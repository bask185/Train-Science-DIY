
C:\Users\sknippels\AppData\Local\Temp\arduino-sketch-53573E213BC4203AD3334DA312EB3A6E/LoPiTS-XS.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
       0:	3e c0       	rjmp	.+124    	; 0x7e <__ctors_end>
       2:	00 00       	nop
../../../../crt1/gcrt1.S:67
       4:	6f c0       	rjmp	.+222    	; 0xe4 <__bad_interrupt>
       6:	00 00       	nop
../../../../crt1/gcrt1.S:68
       8:	6d c0       	rjmp	.+218    	; 0xe4 <__bad_interrupt>
       a:	00 00       	nop
../../../../crt1/gcrt1.S:69
       c:	0c 94 1f 08 	jmp	0x103e	; 0x103e <__vector_3>
../../../../crt1/gcrt1.S:70
      10:	0c 94 1c 08 	jmp	0x1038	; 0x1038 <__vector_4>
../../../../crt1/gcrt1.S:71
      14:	0c 94 19 08 	jmp	0x1032	; 0x1032 <__vector_5>
../../../../crt1/gcrt1.S:72
      18:	65 c0       	rjmp	.+202    	; 0xe4 <__bad_interrupt>
      1a:	00 00       	nop
../../../../crt1/gcrt1.S:73
      1c:	63 c0       	rjmp	.+198    	; 0xe4 <__bad_interrupt>
      1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
      20:	61 c0       	rjmp	.+194    	; 0xe4 <__bad_interrupt>
      22:	00 00       	nop
../../../../crt1/gcrt1.S:75
      24:	5f c0       	rjmp	.+190    	; 0xe4 <__bad_interrupt>
      26:	00 00       	nop
../../../../crt1/gcrt1.S:76
      28:	5d c0       	rjmp	.+186    	; 0xe4 <__bad_interrupt>
      2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
      2c:	5b c0       	rjmp	.+182    	; 0xe4 <__bad_interrupt>
      2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
      30:	59 c0       	rjmp	.+178    	; 0xe4 <__bad_interrupt>
      32:	00 00       	nop
../../../../crt1/gcrt1.S:79
      34:	57 c0       	rjmp	.+174    	; 0xe4 <__bad_interrupt>
      36:	00 00       	nop
../../../../crt1/gcrt1.S:80
      38:	55 c0       	rjmp	.+170    	; 0xe4 <__bad_interrupt>
      3a:	00 00       	nop
../../../../crt1/gcrt1.S:81
      3c:	c0 c7       	rjmp	.+3968   	; 0xfbe <__vector_15>
      3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
      40:	51 c0       	rjmp	.+162    	; 0xe4 <__bad_interrupt>
      42:	00 00       	nop
../../../../crt1/gcrt1.S:83
      44:	4f c0       	rjmp	.+158    	; 0xe4 <__bad_interrupt>
      46:	00 00       	nop
../../../../crt1/gcrt1.S:84
      48:	4d c0       	rjmp	.+154    	; 0xe4 <__bad_interrupt>
      4a:	00 00       	nop
../../../../crt1/gcrt1.S:85
      4c:	4b c0       	rjmp	.+150    	; 0xe4 <__bad_interrupt>
      4e:	00 00       	nop
../../../../crt1/gcrt1.S:86
      50:	49 c0       	rjmp	.+146    	; 0xe4 <__bad_interrupt>
      52:	00 00       	nop
../../../../crt1/gcrt1.S:87
      54:	47 c0       	rjmp	.+142    	; 0xe4 <__bad_interrupt>
      56:	00 00       	nop
../../../../crt1/gcrt1.S:88
      58:	45 c0       	rjmp	.+138    	; 0xe4 <__bad_interrupt>
      5a:	00 00       	nop
../../../../crt1/gcrt1.S:89
      5c:	43 c0       	rjmp	.+134    	; 0xe4 <__bad_interrupt>
      5e:	00 00       	nop
../../../../crt1/gcrt1.S:90
      60:	41 c0       	rjmp	.+130    	; 0xe4 <__bad_interrupt>
      62:	00 00       	nop
../../../../crt1/gcrt1.S:91
      64:	3f c0       	rjmp	.+126    	; 0xe4 <__bad_interrupt>
      66:	00 00       	nop
../../../../crt1/gcrt1.S:92
      68:	3d c0       	rjmp	.+122    	; 0xe4 <__bad_interrupt>
      6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
      6c:	3b c0       	rjmp	.+118    	; 0xe4 <__bad_interrupt>
      6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
      70:	39 c0       	rjmp	.+114    	; 0xe4 <__bad_interrupt>
      72:	00 00       	nop
../../../../crt1/gcrt1.S:95
      74:	37 c0       	rjmp	.+110    	; 0xe4 <__bad_interrupt>
      76:	00 00       	nop
../../../../crt1/gcrt1.S:96
      78:	35 c0       	rjmp	.+106    	; 0xe4 <__bad_interrupt>
	...

0000007c <__ctors_start>:
__trampolines_start():
      7c:	e1 0d       	add	r30, r1

0000007e <__ctors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
      7e:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
      80:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
      82:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
      84:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
      86:	df e3       	ldi	r29, 0x3F	; 63
../../../../crt1/gcrt1.S:237
      88:	de bf       	out	0x3e, r29	; 62

0000008a <_initThreeStuff()>:
_Z15_initThreeStuffv():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/main.cpp:104

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
      8a:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <digital_pin_to_bit_mask+0x7f62c6>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/main.cpp:105
    RSTCTRL.RSTFR = flags;
      8e:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <digital_pin_to_bit_mask+0x7f62c6>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/main.cpp:106
    if (flags == 0) {
      92:	81 11       	cpse	r24, r1
      94:	05 c0       	rjmp	.+10     	; 0xa0 <_initThreeStuff()+0x16>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/main.cpp:107
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
      96:	98 ed       	ldi	r25, 0xD8	; 216
      98:	21 e0       	ldi	r18, 0x01	; 1
      9a:	94 bf       	out	0x34, r25	; 52
      9c:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <digital_pin_to_bit_mask+0x7f62c7>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/main.cpp:109
    }
    GPIOR0 = flags;
      a0:	8c bb       	out	0x1c, r24	; 28

000000a2 <__do_copy_data>:
__do_copy_data():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
      a2:	18 e3       	ldi	r17, 0x38	; 56
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
      a4:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
      a6:	b8 e3       	ldi	r27, 0x38	; 56
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
      a8:	ec e8       	ldi	r30, 0x8C	; 140
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
      aa:	fd e1       	ldi	r31, 0x1D	; 29
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
      ac:	02 c0       	rjmp	.+4      	; 0xb2 <__do_copy_data+0x10>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
      ae:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
      b0:	0d 92       	st	X+, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
      b2:	a6 30       	cpi	r26, 0x06	; 6
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
      b4:	b1 07       	cpc	r27, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
      b6:	d9 f7       	brne	.-10     	; 0xae <__do_copy_data+0xc>

000000b8 <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
      b8:	28 e3       	ldi	r18, 0x38	; 56
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
      ba:	a6 e0       	ldi	r26, 0x06	; 6
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
      bc:	b8 e3       	ldi	r27, 0x38	; 56
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
      be:	01 c0       	rjmp	.+2      	; 0xc2 <.do_clear_bss_start>

000000c0 <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
      c0:	1d 92       	st	X+, r1

000000c2 <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
      c2:	a7 3c       	cpi	r26, 0xC7	; 199
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
      c4:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
      c6:	e1 f7       	brne	.-8      	; 0xc0 <.do_clear_bss_loop>

000000c8 <__do_global_ctors>:
__do_global_ctors():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
      c8:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
      ca:	cf e3       	ldi	r28, 0x3F	; 63
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
      cc:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
      ce:	04 c0       	rjmp	.+8      	; 0xd8 <__do_global_ctors+0x10>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
      d0:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
      d2:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
      d4:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
      d8:	ce 33       	cpi	r28, 0x3E	; 62
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
      da:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
      dc:	c9 f7       	brne	.-14     	; 0xd0 <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
      de:	f9 d7       	rcall	.+4082   	; 0x10d2 <main>
../../../../crt1/gcrt1.S:315
      e0:	0c 94 a0 0e 	jmp	0x1d40	; 0x1d40 <_exit>

000000e4 <__bad_interrupt>:
__vector_22():
../../../../crt1/gcrt1.S:209
      e4:	8d cf       	rjmp	.-230    	; 0x0 <__vectors>

000000e6 <attachInterrupt.constprop.7>:
attachInterrupt.constprop.7():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:79
   * of which there are only 7 ports worth of registers available. So this implementation is guaranteed not to work on a
   * future part with 8 ports anyway. We will cross that bridge once Microchip has announced intent to build it.
   */

  void  attachInterrupt(uint8_t pin, void (*userFunc)(void), uint8_t mode) {
    uint8_t bitpos = digitalPinToBitPosition(pin);
      e6:	82 31       	cpi	r24, 0x12	; 18
      e8:	08 f0       	brcs	.+2      	; 0xec <attachInterrupt.constprop.7+0x6>
      ea:	42 c0       	rjmp	.+132    	; 0x170 <__EEPROM_REGION_LENGTH__+0x70>
      ec:	28 2f       	mov	r18, r24
      ee:	30 e0       	ldi	r19, 0x00	; 0
      f0:	f9 01       	movw	r30, r18
      f2:	ea 5a       	subi	r30, 0xAA	; 170
      f4:	f2 46       	sbci	r31, 0x62	; 98
      f6:	90 81       	ld	r25, Z
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:80
    if (bitpos == NOT_A_PIN) {
      f8:	9f 3f       	cpi	r25, 0xFF	; 255
      fa:	d1 f1       	breq	.+116    	; 0x170 <__EEPROM_REGION_LENGTH__+0x70>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:84
      return;
    }
    uint8_t port = digitalPinToPort(pin);
    switch (mode) {
      fc:	62 30       	cpi	r22, 0x02	; 2
      fe:	59 f0       	breq	.+22     	; 0x116 <__EEPROM_REGION_LENGTH__+0x16>
     100:	20 f4       	brcc	.+8      	; 0x10a <__EEPROM_REGION_LENGTH__+0xa>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:95
        break;
      case RISING:
        mode = PORT_ISC_RISING_gc;
        break;
      case LOW:
        mode = PORT_ISC_LEVEL_gc;
     102:	45 e0       	ldi	r20, 0x05	; 5
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:84
    uint8_t bitpos = digitalPinToBitPosition(pin);
    if (bitpos == NOT_A_PIN) {
      return;
    }
    uint8_t port = digitalPinToPort(pin);
    switch (mode) {
     104:	66 23       	and	r22, r22
     106:	41 f0       	breq	.+16     	; 0x118 <__EEPROM_REGION_LENGTH__+0x18>
     108:	08 95       	ret
     10a:	63 30       	cpi	r22, 0x03	; 3
     10c:	91 f1       	breq	.+100    	; 0x172 <__EEPROM_REGION_LENGTH__+0x72>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:86
      case CHANGE:
        mode = PORT_ISC_BOTHEDGES_gc;
     10e:	41 e0       	ldi	r20, 0x01	; 1
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:84
    uint8_t bitpos = digitalPinToBitPosition(pin);
    if (bitpos == NOT_A_PIN) {
      return;
    }
    uint8_t port = digitalPinToPort(pin);
    switch (mode) {
     110:	64 30       	cpi	r22, 0x04	; 4
     112:	11 f0       	breq	.+4      	; 0x118 <__EEPROM_REGION_LENGTH__+0x18>
     114:	08 95       	ret
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:89
      case CHANGE:
        mode = PORT_ISC_BOTHEDGES_gc;
        break;
      case FALLING:
        mode = PORT_ISC_FALLING_gc;
     116:	43 e0       	ldi	r20, 0x03	; 3
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:83
  void  attachInterrupt(uint8_t pin, void (*userFunc)(void), uint8_t mode) {
    uint8_t bitpos = digitalPinToBitPosition(pin);
    if (bitpos == NOT_A_PIN) {
      return;
    }
    uint8_t port = digitalPinToPort(pin);
     118:	28 59       	subi	r18, 0x98	; 152
     11a:	32 46       	sbci	r19, 0x62	; 98
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:100
        mode = PORT_ISC_LEVEL_gc;
        break;
      default:
        return;
    }
    if (intFunc[port] != NULL && userFunc != NULL) {
     11c:	d9 01       	movw	r26, r18
     11e:	ec 91       	ld	r30, X
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	df 01       	movw	r26, r30
     124:	aa 0f       	add	r26, r26
     126:	bb 1f       	adc	r27, r27
     128:	a0 50       	subi	r26, 0x00	; 0
     12a:	b8 4c       	sbci	r27, 0xC8	; 200
     12c:	2d 91       	ld	r18, X+
     12e:	3c 91       	ld	r19, X
     130:	21 15       	cp	r18, r1
     132:	31 05       	cpc	r19, r1
     134:	e9 f0       	breq	.+58     	; 0x170 <__EEPROM_REGION_LENGTH__+0x70>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:102
      // if it is null the port is not enabled for attachInterrupt, and obviously a null user function is invalid too.
      intFunc[port][bitpos] = userFunc;
     136:	69 2f       	mov	r22, r25
     138:	70 e0       	ldi	r23, 0x00	; 0
     13a:	66 0f       	add	r22, r22
     13c:	77 1f       	adc	r23, r23
     13e:	26 0f       	add	r18, r22
     140:	37 1f       	adc	r19, r23
     142:	67 ef       	ldi	r22, 0xF7	; 247
     144:	70 e0       	ldi	r23, 0x00	; 0
     146:	d9 01       	movw	r26, r18
     148:	6d 93       	st	X+, r22
     14a:	7c 93       	st	X, r23
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:104
      uint8_t portoffset = ((port << 5) & 0xE0) + 0x10 + bitpos;
      uint8_t oldSREG = SREG;
     14c:	5f b7       	in	r21, 0x3f	; 63
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:105
      cli();
     14e:	f8 94       	cli
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:103
        return;
    }
    if (intFunc[port] != NULL && userFunc != NULL) {
      // if it is null the port is not enabled for attachInterrupt, and obviously a null user function is invalid too.
      intFunc[port][bitpos] = userFunc;
      uint8_t portoffset = ((port << 5) & 0xE0) + 0x10 + bitpos;
     150:	9f 01       	movw	r18, r30
     152:	65 e0       	ldi	r22, 0x05	; 5
     154:	22 0f       	add	r18, r18
     156:	33 1f       	adc	r19, r19
     158:	6a 95       	dec	r22
     15a:	e1 f7       	brne	.-8      	; 0x154 <__EEPROM_REGION_LENGTH__+0x54>
     15c:	e0 e1       	ldi	r30, 0x10	; 16
     15e:	e9 0f       	add	r30, r25
     160:	e2 0f       	add	r30, r18
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:107
      uint8_t oldSREG = SREG;
      cli();
      // We now have the port, the mode, the bitpos and the pointer
      uint8_t settings = *(portbase + portoffset) & 0xF8;
     162:	f0 e0       	ldi	r31, 0x00	; 0
     164:	fc 5f       	subi	r31, 0xFC	; 252
     166:	80 81       	ld	r24, Z
     168:	88 7f       	andi	r24, 0xF8	; 248
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:108
      *(portbase + portoffset) = settings | mode;
     16a:	84 2b       	or	r24, r20
     16c:	80 83       	st	Z, r24
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:109
      SREG = oldSREG;
     16e:	5f bf       	out	0x3f, r21	; 63
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:111
    }
  }
     170:	08 95       	ret
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:92
        break;
      case FALLING:
        mode = PORT_ISC_FALLING_gc;
        break;
      case RISING:
        mode = PORT_ISC_RISING_gc;
     172:	42 e0       	ldi	r20, 0x02	; 2
     174:	d1 cf       	rjmp	.-94     	; 0x118 <__EEPROM_REGION_LENGTH__+0x18>

00000176 <micros>:
micros():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:521
    #else /* TCA */
      uint8_t ticks;
    #endif
    uint8_t flags;
    /* Save current state and disable interrupts */
    uint8_t oldSREG = SREG;
     176:	9f b7       	in	r25, 0x3f	; 63
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:522
    cli(); /* INTERRUPTS OFF */
     178:	f8 94       	cli
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:527
    #if defined(MILLIS_USE_TIMERA0)
      ticks = TCA0.SPLIT.HCNT;
      flags = TCA0.SPLIT.INTFLAGS;
    #elif defined(MILLIS_USE_TIMERD0)
      TCD0.CTRLE = TCD_SCAPTUREA_bm;
     17a:	88 e0       	ldi	r24, 0x08	; 8
     17c:	80 93 84 0a 	sts	0x0A84, r24	; 0x800a84 <digital_pin_to_bit_mask+0x7f6d0a>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:528
      while (!(TCD0.STATUS & TCD_CMDRDY_bm)); // wait for sync - should be only one iteration of this loop
     180:	80 91 8e 0a 	lds	r24, 0x0A8E	; 0x800a8e <digital_pin_to_bit_mask+0x7f6d14>
     184:	81 ff       	sbrs	r24, 1
     186:	fc cf       	rjmp	.-8      	; 0x180 <micros+0xa>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:529
      flags = TCD0.INTFLAGS;
     188:	80 91 8d 0a 	lds	r24, 0x0A8D	; 0x800a8d <digital_pin_to_bit_mask+0x7f6d13>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:530
      ticks = TCD0.CAPTUREA;
     18c:	e0 91 a2 0a 	lds	r30, 0x0AA2	; 0x800aa2 <digital_pin_to_bit_mask+0x7f6d28>
     190:	f0 91 a3 0a 	lds	r31, 0x0AA3	; 0x800aa3 <digital_pin_to_bit_mask+0x7f6d29>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:541
     * ISR has not fired. If we already read a high value of ticks, either we read it just before the overflow,
     * so we shouldn't increment overflows, or interrupts are disabled and micros isn't expected to work so it
     * doesn't matter.
     * Get current number of overflows and timer count */
    #if !((defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1) || defined(MILLIS_USE_TIMERB2) || defined(MILLIS_USE_TIMERB3) || defined(MILLIS_USE_TIMERB4)))
      overflows = timingStruct.timer_overflow_count;
     194:	20 91 35 38 	lds	r18, 0x3835	; 0x803835 <timingStruct+0x6>
     198:	30 91 36 38 	lds	r19, 0x3836	; 0x803836 <timingStruct+0x7>
     19c:	40 91 37 38 	lds	r20, 0x3837	; 0x803837 <timingStruct+0x8>
     1a0:	50 91 38 38 	lds	r21, 0x3838	; 0x803838 <timingStruct+0x9>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:546
    #else
      overflows = timingStruct.timer_millis;
    #endif
    /* Turn interrupts back on, assuming they were on when micros was called. */
    SREG = oldSREG; /* INTERRUPTS ON */
     1a4:	9f bf       	out	0x3f, r25	; 63
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:548
    #if defined(MILLIS_USE_TIMERD0)
      if ((flags & TCD_OVF_bm) && (ticks < 0x07)) {
     1a6:	80 ff       	sbrs	r24, 0
     1a8:	07 c0       	rjmp	.+14     	; 0x1b8 <micros+0x42>
     1aa:	e7 30       	cpi	r30, 0x07	; 7
     1ac:	f1 05       	cpc	r31, r1
     1ae:	20 f4       	brcc	.+8      	; 0x1b8 <micros+0x42>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:558
      if ((flags & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
    #endif
    #if ((defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1) || defined(MILLIS_USE_TIMERB2) || defined(MILLIS_USE_TIMERB3) || defined(MILLIS_USE_TIMERB4)) && !(F_CPU > 2000000UL))
      overflows +=2;
    #else
      overflows++;
     1b0:	2f 5f       	subi	r18, 0xFF	; 255
     1b2:	3f 4f       	sbci	r19, 0xFF	; 255
     1b4:	4f 4f       	sbci	r20, 0xFF	; 255
     1b6:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:564
    #endif
      } // end getting ticks

    #if defined(MILLIS_USE_TIMERD0)
      #if (F_CPU == 20000000UL || F_CPU == 10000000UL || F_CPU == 5000000UL)
        uint8_t ticks_l = ticks >> 1;
     1b8:	bf 01       	movw	r22, r30
     1ba:	76 95       	lsr	r23
     1bc:	67 95       	ror	r22
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:565
        ticks = ticks + ticks_l + ((ticks_l >> 2) - (ticks_l >> 4) + (ticks_l >> 7));
     1be:	cf 01       	movw	r24, r30
     1c0:	86 0f       	add	r24, r22
     1c2:	91 1d       	adc	r25, r1
     1c4:	e6 2f       	mov	r30, r22
     1c6:	e6 95       	lsr	r30
     1c8:	e6 95       	lsr	r30
     1ca:	76 2f       	mov	r23, r22
     1cc:	72 95       	swap	r23
     1ce:	7f 70       	andi	r23, 0x0F	; 15
     1d0:	e7 1b       	sub	r30, r23
     1d2:	ff 0b       	sbc	r31, r31
     1d4:	67 fd       	sbrc	r22, 7
     1d6:	31 96       	adiw	r30, 0x01	; 1
     1d8:	e8 0f       	add	r30, r24
     1da:	f9 1f       	adc	r31, r25
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:568
        // + ticks +(ticks>>1)+(ticks>>3)-(ticks>>5)+(ticks>>8))
        // speed optimization via doing math with smaller datatypes, since we know high byte is 1 or 0.
        microseconds =   overflows * (TIME_TRACKING_CYCLES_PER_OVF / 20) + ticks; // ticks value corrected above.
     1dc:	a0 e3       	ldi	r26, 0x30	; 48
     1de:	b3 e0       	ldi	r27, 0x03	; 3
     1e0:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <__muluhisi3>
     1e4:	6e 0f       	add	r22, r30
     1e6:	7f 1f       	adc	r23, r31
     1e8:	81 1d       	adc	r24, r1
     1ea:	91 1d       	adc	r25, r1
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:906
        microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                      + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
      #endif
    #endif // end of timer-specific part of micros calculations
    return microseconds;
  }
     1ec:	08 95       	ret

000001ee <ExternalInterruptHandler()>:
_Z24ExternalInterruptHandlerv():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:339
#elif defined(ESP8266)
    void ICACHE_RAM_ATTR ExternalInterruptHandler (void)
#else
    void ExternalInterruptHandler (void)
#endif
{
     1ee:	ff 92       	push	r15
     1f0:	0f 93       	push	r16
     1f2:	1f 93       	push	r17
     1f4:	cf 93       	push	r28
     1f6:	df 93       	push	r29
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:384
        #endif
        SET_TP3;
        return; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> abort IRQ
    }
    #endif
    actMicros = micros();
     1f8:	be df       	rcall	.-132    	; 0x176 <micros>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:385
    bitMicros = actMicros-lastMicros;
     1fa:	20 91 2d 38 	lds	r18, 0x382D	; 0x80382d <ExternalInterruptHandler()::lastMicros>
     1fe:	30 91 2e 38 	lds	r19, 0x382E	; 0x80382e <ExternalInterruptHandler()::lastMicros+0x1>
     202:	eb 01       	movw	r28, r22
     204:	c2 1b       	sub	r28, r18
     206:	d3 0b       	sbc	r29, r19
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:390

    CLR_TP3;
    SET_TP3;
    #ifdef __AVR_MEGA__
    if (bitMicros < bitMin || (DccRx.State != WAIT_START_BIT && (*DccProcState.ExtIntPort & DccProcState.ExtIntMask) != (ISRLevel)))
     208:	20 91 3b 38 	lds	r18, 0x383B	; 0x80383b <bitMin>
     20c:	30 91 3c 38 	lds	r19, 0x383C	; 0x80383c <bitMin+0x1>
     210:	c2 17       	cp	r28, r18
     212:	d3 07       	cpc	r29, r19
     214:	08 f4       	brcc	.+2      	; 0x218 <ExternalInterruptHandler()+0x2a>
     216:	5d c0       	rjmp	.+186    	; 0x2d2 <ExternalInterruptHandler()+0xe4>
     218:	40 91 3f 38 	lds	r20, 0x383F	; 0x80383f <DccRx>
     21c:	50 91 40 38 	lds	r21, 0x3840	; 0x803840 <DccRx+0x1>
     220:	41 30       	cpi	r20, 0x01	; 1
     222:	51 05       	cpc	r21, r1
     224:	61 f0       	breq	.+24     	; 0x23e <ExternalInterruptHandler()+0x50>
     226:	e0 91 c0 38 	lds	r30, 0x38C0	; 0x8038c0 <DccProcState+0x13>
     22a:	f0 91 c1 38 	lds	r31, 0x38C1	; 0x8038c1 <DccProcState+0x14>
     22e:	20 81       	ld	r18, Z
     230:	30 91 c2 38 	lds	r19, 0x38C2	; 0x8038c2 <DccProcState+0x15>
     234:	23 23       	and	r18, r19
     236:	30 91 39 38 	lds	r19, 0x3839	; 0x803839 <ISRLevel>
     23a:	23 13       	cpse	r18, r19
     23c:	4a c0       	rjmp	.+148    	; 0x2d2 <ExternalInterruptHandler()+0xe4>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:404
        return; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> abort IRQ
    }
    CLR_TP3;
    SET_TP3;

    lastMicros = actMicros;
     23e:	60 93 2d 38 	sts	0x382D, r22	; 0x80382d <ExternalInterruptHandler()::lastMicros>
     242:	70 93 2e 38 	sts	0x382E, r23	; 0x80382e <ExternalInterruptHandler()::lastMicros+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:435
    }
    CLR_TP3;
    SET_TP3;
    #endif

    DccBitVal = (bitMicros < bitMax);
     246:	00 91 3d 38 	lds	r16, 0x383D	; 0x80383d <bitMax>
     24a:	10 91 3e 38 	lds	r17, 0x383E	; 0x80383e <bitMax+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:445
    #endif

    #ifdef DCC_DEBUG
    DccProcState.TickCount++;
    #endif
    switch (DccRx.State)
     24e:	42 30       	cpi	r20, 0x02	; 2
     250:	51 05       	cpc	r21, r1
     252:	09 f4       	brne	.+2      	; 0x256 <ExternalInterruptHandler()+0x68>
     254:	0d c1       	rjmp	.+538    	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
     256:	43 30       	cpi	r20, 0x03	; 3
     258:	51 05       	cpc	r21, r1
     25a:	09 f4       	brne	.+2      	; 0x25e <ExternalInterruptHandler()+0x70>
     25c:	48 c1       	rjmp	.+656    	; 0x4ee <__LOCK_REGION_LENGTH__+0xee>
     25e:	41 30       	cpi	r20, 0x01	; 1
     260:	51 05       	cpc	r21, r1
     262:	61 f4       	brne	.+24     	; 0x27c <ExternalInterruptHandler()+0x8e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:476
        }
        break;
        #endif
    case WAIT_START_BIT:
        // we are looking for first half "0" bit after preamble
        switch (halfBit)
     264:	80 91 2c 38 	lds	r24, 0x382C	; 0x80382c <ExternalInterruptHandler()::halfBit>
     268:	81 30       	cpi	r24, 0x01	; 1
     26a:	09 f4       	brne	.+2      	; 0x26e <ExternalInterruptHandler()+0x80>
     26c:	45 c0       	rjmp	.+138    	; 0x2f8 <ExternalInterruptHandler()+0x10a>
     26e:	b8 f1       	brcs	.+110    	; 0x2de <ExternalInterruptHandler()+0xf0>
     270:	83 30       	cpi	r24, 0x03	; 3
     272:	09 f4       	brne	.+2      	; 0x276 <ExternalInterruptHandler()+0x88>
     274:	7e c0       	rjmp	.+252    	; 0x372 <ExternalInterruptHandler()+0x184>
     276:	84 30       	cpi	r24, 0x04	; 4
     278:	09 f4       	brne	.+2      	; 0x27c <ExternalInterruptHandler()+0x8e>
     27a:	c3 c0       	rjmp	.+390    	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:720

    // unless we're already looking for the start bit
    // we always search for a preamble ( ( 10 or more consecutive 1 bits )
    // if we found it within a packet, the packet decoding is aborted because
    // that much one bits cannot be valid in a packet.
    if (DccRx.State != WAIT_START_BIT)
     27c:	80 91 3f 38 	lds	r24, 0x383F	; 0x80383f <DccRx>
     280:	90 91 40 38 	lds	r25, 0x3840	; 0x803840 <DccRx+0x1>
     284:	01 97       	sbiw	r24, 0x01	; 1
     286:	29 f1       	breq	.+74     	; 0x2d2 <ExternalInterruptHandler()+0xe4>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:722
    {
        if (DccBitVal)
     288:	c0 17       	cp	r28, r16
     28a:	d1 07       	cpc	r29, r17
     28c:	08 f0       	brcs	.+2      	; 0x290 <ExternalInterruptHandler()+0xa2>
     28e:	67 c1       	rjmp	.+718    	; 0x55e <__LOCK_REGION_LENGTH__+0x15e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:724
        {
            preambleBitCount++;
     290:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <ExternalInterruptHandler()::preambleBitCount>
     294:	8f 5f       	subi	r24, 0xFF	; 255
     296:	80 93 2a 38 	sts	0x382A, r24	; 0x80382a <ExternalInterruptHandler()::preambleBitCount>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:726
            //SET_TP2;
            if (preambleBitCount > 10)
     29a:	8b 30       	cpi	r24, 0x0B	; 11
     29c:	d0 f0       	brcs	.+52     	; 0x2d2 <ExternalInterruptHandler()+0xe4>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:738
                    DccRx.State = WAIT_START_BIT_FULL;
                }
                else
                {
                #endif
                    DccRx.State = WAIT_START_BIT ;
     29e:	81 e0       	ldi	r24, 0x01	; 1
     2a0:	90 e0       	ldi	r25, 0x00	; 0
     2a2:	80 93 3f 38 	sts	0x383F, r24	; 0x80383f <DccRx>
     2a6:	90 93 40 38 	sts	0x3840, r25	; 0x803840 <DccRx+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:749
                    detachInterrupt (DccProcState.ExtIntNum);
                    #endif
                    #ifdef ESP32
                    ISRWatch = CHANGE;
                    #else
                    attachInterrupt (DccProcState.ExtIntNum, ExternalInterruptHandler, CHANGE);
     2aa:	64 e0       	ldi	r22, 0x04	; 4
     2ac:	80 91 be 38 	lds	r24, 0x38BE	; 0x8038be <DccProcState+0x11>
     2b0:	1a df       	rcall	.-460    	; 0xe6 <attachInterrupt.constprop.7>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:752
                    #endif
                    ISRChkMask = 0;         // AVR level check is always true with this settings
                    ISRLevel = 0;           // ( there cannot be false edge IRQ's with CHANGE )
     2b2:	10 92 39 38 	sts	0x3839, r1	; 0x803839 <ISRLevel>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:753
                    halfBit = 0;
     2b6:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <ExternalInterruptHandler()::halfBit>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:754
                    bitMax = MAX_ONEBITHALF;
     2ba:	82 e5       	ldi	r24, 0x52	; 82
     2bc:	90 e0       	ldi	r25, 0x00	; 0
     2be:	80 93 3d 38 	sts	0x383D, r24	; 0x80383d <bitMax>
     2c2:	90 93 3e 38 	sts	0x383E, r25	; 0x80383e <bitMax+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:755
                    bitMin = MIN_ONEBITHALF;
     2c6:	83 e2       	ldi	r24, 0x23	; 35
     2c8:	90 e0       	ldi	r25, 0x00	; 0
     2ca:	80 93 3b 38 	sts	0x383B, r24	; 0x80383b <bitMin>
     2ce:	90 93 3c 38 	sts	0x383C, r25	; 0x80383c <bitMin+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:775
    #ifdef ALLOW_NESTED_IRQ
    DCC_IrqRunning = false;
    #endif
    //CLR_TP1;
    CLR_TP3;
}
     2d2:	df 91       	pop	r29
     2d4:	cf 91       	pop	r28
     2d6:	1f 91       	pop	r17
     2d8:	0f 91       	pop	r16
     2da:	ff 90       	pop	r15
     2dc:	08 95       	ret
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:480
        // we are looking for first half "0" bit after preamble
        switch (halfBit)
        {
        case 0:
            // check first part
            if (DccBitVal)
     2de:	c0 17       	cp	r28, r16
     2e0:	d1 07       	cpc	r29, r17
     2e2:	30 f4       	brcc	.+12     	; 0x2f0 <ExternalInterruptHandler()+0x102>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:483
            {
                // is still 1-bit (Preamble)
                halfBit=1;
     2e4:	81 e0       	ldi	r24, 0x01	; 1
     2e6:	80 93 2c 38 	sts	0x382C, r24	; 0x80382c <ExternalInterruptHandler()::halfBit>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:484
                bit1=bitMicros;
     2ea:	c0 93 2b 38 	sts	0x382B, r28	; 0x80382b <ExternalInterruptHandler()::bit1>
     2ee:	c6 cf       	rjmp	.-116    	; 0x27c <ExternalInterruptHandler()+0x8e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:489
            }
            else
            {
                // was "0" half bit, maybe the startbit
                halfBit = 4;
     2f0:	84 e0       	ldi	r24, 0x04	; 4
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:527
            else
            {
                // first '0' half detected in second halfBit
                // wrong sync or not a DCC protokoll
                CLR_TP3;
                halfBit = 3;
     2f2:	80 93 2c 38 	sts	0x382C, r24	; 0x80382c <ExternalInterruptHandler()::halfBit>
     2f6:	c2 cf       	rjmp	.-124    	; 0x27c <ExternalInterruptHandler()+0x8e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:493
                // was "0" half bit, maybe the startbit
                halfBit = 4;
            }
            break;
        case 1: // previous halfbit was '1'
            if (DccBitVal)
     2f8:	c0 17       	cp	r28, r16
     2fa:	d1 07       	cpc	r29, r17
     2fc:	c0 f5       	brcc	.+112    	; 0x36e <ExternalInterruptHandler()+0x180>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:496
            {
                // its a '1' halfBit -> we are still in the preamble
                halfBit = 0;
     2fe:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <ExternalInterruptHandler()::halfBit>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:498
                bit2=bitMicros;
                preambleBitCount++;
     302:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <ExternalInterruptHandler()::preambleBitCount>
     306:	8f 5f       	subi	r24, 0xFF	; 255
     308:	80 93 2a 38 	sts	0x382A, r24	; 0x80382a <ExternalInterruptHandler()::preambleBitCount>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:499
                if (abs (bit2-bit1) > MAX_BITDIFF)
     30c:	20 91 2b 38 	lds	r18, 0x382B	; 0x80382b <ExternalInterruptHandler()::bit1>
     310:	8c 2f       	mov	r24, r28
     312:	0c 2e       	mov	r0, r28
     314:	00 0c       	add	r0, r0
     316:	99 0b       	sbc	r25, r25
     318:	82 1b       	sub	r24, r18
     31a:	91 09       	sbc	r25, r1
     31c:	27 fd       	sbrc	r18, 7
     31e:	93 95       	inc	r25
     320:	97 ff       	sbrs	r25, 7
     322:	03 c0       	rjmp	.+6      	; 0x32a <ExternalInterruptHandler()+0x13c>
     324:	91 95       	neg	r25
     326:	81 95       	neg	r24
     328:	91 09       	sbc	r25, r1
     32a:	49 97       	sbiw	r24, 0x19	; 25
     32c:	94 f2       	brlt	.-92     	; 0x2d2 <ExternalInterruptHandler()+0xe4>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:502
                {
                    // the length of the 2 halfbits differ too much -> wrong protokoll
                    DccRx.State = WAIT_PREAMBLE;
     32e:	10 92 3f 38 	sts	0x383F, r1	; 0x80383f <DccRx>
     332:	10 92 40 38 	sts	0x3840, r1	; 0x803840 <DccRx+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:503
                    bitMax = MAX_PRAEAMBEL;
     336:	82 e9       	ldi	r24, 0x92	; 146
     338:	90 e0       	ldi	r25, 0x00	; 0
     33a:	80 93 3d 38 	sts	0x383D, r24	; 0x80383d <bitMax>
     33e:	90 93 3e 38 	sts	0x383E, r25	; 0x80383e <bitMax+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:504
                    bitMin = MIN_ONEBITFULL;
     342:	82 e5       	ldi	r24, 0x52	; 82
     344:	90 e0       	ldi	r25, 0x00	; 0
     346:	80 93 3b 38 	sts	0x383B, r24	; 0x80383b <bitMin>
     34a:	90 93 3c 38 	sts	0x383C, r25	; 0x80383c <bitMin+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:505
                    preambleBitCount = 0;
     34e:	10 92 2a 38 	sts	0x382A, r1	; 0x80382a <ExternalInterruptHandler()::preambleBitCount>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:619
            #endif

            #if defined(ESP32)
            ISRWatch = ISREdge;
            #else
            attachInterrupt (DccProcState.ExtIntNum, ExternalInterruptHandler, ISREdge);
     352:	f0 90 3a 38 	lds	r15, 0x383A	; 0x80383a <ISREdge>
     356:	6f 2d       	mov	r22, r15
     358:	80 91 be 38 	lds	r24, 0x38BE	; 0x8038be <DccProcState+0x11>
     35c:	c4 de       	rcall	.-632    	; 0xe6 <attachInterrupt.constprop.7>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:622
            #endif
            // enable level-checking
            ISRChkMask = DccProcState.ExtIntMask;
     35e:	80 91 c2 38 	lds	r24, 0x38C2	; 0x8038c2 <DccProcState+0x15>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:623
            ISRLevel = (ISREdge==RISING) ? DccProcState.ExtIntMask : 0 ;
     362:	93 e0       	ldi	r25, 0x03	; 3
     364:	f9 12       	cpse	r15, r25
     366:	25 c0       	rjmp	.+74     	; 0x3b2 <ExternalInterruptHandler()+0x1c4>
     368:	80 93 39 38 	sts	0x3839, r24	; 0x803839 <ISRLevel>
     36c:	87 cf       	rjmp	.-242    	; 0x27c <ExternalInterruptHandler()+0x8e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:527
            else
            {
                // first '0' half detected in second halfBit
                // wrong sync or not a DCC protokoll
                CLR_TP3;
                halfBit = 3;
     36e:	83 e0       	ldi	r24, 0x03	; 3
     370:	c0 cf       	rjmp	.-128    	; 0x2f2 <ExternalInterruptHandler()+0x104>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:532
                SET_TP3;
            }
            break;
        case 3: // previous halfbit was '0'  in second halfbit
            if (DccBitVal)
     372:	c0 17       	cp	r28, r16
     374:	d1 07       	cpc	r29, r17
     376:	f8 f4       	brcc	.+62     	; 0x3b6 <ExternalInterruptHandler()+0x1c8>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:535
            {
                // its a '1' halfbit -> we got only a half '0' bit -> cannot be DCC
                DccRx.State = WAIT_PREAMBLE;
     378:	10 92 3f 38 	sts	0x383F, r1	; 0x80383f <DccRx>
     37c:	10 92 40 38 	sts	0x3840, r1	; 0x803840 <DccRx+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:536
                bitMax = MAX_PRAEAMBEL;
     380:	82 e9       	ldi	r24, 0x92	; 146
     382:	90 e0       	ldi	r25, 0x00	; 0
     384:	80 93 3d 38 	sts	0x383D, r24	; 0x80383d <bitMax>
     388:	90 93 3e 38 	sts	0x383E, r25	; 0x80383e <bitMax+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:537
                bitMin = MIN_ONEBITFULL;
     38c:	82 e5       	ldi	r24, 0x52	; 82
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	80 93 3b 38 	sts	0x383B, r24	; 0x80383b <bitMin>
     394:	90 93 3c 38 	sts	0x383C, r25	; 0x80383c <bitMin+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:538
                preambleBitCount = 0;
     398:	10 92 2a 38 	sts	0x382A, r1	; 0x80382a <ExternalInterruptHandler()::preambleBitCount>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:570
            detachInterrupt (DccProcState.ExtIntNum);
            #endif
            #if defined(ESP32)
            ISRWatch = ISREdge;
            #else
            attachInterrupt (DccProcState.ExtIntNum, ExternalInterruptHandler, ISREdge);
     39c:	f0 90 3a 38 	lds	r15, 0x383A	; 0x80383a <ISREdge>
     3a0:	6f 2d       	mov	r22, r15
     3a2:	80 91 be 38 	lds	r24, 0x38BE	; 0x8038be <DccProcState+0x11>
     3a6:	9f de       	rcall	.-706    	; 0xe6 <attachInterrupt.constprop.7>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:573
            #endif
            // enable level-checking
            ISRChkMask = DccProcState.ExtIntMask;
     3a8:	80 91 c2 38 	lds	r24, 0x38C2	; 0x8038c2 <DccProcState+0x15>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:574
            ISRLevel = (ISREdge==RISING) ? DccProcState.ExtIntMask : 0 ;
     3ac:	33 e0       	ldi	r19, 0x03	; 3
     3ae:	f3 16       	cp	r15, r19
     3b0:	d9 f2       	breq	.-74     	; 0x368 <ExternalInterruptHandler()+0x17a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:623
            #else
            attachInterrupt (DccProcState.ExtIntNum, ExternalInterruptHandler, ISREdge);
            #endif
            // enable level-checking
            ISRChkMask = DccProcState.ExtIntMask;
            ISRLevel = (ISREdge==RISING) ? DccProcState.ExtIntMask : 0 ;
     3b2:	80 e0       	ldi	r24, 0x00	; 0
     3b4:	d9 cf       	rjmp	.-78     	; 0x368 <ExternalInterruptHandler()+0x17a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:547
            {
                // we got two '0' halfbits -> it's the startbit
                // but sync is NOT ok, change IRQ edge.
                CLR_TP2;
                CLR_TP1;
                if (ISREdge == RISING) ISREdge = FALLING;
     3b6:	90 91 3a 38 	lds	r25, 0x383A	; 0x80383a <ISREdge>
     3ba:	93 30       	cpi	r25, 0x03	; 3
     3bc:	09 f4       	brne	.+2      	; 0x3c0 <ExternalInterruptHandler()+0x1d2>
     3be:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:548
                else ISREdge = RISING;
     3c0:	80 93 3a 38 	sts	0x383A, r24	; 0x80383a <ISREdge>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:549
                DccRx.State = WAIT_DATA ;
     3c4:	82 e0       	ldi	r24, 0x02	; 2
     3c6:	90 e0       	ldi	r25, 0x00	; 0
     3c8:	80 93 3f 38 	sts	0x383F, r24	; 0x80383f <DccRx>
     3cc:	90 93 40 38 	sts	0x3840, r25	; 0x803840 <DccRx+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:551
                CLR_TP1;
                bitMax = MAX_ONEBITFULL;
     3d0:	82 e9       	ldi	r24, 0x92	; 146
     3d2:	90 e0       	ldi	r25, 0x00	; 0
     3d4:	80 93 3d 38 	sts	0x383D, r24	; 0x80383d <bitMax>
     3d8:	90 93 3e 38 	sts	0x383E, r25	; 0x80383e <bitMax+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:552
                bitMin = MIN_ONEBITFULL;
     3dc:	82 e5       	ldi	r24, 0x52	; 82
     3de:	90 e0       	ldi	r25, 0x00	; 0
     3e0:	80 93 3b 38 	sts	0x383B, r24	; 0x80383b <bitMin>
     3e4:	90 93 3c 38 	sts	0x383C, r25	; 0x80383c <bitMin+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:553
                DccRx.PacketBuf.Size = 0;
     3e8:	10 92 45 38 	sts	0x3845, r1	; 0x803845 <DccRx+0x6>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:556
                /*for(uint8_t i = 0; i< MAX_DCC_MESSAGE_LEN; i++ )
                DccRx.PacketBuf.Data[i] = 0;*/
                DccRx.PacketBuf.PreambleBits = preambleBitCount;
     3ec:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <ExternalInterruptHandler()::preambleBitCount>
     3f0:	80 93 46 38 	sts	0x3846, r24	; 0x803846 <DccRx+0x7>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:557
                DccRx.BitCount = 0 ;
     3f4:	10 92 42 38 	sts	0x3842, r1	; 0x803842 <DccRx+0x3>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:558
                DccRx.chkSum = 0 ;
     3f8:	10 92 44 38 	sts	0x3844, r1	; 0x803844 <DccRx+0x5>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:559
                DccRx.TempByte = 0 ;
     3fc:	10 92 43 38 	sts	0x3843, r1	; 0x803843 <DccRx+0x4>
     400:	cd cf       	rjmp	.-102    	; 0x39c <ExternalInterruptHandler()+0x1ae>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:579
            ISRLevel = (ISREdge==RISING) ? DccProcState.ExtIntMask : 0 ;
            //CLR_TP4;
            break;
        case 4: // previous (first) halfbit was 0
            // if this halfbit is 0 too, we got the startbit
            if (DccBitVal)
     402:	c0 17       	cp	r28, r16
     404:	d1 07       	cpc	r29, r17
     406:	a8 f4       	brcc	.+42     	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:582
            {
                // second halfbit is 1 -> unknown protokoll
                DccRx.State = WAIT_PREAMBLE;
     408:	10 92 3f 38 	sts	0x383F, r1	; 0x80383f <DccRx>
     40c:	10 92 40 38 	sts	0x3840, r1	; 0x803840 <DccRx+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:583
                bitMax = MAX_PRAEAMBEL;
     410:	82 e9       	ldi	r24, 0x92	; 146
     412:	90 e0       	ldi	r25, 0x00	; 0
     414:	80 93 3d 38 	sts	0x383D, r24	; 0x80383d <bitMax>
     418:	90 93 3e 38 	sts	0x383E, r25	; 0x80383e <bitMax+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:584
                bitMin = MIN_ONEBITFULL;
     41c:	82 e5       	ldi	r24, 0x52	; 82
     41e:	90 e0       	ldi	r25, 0x00	; 0
     420:	80 93 3b 38 	sts	0x383B, r24	; 0x80383b <bitMin>
     424:	90 93 3c 38 	sts	0x383C, r25	; 0x80383c <bitMin+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:585
                preambleBitCount = 0;
     428:	10 92 2a 38 	sts	0x382A, r1	; 0x80382a <ExternalInterruptHandler()::preambleBitCount>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:588
                CLR_TP2;
                CLR_TP1;
                DccRx.BitCount = 0;
     42c:	10 92 42 38 	sts	0x3842, r1	; 0x803842 <DccRx+0x3>
     430:	90 cf       	rjmp	.-224    	; 0x352 <ExternalInterruptHandler()+0x164>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:595
            else
            {
                // we got the startbit
                CLR_TP2;
                CLR_TP1;
                DccRx.State = WAIT_DATA ;
     432:	82 e0       	ldi	r24, 0x02	; 2
     434:	90 e0       	ldi	r25, 0x00	; 0
     436:	80 93 3f 38 	sts	0x383F, r24	; 0x80383f <DccRx>
     43a:	90 93 40 38 	sts	0x3840, r25	; 0x803840 <DccRx+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:597
                CLR_TP1;
                bitMax = MAX_ONEBITFULL;
     43e:	82 e9       	ldi	r24, 0x92	; 146
     440:	90 e0       	ldi	r25, 0x00	; 0
     442:	80 93 3d 38 	sts	0x383D, r24	; 0x80383d <bitMax>
     446:	90 93 3e 38 	sts	0x383E, r25	; 0x80383e <bitMax+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:598
                bitMin = MIN_ONEBITFULL;
     44a:	82 e5       	ldi	r24, 0x52	; 82
     44c:	90 e0       	ldi	r25, 0x00	; 0
     44e:	80 93 3b 38 	sts	0x383B, r24	; 0x80383b <bitMin>
     452:	90 93 3c 38 	sts	0x383C, r25	; 0x80383c <bitMin+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:600
                // initialize packet buffer
                DccRx.PacketBuf.Size = 0;
     456:	10 92 45 38 	sts	0x3845, r1	; 0x803845 <DccRx+0x6>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:603
                /*for(uint8_t i = 0; i< MAX_DCC_MESSAGE_LEN; i++ )
                DccRx.PacketBuf.Data[i] = 0;*/
                DccRx.PacketBuf.PreambleBits = preambleBitCount;
     45a:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <ExternalInterruptHandler()::preambleBitCount>
     45e:	80 93 46 38 	sts	0x3846, r24	; 0x803846 <DccRx+0x7>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:604
                DccRx.BitCount = 0 ;
     462:	10 92 42 38 	sts	0x3842, r1	; 0x803842 <DccRx+0x3>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:605
                DccRx.chkSum = 0 ;
     466:	10 92 44 38 	sts	0x3844, r1	; 0x803844 <DccRx+0x5>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:606
                DccRx.TempByte = 0 ;
     46a:	10 92 43 38 	sts	0x3843, r1	; 0x803843 <DccRx+0x4>
     46e:	71 cf       	rjmp	.-286    	; 0x352 <ExternalInterruptHandler()+0x164>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:633
        }
        break;

    case WAIT_DATA:
        CLR_TP2;
        DccRx.BitCount++;
     470:	90 91 42 38 	lds	r25, 0x3842	; 0x803842 <DccRx+0x3>
     474:	9f 5f       	subi	r25, 0xFF	; 255
     476:	90 93 42 38 	sts	0x3842, r25	; 0x803842 <DccRx+0x3>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:634
        DccRx.TempByte = (DccRx.TempByte << 1) ;
     47a:	80 91 43 38 	lds	r24, 0x3843	; 0x803843 <DccRx+0x4>
     47e:	88 0f       	add	r24, r24
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:635
        if (DccBitVal)
     480:	c0 17       	cp	r28, r16
     482:	d1 07       	cpc	r29, r17
     484:	e0 f0       	brcs	.+56     	; 0x4be <__LOCK_REGION_LENGTH__+0xbe>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:636
            DccRx.TempByte |= 1 ;
     486:	80 93 43 38 	sts	0x3843, r24	; 0x803843 <DccRx+0x4>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:638

        if (DccRx.BitCount == 8)
     48a:	98 30       	cpi	r25, 0x08	; 8
     48c:	09 f0       	breq	.+2      	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
     48e:	fc ce       	rjmp	.-520    	; 0x288 <ExternalInterruptHandler()+0x9a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:640
        {
            if (DccRx.PacketBuf.Size == MAX_DCC_MESSAGE_LEN)  // Packet is too long - abort
     490:	e0 91 45 38 	lds	r30, 0x3845	; 0x803845 <DccRx+0x6>
     494:	e6 30       	cpi	r30, 0x06	; 6
     496:	a9 f4       	brne	.+42     	; 0x4c2 <__LOCK_REGION_LENGTH__+0xc2>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:642
            {
                DccRx.State = WAIT_PREAMBLE ;
     498:	10 92 3f 38 	sts	0x383F, r1	; 0x80383f <DccRx>
     49c:	10 92 40 38 	sts	0x3840, r1	; 0x803840 <DccRx+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:643
                bitMax = MAX_PRAEAMBEL;
     4a0:	82 e9       	ldi	r24, 0x92	; 146
     4a2:	90 e0       	ldi	r25, 0x00	; 0
     4a4:	80 93 3d 38 	sts	0x383D, r24	; 0x80383d <bitMax>
     4a8:	90 93 3e 38 	sts	0x383E, r25	; 0x80383e <bitMax+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:644
                bitMin = MIN_ONEBITFULL;
     4ac:	82 e5       	ldi	r24, 0x52	; 82
     4ae:	90 e0       	ldi	r25, 0x00	; 0
     4b0:	80 93 3b 38 	sts	0x383B, r24	; 0x80383b <bitMin>
     4b4:	90 93 3c 38 	sts	0x383C, r25	; 0x80383c <bitMin+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:645
                DccRx.BitCount = 0 ;
     4b8:	10 92 42 38 	sts	0x3842, r1	; 0x803842 <DccRx+0x3>
     4bc:	df ce       	rjmp	.-578    	; 0x27c <ExternalInterruptHandler()+0x8e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:636
    case WAIT_DATA:
        CLR_TP2;
        DccRx.BitCount++;
        DccRx.TempByte = (DccRx.TempByte << 1) ;
        if (DccBitVal)
            DccRx.TempByte |= 1 ;
     4be:	81 60       	ori	r24, 0x01	; 1
     4c0:	e2 cf       	rjmp	.-60     	; 0x486 <__LOCK_REGION_LENGTH__+0x86>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:649
                bitMin = MIN_ONEBITFULL;
                DccRx.BitCount = 0 ;
            }
            else
            {
                DccRx.State = WAIT_END_BIT ;
     4c2:	83 e0       	ldi	r24, 0x03	; 3
     4c4:	90 e0       	ldi	r25, 0x00	; 0
     4c6:	80 93 3f 38 	sts	0x383F, r24	; 0x80383f <DccRx>
     4ca:	90 93 40 38 	sts	0x3840, r25	; 0x803840 <DccRx+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:650
                DccRx.PacketBuf.Data[ DccRx.PacketBuf.Size++ ] = DccRx.TempByte ;
     4ce:	90 91 43 38 	lds	r25, 0x3843	; 0x803843 <DccRx+0x4>
     4d2:	81 e0       	ldi	r24, 0x01	; 1
     4d4:	8e 0f       	add	r24, r30
     4d6:	80 93 45 38 	sts	0x3845, r24	; 0x803845 <DccRx+0x6>
     4da:	f0 e0       	ldi	r31, 0x00	; 0
     4dc:	e1 5c       	subi	r30, 0xC1	; 193
     4de:	f7 4c       	sbci	r31, 0xC7	; 199
     4e0:	90 87       	std	Z+8, r25	; 0x08
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:651
                DccRx.chkSum ^= DccRx.TempByte;
     4e2:	80 91 44 38 	lds	r24, 0x3844	; 0x803844 <DccRx+0x5>
     4e6:	89 27       	eor	r24, r25
     4e8:	80 93 44 38 	sts	0x3844, r24	; 0x803844 <DccRx+0x5>
     4ec:	c7 ce       	rjmp	.-626    	; 0x27c <ExternalInterruptHandler()+0x8e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:660

    case WAIT_END_BIT:
        SET_TP2;
        CLR_TP2;
        DccRx.BitCount++;
        if (DccBitVal)    // End of packet?
     4ee:	c0 17       	cp	r28, r16
     4f0:	d1 07       	cpc	r29, r17
     4f2:	28 f5       	brcc	.+74     	; 0x53e <__LOCK_REGION_LENGTH__+0x13e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:664
        {
            CLR_TP3;
            SET_TP4;
            DccRx.State = WAIT_PREAMBLE ;
     4f4:	10 92 3f 38 	sts	0x383F, r1	; 0x80383f <DccRx>
     4f8:	10 92 40 38 	sts	0x3840, r1	; 0x803840 <DccRx+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:665
            DccRx.BitCount = 0 ;
     4fc:	10 92 42 38 	sts	0x3842, r1	; 0x803842 <DccRx+0x3>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:666
            bitMax = MAX_PRAEAMBEL;
     500:	82 e9       	ldi	r24, 0x92	; 146
     502:	90 e0       	ldi	r25, 0x00	; 0
     504:	80 93 3d 38 	sts	0x383D, r24	; 0x80383d <bitMax>
     508:	90 93 3e 38 	sts	0x383E, r25	; 0x80383e <bitMax+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:667
            bitMin = MIN_ONEBITFULL;
     50c:	82 e5       	ldi	r24, 0x52	; 82
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	80 93 3b 38 	sts	0x383B, r24	; 0x80383b <bitMin>
     514:	90 93 3c 38 	sts	0x383C, r25	; 0x80383c <bitMin+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:669
            SET_TP1;
            if (DccRx.chkSum == 0)
     518:	80 91 44 38 	lds	r24, 0x3844	; 0x803844 <DccRx+0x5>
     51c:	81 11       	cpse	r24, r1
     51e:	b8 ce       	rjmp	.-656    	; 0x290 <ExternalInterruptHandler()+0xa2>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:675
            {
                // Packet is valid
                #ifdef ESP32
                portENTER_CRITICAL_ISR (&mux);
                #endif
                DccRx.PacketCopy = DccRx.PacketBuf ;
     520:	88 e0       	ldi	r24, 0x08	; 8
     522:	e5 e4       	ldi	r30, 0x45	; 69
     524:	f8 e3       	ldi	r31, 0x38	; 56
     526:	ad e4       	ldi	r26, 0x4D	; 77
     528:	b8 e3       	ldi	r27, 0x38	; 56
     52a:	01 90       	ld	r0, Z+
     52c:	0d 92       	st	X+, r0
     52e:	8a 95       	dec	r24
     530:	e1 f7       	brne	.-8      	; 0x52a <__LOCK_REGION_LENGTH__+0x12a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:676
                DccRx.DataReady = 1 ;
     532:	81 e0       	ldi	r24, 0x01	; 1
     534:	80 93 41 38 	sts	0x3841, r24	; 0x803841 <DccRx+0x2>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:681
                #ifdef ESP32
                portEXIT_CRITICAL_ISR (&mux);
                #endif
                // SET_TP2; CLR_TP2;
                preambleBitCount = 0 ;
     538:	10 92 2a 38 	sts	0x382A, r1	; 0x80382a <ExternalInterruptHandler()::preambleBitCount>
     53c:	9f ce       	rjmp	.-706    	; 0x27c <ExternalInterruptHandler()+0x8e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:699
            CLR_TP4;
        }
        else      // Get next Byte
        {
            // KGW - Abort immediately if packet is too long.
            if (DccRx.PacketBuf.Size == MAX_DCC_MESSAGE_LEN)  // Packet is too long - abort
     53e:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <DccRx+0x6>
     542:	86 30       	cpi	r24, 0x06	; 6
     544:	09 f4       	brne	.+2      	; 0x548 <__LOCK_REGION_LENGTH__+0x148>
     546:	a8 cf       	rjmp	.-176    	; 0x498 <__LOCK_REGION_LENGTH__+0x98>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:708
                bitMin = MIN_ONEBITFULL;
                DccRx.BitCount = 0 ;
            }
            else
            {
                DccRx.State = WAIT_DATA ;
     548:	82 e0       	ldi	r24, 0x02	; 2
     54a:	90 e0       	ldi	r25, 0x00	; 0
     54c:	80 93 3f 38 	sts	0x383F, r24	; 0x80383f <DccRx>
     550:	90 93 40 38 	sts	0x3840, r25	; 0x803840 <DccRx+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:710

                DccRx.BitCount = 0 ;
     554:	10 92 42 38 	sts	0x3842, r1	; 0x803842 <DccRx+0x3>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:711
                DccRx.TempByte = 0 ;
     558:	10 92 43 38 	sts	0x3843, r1	; 0x803843 <DccRx+0x4>
     55c:	8f ce       	rjmp	.-738    	; 0x27c <ExternalInterruptHandler()+0x8e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:765
            }
        }
        else
        {
            CLR_TP1;
            preambleBitCount = 0 ;
     55e:	10 92 2a 38 	sts	0x382A, r1	; 0x80382a <ExternalInterruptHandler()::preambleBitCount>
     562:	b7 ce       	rjmp	.-658    	; 0x2d2 <ExternalInterruptHandler()+0xe4>

00000564 <millis>:
millis():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:454
  unsigned long millis() {
    // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
    unsigned long m;
    // disable interrupts while we read timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to timer_millis)
    uint8_t oldSREG = SREG;
     564:	2f b7       	in	r18, 0x3f	; 63
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:455
    cli();
     566:	f8 94       	cli
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:506
        "adc %D0, %D1"    "\n\t"
        : "+r" (m), "+r" (temp), "+d" (cnt)
        );
      */
    #else
      m = timingStruct.timer_millis;
     568:	60 91 31 38 	lds	r22, 0x3831	; 0x803831 <timingStruct+0x2>
     56c:	70 91 32 38 	lds	r23, 0x3832	; 0x803832 <timingStruct+0x3>
     570:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <timingStruct+0x4>
     574:	90 91 34 38 	lds	r25, 0x3834	; 0x803834 <timingStruct+0x5>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:507
      SREG = oldSREG;
     578:	2f bf       	out	0x3f, r18	; 63
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:510
    #endif
    return m;
  }
     57a:	08 95       	ret

0000057c <resetServiceModeTimer(unsigned char)>:
_Z21resetServiceModeTimerh():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1221
}
#endif

/////////////////////////////////////////////////////////////////////////
void resetServiceModeTimer (uint8_t inServiceMode)
{
     57c:	cf 93       	push	r28
     57e:	c8 2f       	mov	r28, r24
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1222
    if (notifyServiceMode && inServiceMode != DccProcState.inServiceMode)
     580:	80 e0       	ldi	r24, 0x00	; 0
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	51 f0       	breq	.+20     	; 0x59c <resetServiceModeTimer(unsigned char)+0x20>
     588:	80 91 af 38 	lds	r24, 0x38AF	; 0x8038af <DccProcState+0x2>
     58c:	8c 17       	cp	r24, r28
     58e:	31 f0       	breq	.+12     	; 0x59c <resetServiceModeTimer(unsigned char)+0x20>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1224
    {
        notifyServiceMode (inServiceMode);
     590:	81 e0       	ldi	r24, 0x01	; 1
     592:	c1 11       	cpse	r28, r1
     594:	01 c0       	rjmp	.+2      	; 0x598 <resetServiceModeTimer(unsigned char)+0x1c>
     596:	80 e0       	ldi	r24, 0x00	; 0
     598:	0e 94 00 00 	call	0	; 0x0 <__vectors>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1227
    }
    // Set the Service Mode
    DccProcState.inServiceMode = inServiceMode ;
     59c:	c0 93 af 38 	sts	0x38AF, r28	; 0x8038af <DccProcState+0x2>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1229

    DccProcState.LastServiceModeMillis = inServiceMode ? millis() : 0 ;
     5a0:	60 e0       	ldi	r22, 0x00	; 0
     5a2:	70 e0       	ldi	r23, 0x00	; 0
     5a4:	cb 01       	movw	r24, r22
     5a6:	c1 11       	cpse	r28, r1
     5a8:	dd df       	rcall	.-70     	; 0x564 <millis>
     5aa:	60 93 b0 38 	sts	0x38B0, r22	; 0x8038b0 <DccProcState+0x3>
     5ae:	70 93 b1 38 	sts	0x38B1, r23	; 0x8038b1 <DccProcState+0x4>
     5b2:	80 93 b2 38 	sts	0x38B2, r24	; 0x8038b2 <DccProcState+0x5>
     5b6:	90 93 b3 38 	sts	0x38B3, r25	; 0x8038b3 <DccProcState+0x6>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1230
    if (notifyServiceMode && inServiceMode != DccProcState.inServiceMode)
     5ba:	80 e0       	ldi	r24, 0x00	; 0
     5bc:	90 e0       	ldi	r25, 0x00	; 0
     5be:	89 2b       	or	r24, r25
     5c0:	59 f0       	breq	.+22     	; 0x5d8 <resetServiceModeTimer(unsigned char)+0x5c>
     5c2:	80 91 af 38 	lds	r24, 0x38AF	; 0x8038af <DccProcState+0x2>
     5c6:	8c 17       	cp	r24, r28
     5c8:	39 f0       	breq	.+14     	; 0x5d8 <resetServiceModeTimer(unsigned char)+0x5c>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1232
    {
        notifyServiceMode (inServiceMode);
     5ca:	81 e0       	ldi	r24, 0x01	; 1
     5cc:	c1 11       	cpse	r28, r1
     5ce:	01 c0       	rjmp	.+2      	; 0x5d2 <resetServiceModeTimer(unsigned char)+0x56>
     5d0:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1234
    }
}
     5d2:	cf 91       	pop	r28
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1232
    DccProcState.inServiceMode = inServiceMode ;

    DccProcState.LastServiceModeMillis = inServiceMode ? millis() : 0 ;
    if (notifyServiceMode && inServiceMode != DccProcState.inServiceMode)
    {
        notifyServiceMode (inServiceMode);
     5d4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1234
    }
}
     5d8:	cf 91       	pop	r28
     5da:	08 95       	ret

000005dc <writeCV(unsigned int, unsigned char)>:
_Z7writeCVjh():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:851
    Value = readEEPROM (CV);
    return Value ;
}

uint8_t writeCV (unsigned int CV, uint8_t Value)
{
     5dc:	ef 92       	push	r14
     5de:	ff 92       	push	r15
     5e0:	1f 93       	push	r17
     5e2:	cf 93       	push	r28
     5e4:	df 93       	push	r29
     5e6:	ec 01       	movw	r28, r24
     5e8:	16 2f       	mov	r17, r22
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:852
    switch (CV)
     5ea:	83 31       	cpi	r24, 0x13	; 19
     5ec:	91 05       	cpc	r25, r1
     5ee:	d8 f4       	brcc	.+54     	; 0x626 <writeCV(unsigned int, unsigned char)+0x4a>
     5f0:	81 31       	cpi	r24, 0x11	; 17
     5f2:	91 05       	cpc	r25, r1
     5f4:	28 f4       	brcc	.+10     	; 0x600 <writeCV(unsigned int, unsigned char)+0x24>
     5f6:	81 30       	cpi	r24, 0x01	; 1
     5f8:	91 05       	cpc	r25, r1
     5fa:	11 f0       	breq	.+4      	; 0x600 <writeCV(unsigned int, unsigned char)+0x24>
     5fc:	09 97       	sbiw	r24, 0x09	; 9
     5fe:	31 f4       	brne	.+12     	; 0x60c <writeCV(unsigned int, unsigned char)+0x30>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:865
    // no break, because myDccAdress must also be reset
    case CV_ACCESSORY_DECODER_ADDRESS_LSB:	// Also same CV for CV_MULTIFUNCTION_PRIMARY_ADDRESS
    case CV_ACCESSORY_DECODER_ADDRESS_MSB:
    case CV_MULTIFUNCTION_EXTENDED_ADDRESS_MSB:
    case CV_MULTIFUNCTION_EXTENDED_ADDRESS_LSB:
        DccProcState.myDccAddress = -1;	// Assume any CV Write Operation might change the Address
     600:	8f ef       	ldi	r24, 0xFF	; 255
     602:	9f ef       	ldi	r25, 0xFF	; 255
     604:	80 93 c3 38 	sts	0x38C3, r24	; 0x8038c3 <DccProcState+0x16>
     608:	90 93 c4 38 	sts	0x38C4, r25	; 0x8038c4 <DccProcState+0x17>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:868
    }

    if (notifyCVWrite)
     60c:	80 e0       	ldi	r24, 0x00	; 0
     60e:	90 e0       	ldi	r25, 0x00	; 0
     610:	89 2b       	or	r24, r25
     612:	b9 f0       	breq	.+46     	; 0x642 <writeCV(unsigned int, unsigned char)+0x66>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:869
        return notifyCVWrite (CV, Value) ;
     614:	61 2f       	mov	r22, r17
     616:	ce 01       	movw	r24, r28
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:883
        if (notifyDccCVChange && ! (DccProcState.Flags & FLAGS_SETCV_CALLED))
            notifyDccCVChange (CV, Value);
    }

    return readEEPROM (CV) ;
}
     618:	df 91       	pop	r29
     61a:	cf 91       	pop	r28
     61c:	1f 91       	pop	r17
     61e:	ff 90       	pop	r15
     620:	ef 90       	pop	r14
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:869
    case CV_MULTIFUNCTION_EXTENDED_ADDRESS_LSB:
        DccProcState.myDccAddress = -1;	// Assume any CV Write Operation might change the Address
    }

    if (notifyCVWrite)
        return notifyCVWrite (CV, Value) ;
     622:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:852
    return Value ;
}

uint8_t writeCV (unsigned int CV, uint8_t Value)
{
    switch (CV)
     626:	4d 97       	sbiw	r24, 0x1d	; 29
     628:	89 f7       	brne	.-30     	; 0x60c <writeCV(unsigned int, unsigned char)+0x30>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:856
    {
    case CV_29_CONFIG:
        // copy addressmode Bit to Flags
        Value = Value &  ~CV29_RAILCOM_ENABLE;   // Bidi (RailCom) Bit must not be enabled,
     62a:	17 7f       	andi	r17, 0xF7	; 247
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:858
        // because you cannot build a Bidi decoder with this lib.
        DccProcState.cv29Value = Value;
     62c:	10 93 c6 38 	sts	0x38C6, r17	; 0x8038c6 <DccProcState+0x19>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:859
        DccProcState.Flags = (DccProcState.Flags & ~FLAGS_CV29_BITS) | (Value & FLAGS_CV29_BITS);
     630:	80 91 ad 38 	lds	r24, 0x38AD	; 0x8038ad <DccProcState>
     634:	8f 73       	andi	r24, 0x3F	; 63
     636:	91 2f       	mov	r25, r17
     638:	90 7c       	andi	r25, 0xC0	; 192
     63a:	89 2b       	or	r24, r25
     63c:	80 93 ad 38 	sts	0x38AD, r24	; 0x8038ad <DccProcState>
     640:	df cf       	rjmp	.-66     	; 0x600 <writeCV(unsigned int, unsigned char)+0x24>
_ZNK5EERefdeEv():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\libraries\EEPROM\src/EEPROM.h:62
  EERef(const INDEXDATATYPE index)
    : index(index)                 {}

  // Access/read members.
  uint8_t operator * () const            {
    return (*(uint8_t *)((uint16_t)(MAPPED_EEPROM_START + (index & EEPROM_INDEX_MASK))));
     642:	7e 01       	movw	r14, r28
     644:	ff 24       	eor	r15, r15
     646:	8c ee       	ldi	r24, 0xEC	; 236
     648:	f8 1a       	sub	r15, r24
_Z7writeCVjh():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:871
    }

    if (notifyCVWrite)
        return notifyCVWrite (CV, Value) ;

    if (readEEPROM (CV) != Value)
     64a:	d7 01       	movw	r26, r14
     64c:	8c 91       	ld	r24, X
     64e:	18 17       	cp	r17, r24
     650:	11 f1       	breq	.+68     	; 0x696 <writeCV(unsigned int, unsigned char)+0xba>
operator=():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\libraries\EEPROM\src/EEPROM.h:95
      "ldi %0, 0x03"      "\n\t" // command loaded: page erase-write.
      "st Z, %0"          "\n\t" // write the page erase-write command to nvmctrl.ctrla
      "out 0x3f, r0"      "\n"   // restore SREG
      :"+d"(in)           // take the value we are writing in any upper register as read/write,
      : "x"(adr)          // and the address (not the index) in X
      : "r30", "r31", "r18");      // clobber Z and r18. We needed an upper register for the temporary value to andi it. I wonder if this will fix the eeprom bugs too?
     652:	81 2f       	mov	r24, r17
     654:	e0 e0       	ldi	r30, 0x00	; 0
     656:	f0 e1       	ldi	r31, 0x10	; 16
     658:	0f b6       	in	r0, 0x3f	; 63
     65a:	22 81       	ldd	r18, Z+2	; 0x02
     65c:	23 70       	andi	r18, 0x03	; 3
     65e:	e9 f7       	brne	.-6      	; 0x65a <writeCV(unsigned int, unsigned char)+0x7e>
     660:	f8 94       	cli
     662:	8c 93       	st	X, r24
     664:	8d e9       	ldi	r24, 0x9D	; 157
     666:	84 bf       	out	0x34, r24	; 52
     668:	83 e0       	ldi	r24, 0x03	; 3
     66a:	80 83       	st	Z, r24
     66c:	0f be       	out	0x3f, r0	; 63
_Z7writeCVjh():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:875
    {
        writeEEPROM (CV, Value) ;

        if (notifyCVChange)
     66e:	80 e0       	ldi	r24, 0x00	; 0
     670:	90 e0       	ldi	r25, 0x00	; 0
     672:	89 2b       	or	r24, r25
     674:	21 f0       	breq	.+8      	; 0x67e <writeCV(unsigned int, unsigned char)+0xa2>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:876
            notifyCVChange (CV, Value) ;
     676:	61 2f       	mov	r22, r17
     678:	ce 01       	movw	r24, r28
     67a:	0e 94 00 00 	call	0	; 0x0 <__vectors>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:878

        if (notifyDccCVChange && ! (DccProcState.Flags & FLAGS_SETCV_CALLED))
     67e:	80 e0       	ldi	r24, 0x00	; 0
     680:	90 e0       	ldi	r25, 0x00	; 0
     682:	89 2b       	or	r24, r25
     684:	41 f0       	breq	.+16     	; 0x696 <writeCV(unsigned int, unsigned char)+0xba>
     686:	80 91 ad 38 	lds	r24, 0x38AD	; 0x8038ad <DccProcState>
     68a:	84 fd       	sbrc	r24, 4
     68c:	04 c0       	rjmp	.+8      	; 0x696 <writeCV(unsigned int, unsigned char)+0xba>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:879
            notifyDccCVChange (CV, Value);
     68e:	61 2f       	mov	r22, r17
     690:	ce 01       	movw	r24, r28
     692:	0e 94 00 00 	call	0	; 0x0 <__vectors>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:883
    }

    return readEEPROM (CV) ;
}
     696:	f7 01       	movw	r30, r14
     698:	80 81       	ld	r24, Z
     69a:	df 91       	pop	r29
     69c:	cf 91       	pop	r28
     69e:	1f 91       	pop	r17
     6a0:	ff 90       	pop	r15
     6a2:	ef 90       	pop	r14
     6a4:	08 95       	ret

000006a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>:
_ZN7NmraDcc5setCVEjh.constprop.11():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1649
{
    return readCV (CV);
}

////////////////////////////////////////////////////////////////////////
uint8_t NmraDcc::setCV (uint16_t CV, uint8_t Value)
     6a6:	cf 93       	push	r28
     6a8:	df 93       	push	r29
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1651
{
    DccProcState.Flags |= FLAGS_SETCV_CALLED;
     6aa:	cd ea       	ldi	r28, 0xAD	; 173
     6ac:	d8 e3       	ldi	r29, 0x38	; 56
     6ae:	28 81       	ld	r18, Y
     6b0:	20 61       	ori	r18, 0x10	; 16
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1653

    uint8_t returnValue = writeCV (CV,Value);
     6b2:	28 83       	st	Y, r18
     6b4:	93 df       	rcall	.-218    	; 0x5dc <writeCV(unsigned int, unsigned char)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1655

    DccProcState.Flags &= ~FLAGS_SETCV_CALLED;
     6b6:	98 81       	ld	r25, Y
     6b8:	9f 7e       	andi	r25, 0xEF	; 239
     6ba:	98 83       	st	Y, r25
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1658

    return returnValue;
}
     6bc:	df 91       	pop	r29
     6be:	cf 91       	pop	r28
     6c0:	08 95       	ret

000006c2 <readCV(unsigned int)>:
_Z6readCVj():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:843

uint8_t readCV (unsigned int CV)
{
    uint8_t Value ;

    if (notifyCVRead)
     6c2:	20 e0       	ldi	r18, 0x00	; 0
     6c4:	30 e0       	ldi	r19, 0x00	; 0
     6c6:	23 2b       	or	r18, r19
     6c8:	11 f0       	breq	.+4      	; 0x6ce <readCV(unsigned int)+0xc>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:844
        return notifyCVRead (CV) ;
     6ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
_ZNK5EERefdeEv():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\libraries\EEPROM\src/EEPROM.h:62
  EERef(const INDEXDATATYPE index)
    : index(index)                 {}

  // Access/read members.
  uint8_t operator * () const            {
    return (*(uint8_t *)((uint16_t)(MAPPED_EEPROM_START + (index & EEPROM_INDEX_MASK))));
     6ce:	99 27       	eor	r25, r25
     6d0:	fc 01       	movw	r30, r24
     6d2:	fc 5e       	subi	r31, 0xEC	; 236
_Z6readCVj():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:848

    Value = readEEPROM (CV);
    return Value ;
}
     6d4:	80 81       	ld	r24, Z
     6d6:	08 95       	ret

000006d8 <getMyAddr()>:
_Z9getMyAddrv():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:886

    return readEEPROM (CV) ;
}

uint16_t getMyAddr (void)
{
     6d8:	cf 93       	push	r28
     6da:	df 93       	push	r29
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:887
    if (DccProcState.myDccAddress != -1)	// See if we can return the cached value
     6dc:	20 91 c3 38 	lds	r18, 0x38C3	; 0x8038c3 <DccProcState+0x16>
     6e0:	30 91 c4 38 	lds	r19, 0x38C4	; 0x8038c4 <DccProcState+0x17>
     6e4:	2f 3f       	cpi	r18, 0xFF	; 255
     6e6:	32 07       	cpc	r19, r18
     6e8:	21 f0       	breq	.+8      	; 0x6f2 <getMyAddr()+0x1a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:888
        return (DccProcState.myDccAddress);
     6ea:	c9 01       	movw	r24, r18
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:907
        else
            DccProcState.myDccAddress = readCV (1) ;
    }

    return DccProcState.myDccAddress ;
}
     6ec:	df 91       	pop	r29
     6ee:	cf 91       	pop	r28
     6f0:	08 95       	ret
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:890
uint16_t getMyAddr (void)
{
    if (DccProcState.myDccAddress != -1)	// See if we can return the cached value
        return (DccProcState.myDccAddress);

    if (DccProcState.cv29Value & CV29_ACCESSORY_DECODER)   // Accessory Decoder?
     6f2:	80 91 c6 38 	lds	r24, 0x38C6	; 0x8038c6 <DccProcState+0x19>
     6f6:	87 ff       	sbrs	r24, 7
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:892
    {
        if (DccProcState.cv29Value & CV29_OUTPUT_ADDRESS_MODE)
     6f8:	27 c0       	rjmp	.+78     	; 0x748 <getMyAddr()+0x70>
     6fa:	86 ff       	sbrs	r24, 6
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:893
            DccProcState.myDccAddress = (readCV (CV_ACCESSORY_DECODER_ADDRESS_MSB) << 8) | readCV (CV_ACCESSORY_DECODER_ADDRESS_LSB);
     6fc:	0d c0       	rjmp	.+26     	; 0x718 <getMyAddr()+0x40>
     6fe:	89 e0       	ldi	r24, 0x09	; 9
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	df df       	rcall	.-66     	; 0x6c2 <readCV(unsigned int)>
     704:	c8 2f       	mov	r28, r24
     706:	81 e0       	ldi	r24, 0x01	; 1
     708:	90 e0       	ldi	r25, 0x00	; 0
     70a:	db df       	rcall	.-74     	; 0x6c2 <readCV(unsigned int)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:903
    {
        if (DccProcState.cv29Value & CV29_EXT_ADDRESSING)   // Two Byte Address?
            DccProcState.myDccAddress = ( (readCV (CV_MULTIFUNCTION_EXTENDED_ADDRESS_MSB) - 192) << 8) | readCV (CV_MULTIFUNCTION_EXTENDED_ADDRESS_LSB) ;

        else
            DccProcState.myDccAddress = readCV (1) ;
     70c:	9c 2f       	mov	r25, r28
     70e:	80 93 c3 38 	sts	0x38C3, r24	; 0x8038c3 <DccProcState+0x16>
     712:	90 93 c4 38 	sts	0x38C4, r25	; 0x8038c4 <DccProcState+0x17>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:895
    if (DccProcState.cv29Value & CV29_ACCESSORY_DECODER)   // Accessory Decoder?
    {
        if (DccProcState.cv29Value & CV29_OUTPUT_ADDRESS_MODE)
            DccProcState.myDccAddress = (readCV (CV_ACCESSORY_DECODER_ADDRESS_MSB) << 8) | readCV (CV_ACCESSORY_DECODER_ADDRESS_LSB);
        else
            DccProcState.myDccAddress = ( (readCV (CV_ACCESSORY_DECODER_ADDRESS_MSB) & 0b00000111) << 6) | (readCV (CV_ACCESSORY_DECODER_ADDRESS_LSB) & 0b00111111) ;
     716:	13 c0       	rjmp	.+38     	; 0x73e <getMyAddr()+0x66>
     718:	89 e0       	ldi	r24, 0x09	; 9
     71a:	90 e0       	ldi	r25, 0x00	; 0
     71c:	d2 df       	rcall	.-92     	; 0x6c2 <readCV(unsigned int)>
     71e:	c8 2f       	mov	r28, r24
     720:	81 e0       	ldi	r24, 0x01	; 1
     722:	90 e0       	ldi	r25, 0x00	; 0
     724:	ce df       	rcall	.-100    	; 0x6c2 <readCV(unsigned int)>
     726:	90 e4       	ldi	r25, 0x40	; 64
     728:	c9 9f       	mul	r28, r25
     72a:	90 01       	movw	r18, r0
     72c:	11 24       	eor	r1, r1
     72e:	20 7c       	andi	r18, 0xC0	; 192
     730:	31 70       	andi	r19, 0x01	; 1
     732:	8f 73       	andi	r24, 0x3F	; 63
     734:	28 2b       	or	r18, r24
     736:	20 93 c3 38 	sts	0x38C3, r18	; 0x8038c3 <DccProcState+0x16>
     73a:	30 93 c4 38 	sts	0x38C4, r19	; 0x8038c4 <DccProcState+0x17>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:906

        else
            DccProcState.myDccAddress = readCV (1) ;
    }

    return DccProcState.myDccAddress ;
     73e:	80 91 c3 38 	lds	r24, 0x38C3	; 0x8038c3 <DccProcState+0x16>
     742:	90 91 c4 38 	lds	r25, 0x38C4	; 0x8038c4 <DccProcState+0x17>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:899
        else
            DccProcState.myDccAddress = ( (readCV (CV_ACCESSORY_DECODER_ADDRESS_MSB) & 0b00000111) << 6) | (readCV (CV_ACCESSORY_DECODER_ADDRESS_LSB) & 0b00111111) ;
    }
    else   // Multi-Function Decoder?
    {
        if (DccProcState.cv29Value & CV29_EXT_ADDRESSING)   // Two Byte Address?
     746:	d2 cf       	rjmp	.-92     	; 0x6ec <getMyAddr()+0x14>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:900
            DccProcState.myDccAddress = ( (readCV (CV_MULTIFUNCTION_EXTENDED_ADDRESS_MSB) - 192) << 8) | readCV (CV_MULTIFUNCTION_EXTENDED_ADDRESS_LSB) ;
     748:	85 ff       	sbrs	r24, 5
     74a:	0a c0       	rjmp	.+20     	; 0x760 <getMyAddr()+0x88>
     74c:	81 e1       	ldi	r24, 0x11	; 17
     74e:	90 e0       	ldi	r25, 0x00	; 0
     750:	b8 df       	rcall	.-144    	; 0x6c2 <readCV(unsigned int)>
     752:	c8 2f       	mov	r28, r24
     754:	82 e1       	ldi	r24, 0x12	; 18
     756:	90 e0       	ldi	r25, 0x00	; 0
     758:	b4 df       	rcall	.-152    	; 0x6c2 <readCV(unsigned int)>
     75a:	c0 5c       	subi	r28, 0xC0	; 192
     75c:	dd 0b       	sbc	r29, r29
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:903

        else
            DccProcState.myDccAddress = readCV (1) ;
     75e:	d6 cf       	rjmp	.-84     	; 0x70c <getMyAddr()+0x34>
     760:	81 e0       	ldi	r24, 0x01	; 1
     762:	90 e0       	ldi	r25, 0x00	; 0
     764:	ae df       	rcall	.-164    	; 0x6c2 <readCV(unsigned int)>
     766:	90 e0       	ldi	r25, 0x00	; 0
     768:	d2 cf       	rjmp	.-92     	; 0x70e <getMyAddr()+0x36>

0000076a <ackAdvancedCV()>:
_Z13ackAdvancedCVv():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:788
    }
}

void ackAdvancedCV (void)
{
    if (notifyAdvancedCVAck && (DccProcState.cv29Value & CV29_RAILCOM_ENABLE))
     76a:	80 e0       	ldi	r24, 0x00	; 0
     76c:	90 e0       	ldi	r25, 0x00	; 0
     76e:	89 2b       	or	r24, r25
     770:	29 f0       	breq	.+10     	; 0x77c <ackAdvancedCV()+0x12>
     772:	80 91 c6 38 	lds	r24, 0x38C6	; 0x8038c6 <DccProcState+0x19>
     776:	83 fd       	sbrc	r24, 3
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:791
    {
        DB_PRINT ("ackAdvancedCV: Send RailCom ACK");
        notifyAdvancedCVAck() ;
     778:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:793
    }
}
     77c:	08 95       	ret

0000077e <notifyDccFunc>:
notifyDccFunc():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:305
    loadCV() ; // after a write, reload CV.
}

// This call-back function is called whenever we receive a DCC Function packet for our address
void notifyDccFunc(uint16_t Addr, DCC_ADDR_TYPE AddrType, FN_GROUP FuncGrp, uint8_t FuncState)
{
     77e:	cf 93       	push	r28
     780:	df 93       	push	r29
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:312
    uint8   endF ;
    uint8   F0 ;
    uint8   i ;
    uint8   Fx ;

    switch( FuncGrp )
     782:	43 30       	cpi	r20, 0x03	; 3
     784:	51 05       	cpc	r21, r1
     786:	09 f4       	brne	.+2      	; 0x78a <notifyDccFunc+0xc>
     788:	49 c0       	rjmp	.+146    	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
     78a:	48 f4       	brcc	.+18     	; 0x79e <notifyDccFunc+0x20>
     78c:	41 30       	cpi	r20, 0x01	; 1
     78e:	51 05       	cpc	r21, r1
     790:	c1 f1       	breq	.+112    	; 0x802 <__DATA_REGION_LENGTH__+0x2>
     792:	42 30       	cpi	r20, 0x02	; 2
     794:	51 05       	cpc	r21, r1
     796:	61 f0       	breq	.+24     	; 0x7b0 <notifyDccFunc+0x32>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:332
            uint8 state = FuncState & (1<<i) ;
            setFunc( Fx, state ) ; 
        }
        break ;
    }
}
     798:	df 91       	pop	r29
     79a:	cf 91       	pop	r28
     79c:	08 95       	ret
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:312
    uint8   endF ;
    uint8   F0 ;
    uint8   i ;
    uint8   Fx ;

    switch( FuncGrp )
     79e:	44 30       	cpi	r20, 0x04	; 4
     7a0:	51 05       	cpc	r21, r1
     7a2:	c9 f1       	breq	.+114    	; 0x816 <__DATA_REGION_LENGTH__+0x16>
     7a4:	45 30       	cpi	r20, 0x05	; 5
     7a6:	51 05       	cpc	r21, r1
     7a8:	b9 f7       	brne	.-18     	; 0x798 <notifyDccFunc+0x1a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:320
                    FuncState = (FuncState << 1) | F0 ;     // and shift the others
                    beginF =  0 ; endF =  4 ; goto setFunc ;
    case FN_5_8:    beginF =  5 ; endF =  8 ; goto setFunc ;
    case FN_9_12:   beginF =  9 ; endF = 12 ; goto setFunc ;
    case FN_13_20:  beginF = 13 ; endF = 20 ; goto setFunc ;
    case FN_21_28:  beginF = 21 ; endF = 28 ; goto setFunc ;
     7aa:	5c e1       	ldi	r21, 0x1C	; 28
     7ac:	95 e1       	ldi	r25, 0x15	; 21
     7ae:	02 c0       	rjmp	.+4      	; 0x7b4 <notifyDccFunc+0x36>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:317
    switch( FuncGrp )
    {
    case FN_0_4:    F0 = bitRead( FuncState, 4 ) ;          // put F0 in front
                    FuncState = (FuncState << 1) | F0 ;     // and shift the others
                    beginF =  0 ; endF =  4 ; goto setFunc ;
    case FN_5_8:    beginF =  5 ; endF =  8 ; goto setFunc ;
     7b0:	58 e0       	ldi	r21, 0x08	; 8
     7b2:	95 e0       	ldi	r25, 0x05	; 5
setFunc():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:289
    if( dir )   setPoint =-setPoint ;
}

void setFunc( uint8 num, uint8 state )
{
    if( num == A.Fx ) A.state = state ;
     7b4:	40 91 8f 38 	lds	r20, 0x388F	; 0x80388f <A>
     7b8:	e4 2f       	mov	r30, r20
     7ba:	ef 71       	andi	r30, 0x1F	; 31
     7bc:	47 fb       	bst	r20, 7
     7be:	44 27       	eor	r20, r20
     7c0:	40 f9       	bld	r20, 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:290
    if( num == B.Fx ) B.state = state ;
     7c2:	30 91 8a 38 	lds	r19, 0x388A	; 0x80388a <B>
     7c6:	f3 2f       	mov	r31, r19
     7c8:	ff 71       	andi	r31, 0x1F	; 31
     7ca:	37 fb       	bst	r19, 7
     7cc:	33 27       	eor	r19, r19
     7ce:	30 f9       	bld	r19, 0
notifyDccFunc():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:323
    case FN_9_12:   beginF =  9 ; endF = 12 ; goto setFunc ;
    case FN_13_20:  beginF = 13 ; endF = 20 ; goto setFunc ;
    case FN_21_28:  beginF = 21 ; endF = 28 ; goto setFunc ;
    
    setFunc:
        for( Fx =  beginF, i = 0 ; 
     7d0:	89 2f       	mov	r24, r25
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:327
             Fx <= endF ; 
             Fx ++ ,       i ++ )
        {
            uint8 state = FuncState & (1<<i) ;
     7d2:	a1 e0       	ldi	r26, 0x01	; 1
     7d4:	b0 e0       	ldi	r27, 0x00	; 0
     7d6:	68 2f       	mov	r22, r24
     7d8:	69 1b       	sub	r22, r25
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:324
    case FN_13_20:  beginF = 13 ; endF = 20 ; goto setFunc ;
    case FN_21_28:  beginF = 21 ; endF = 28 ; goto setFunc ;
    
    setFunc:
        for( Fx =  beginF, i = 0 ; 
             Fx <= endF ; 
     7da:	58 17       	cp	r21, r24
     7dc:	10 f1       	brcs	.+68     	; 0x822 <__DATA_REGION_LENGTH__+0x22>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:327
             Fx ++ ,       i ++ )
        {
            uint8 state = FuncState & (1<<i) ;
     7de:	ed 01       	movw	r28, r26
     7e0:	02 c0       	rjmp	.+4      	; 0x7e6 <notifyDccFunc+0x68>
     7e2:	cc 0f       	add	r28, r28
     7e4:	dd 1f       	adc	r29, r29
     7e6:	6a 95       	dec	r22
     7e8:	e2 f7       	brpl	.-8      	; 0x7e2 <notifyDccFunc+0x64>
     7ea:	be 01       	movw	r22, r28
     7ec:	62 23       	and	r22, r18
setFunc():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:289
    if( dir )   setPoint =-setPoint ;
}

void setFunc( uint8 num, uint8 state )
{
    if( num == A.Fx ) A.state = state ;
     7ee:	8e 13       	cpse	r24, r30
     7f0:	02 c0       	rjmp	.+4      	; 0x7f6 <notifyDccFunc+0x78>
     7f2:	46 2f       	mov	r20, r22
     7f4:	41 70       	andi	r20, 0x01	; 1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:290
    if( num == B.Fx ) B.state = state ;
     7f6:	8f 13       	cpse	r24, r31
     7f8:	02 c0       	rjmp	.+4      	; 0x7fe <notifyDccFunc+0x80>
     7fa:	36 2f       	mov	r19, r22
     7fc:	31 70       	andi	r19, 0x01	; 1
notifyDccFunc():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:323
    case FN_9_12:   beginF =  9 ; endF = 12 ; goto setFunc ;
    case FN_13_20:  beginF = 13 ; endF = 20 ; goto setFunc ;
    case FN_21_28:  beginF = 21 ; endF = 28 ; goto setFunc ;
    
    setFunc:
        for( Fx =  beginF, i = 0 ; 
     7fe:	8f 5f       	subi	r24, 0xFF	; 255
     800:	ea cf       	rjmp	.-44     	; 0x7d6 <notifyDccFunc+0x58>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:314
    uint8   i ;
    uint8   Fx ;

    switch( FuncGrp )
    {
    case FN_0_4:    F0 = bitRead( FuncState, 4 ) ;          // put F0 in front
     802:	82 2f       	mov	r24, r18
     804:	90 e0       	ldi	r25, 0x00	; 0
     806:	22 95       	swap	r18
     808:	21 70       	andi	r18, 0x01	; 1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:315
                    FuncState = (FuncState << 1) | F0 ;     // and shift the others
     80a:	88 0f       	add	r24, r24
     80c:	99 1f       	adc	r25, r25
     80e:	28 2b       	or	r18, r24
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:316
                    beginF =  0 ; endF =  4 ; goto setFunc ;
     810:	54 e0       	ldi	r21, 0x04	; 4
     812:	90 e0       	ldi	r25, 0x00	; 0
     814:	cf cf       	rjmp	.-98     	; 0x7b4 <notifyDccFunc+0x36>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:319
    case FN_5_8:    beginF =  5 ; endF =  8 ; goto setFunc ;
    case FN_9_12:   beginF =  9 ; endF = 12 ; goto setFunc ;
    case FN_13_20:  beginF = 13 ; endF = 20 ; goto setFunc ;
     816:	54 e1       	ldi	r21, 0x14	; 20
     818:	9d e0       	ldi	r25, 0x0D	; 13
     81a:	cc cf       	rjmp	.-104    	; 0x7b4 <notifyDccFunc+0x36>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:318
    {
    case FN_0_4:    F0 = bitRead( FuncState, 4 ) ;          // put F0 in front
                    FuncState = (FuncState << 1) | F0 ;     // and shift the others
                    beginF =  0 ; endF =  4 ; goto setFunc ;
    case FN_5_8:    beginF =  5 ; endF =  8 ; goto setFunc ;
    case FN_9_12:   beginF =  9 ; endF = 12 ; goto setFunc ;
     81c:	5c e0       	ldi	r21, 0x0C	; 12
     81e:	99 e0       	ldi	r25, 0x09	; 9
     820:	c9 cf       	rjmp	.-110    	; 0x7b4 <notifyDccFunc+0x36>
     822:	80 91 8f 38 	lds	r24, 0x388F	; 0x80388f <A>
     826:	40 fb       	bst	r20, 0
     828:	87 f9       	bld	r24, 7
     82a:	80 93 8f 38 	sts	0x388F, r24	; 0x80388f <A>
     82e:	80 91 8a 38 	lds	r24, 0x388A	; 0x80388a <B>
     832:	30 fb       	bst	r19, 0
     834:	87 f9       	bld	r24, 7
     836:	80 93 8a 38 	sts	0x388A, r24	; 0x80388a <B>
     83a:	ae cf       	rjmp	.-164    	; 0x798 <notifyDccFunc+0x1a>

0000083c <notifyDccSpeed>:
notifyDccSpeed():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:281
    else                                           updateFunc() ;
}


void notifyDccSpeed(uint16_t Addr, DCC_ADDR_TYPE AddrType, uint8_t Speed, DCC_DIRECTION Dir, DCC_SPEED_STEPS SpeedSteps)
{
     83c:	0f 93       	push	r16
     83e:	1f 93       	push	r17
     840:	cf 93       	push	r28
     842:	c2 2f       	mov	r28, r18
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:282
    setPoint    = map( Speed, 1, SpeedSteps, 0, 100 ) ;   // remap DCC speed to pwm controller speed levels
     844:	50 e0       	ldi	r21, 0x00	; 0
     846:	70 e0       	ldi	r23, 0x00	; 0
     848:	60 e0       	ldi	r22, 0x00	; 0
map():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore\api/Common.cpp:5
#include "Common.h"

/* C++ prototypes */
long map(long x, long in_min, long in_max, long out_min, long out_max) {
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
     84a:	9a 01       	movw	r18, r20
     84c:	ab 01       	movw	r20, r22
     84e:	21 50       	subi	r18, 0x01	; 1
     850:	31 09       	sbc	r19, r1
     852:	41 09       	sbc	r20, r1
     854:	51 09       	sbc	r21, r1
     856:	a4 e6       	ldi	r26, 0x64	; 100
     858:	b0 e0       	ldi	r27, 0x00	; 0
     85a:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <__muluhisi3>
notifyDccSpeed():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:282
     85e:	30 e0       	ldi	r19, 0x00	; 0
     860:	20 e0       	ldi	r18, 0x00	; 0
map():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore\api/Common.cpp:5
     862:	a9 01       	movw	r20, r18
     864:	98 01       	movw	r18, r16
     866:	21 50       	subi	r18, 0x01	; 1
     868:	31 09       	sbc	r19, r1
     86a:	41 09       	sbc	r20, r1
     86c:	51 09       	sbc	r21, r1
     86e:	0e 94 1c 0e 	call	0x1c38	; 0x1c38 <__divmodsi4>
notifyDccSpeed():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:282
     872:	20 93 88 38 	sts	0x3888, r18	; 0x803888 <setPoint>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:283
    dir         = Dir ^ (my.modeControl & 0x01) ;                   // XOR received dir with my own reverse direction bit
     876:	80 91 9c 38 	lds	r24, 0x389C	; 0x80389c <my+0x9>
     87a:	81 70       	andi	r24, 0x01	; 1
     87c:	8c 27       	eor	r24, r28
     87e:	80 93 8e 38 	sts	0x388E, r24	; 0x80388e <dir>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:284
    if( dir )   setPoint =-setPoint ;
     882:	88 23       	and	r24, r24
     884:	19 f0       	breq	.+6      	; 0x88c <notifyDccSpeed+0x50>
     886:	21 95       	neg	r18
     888:	20 93 88 38 	sts	0x3888, r18	; 0x803888 <setPoint>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:285
}
     88c:	cf 91       	pop	r28
     88e:	1f 91       	pop	r17
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1645
}

////////////////////////////////////////////////////////////////////////
uint8_t NmraDcc::getCV (uint16_t CV)
{
    return readCV (CV);
     890:	0f 91       	pop	r16
     892:	08 95       	ret

00000894 <loadCV()>:
_Z6loadCVv():
     894:	8f ef       	ldi	r24, 0xFF	; 255
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:216
}


void loadCV()
{
    if( dcc.getCV( 511 ) != 0xCC )
     896:	91 e0       	ldi	r25, 0x01	; 1
     898:	14 df       	rcall	.-472    	; 0x6c2 <readCV(unsigned int)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:217
    {   dcc.setCV( 511,     0xCC ) ; // use factory reset CV
     89a:	8c 3c       	cpi	r24, 0xCC	; 204
     89c:	09 f4       	brne	.+2      	; 0x8a0 <loadCV()+0xc>
     89e:	44 c0       	rjmp	.+136    	; 0x928 <loadCV()+0x94>
     8a0:	6c ec       	ldi	r22, 0xCC	; 204
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:219

        dcc.setCV(   1, 3 ) ; // addressPrimary 
     8a2:	8f ef       	ldi	r24, 0xFF	; 255
     8a4:	91 e0       	ldi	r25, 0x01	; 1
     8a6:	ff de       	rcall	.-514    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     8a8:	63 e0       	ldi	r22, 0x03	; 3
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:221

        dcc.setCV(   2,   1 ) ; // speedMin    1
     8aa:	81 e0       	ldi	r24, 0x01	; 1
     8ac:	90 e0       	ldi	r25, 0x00	; 0
     8ae:	fb de       	rcall	.-522    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     8b0:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:222
        dcc.setCV(   3,  10 ) ; // accelTime  10
     8b2:	82 e0       	ldi	r24, 0x02	; 2
     8b4:	90 e0       	ldi	r25, 0x00	; 0
     8b6:	f7 de       	rcall	.-530    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     8b8:	6a e0       	ldi	r22, 0x0A	; 10
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:223
        dcc.setCV(   4,  10 ) ; // decelTime  10
     8ba:	83 e0       	ldi	r24, 0x03	; 3
     8bc:	90 e0       	ldi	r25, 0x00	; 0
     8be:	f3 de       	rcall	.-538    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     8c0:	6a e0       	ldi	r22, 0x0A	; 10
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:224
        dcc.setCV(   5, 100 ) ; // maxSpeed  100
     8c2:	84 e0       	ldi	r24, 0x04	; 4
     8c4:	90 e0       	ldi	r25, 0x00	; 0
     8c6:	ef de       	rcall	.-546    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     8c8:	64 e6       	ldi	r22, 0x64	; 100
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:226

        dcc.setCV(  17,   0 ) ; // addrLow 
     8ca:	85 e0       	ldi	r24, 0x05	; 5
     8cc:	90 e0       	ldi	r25, 0x00	; 0
     8ce:	eb de       	rcall	.-554    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     8d0:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:227
        dcc.setCV(  18,   3 ) ; // addrHigh addr 3
     8d2:	81 e1       	ldi	r24, 0x11	; 17
     8d4:	90 e0       	ldi	r25, 0x00	; 0
     8d6:	e7 de       	rcall	.-562    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     8d8:	63 e0       	ldi	r22, 0x03	; 3
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:229

        dcc.setCV(  29,   2 ) ; // modeControl  128 steps on, rest dont care
     8da:	82 e1       	ldi	r24, 0x12	; 18
     8dc:	90 e0       	ldi	r25, 0x00	; 0
     8de:	e3 de       	rcall	.-570    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     8e0:	62 e0       	ldi	r22, 0x02	; 2
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:230
        dcc.setCV(  65,   5 ) ; // kickStartTime 5ms 
     8e2:	8d e1       	ldi	r24, 0x1D	; 29
     8e4:	90 e0       	ldi	r25, 0x00	; 0
     8e6:	df de       	rcall	.-578    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     8e8:	65 e0       	ldi	r22, 0x05	; 5
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:232
        
        dcc.setCV( 112,   0 ) ; // mode -> Lopi
     8ea:	81 e4       	ldi	r24, 0x41	; 65
     8ec:	90 e0       	ldi	r25, 0x00	; 0
     8ee:	db de       	rcall	.-586    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     8f0:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:234

        dcc.setCV( 113,   4 ) ; // F1dir 
     8f2:	80 e7       	ldi	r24, 0x70	; 112
     8f4:	90 e0       	ldi	r25, 0x00	; 0
     8f6:	d7 de       	rcall	.-594    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     8f8:	64 e0       	ldi	r22, 0x04	; 4
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:235
        dcc.setCV( 114,   0 ) ; // F1time 
     8fa:	81 e7       	ldi	r24, 0x71	; 113
     8fc:	90 e0       	ldi	r25, 0x00	; 0
     8fe:	d3 de       	rcall	.-602    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     900:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:236
        dcc.setCV( 115,   1 ) ; // F1pseudo 
     902:	82 e7       	ldi	r24, 0x72	; 114
     904:	90 e0       	ldi	r25, 0x00	; 0
     906:	cf de       	rcall	.-610    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     908:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:238
        
        dcc.setCV( 116,   4 ) ; // F2dir 
     90a:	83 e7       	ldi	r24, 0x73	; 115
     90c:	90 e0       	ldi	r25, 0x00	; 0
     90e:	cb de       	rcall	.-618    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     910:	64 e0       	ldi	r22, 0x04	; 4
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:239
        dcc.setCV( 117,   0 ) ; // F2time 
     912:	84 e7       	ldi	r24, 0x74	; 116
     914:	90 e0       	ldi	r25, 0x00	; 0
     916:	c7 de       	rcall	.-626    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     918:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:240
        dcc.setCV( 118,   2 ) ; // F2pseudo 
     91a:	85 e7       	ldi	r24, 0x75	; 117
     91c:	90 e0       	ldi	r25, 0x00	; 0
     91e:	c3 de       	rcall	.-634    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     920:	62 e0       	ldi	r22, 0x02	; 2
     922:	86 e7       	ldi	r24, 0x76	; 118
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1645
     924:	90 e0       	ldi	r25, 0x00	; 0
     926:	bf de       	rcall	.-642    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
getCV():
     928:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:243
    }

    my.addressPrimary       = dcc.getCV(   1 ) ;
     92a:	90 e0       	ldi	r25, 0x00	; 0
     92c:	ca de       	rcall	.-620    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1645
     92e:	80 93 93 38 	sts	0x3893, r24	; 0x803893 <my>
getCV():
     932:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:244
    my.speedMin             = dcc.getCV(   2 ) ;
     934:	90 e0       	ldi	r25, 0x00	; 0
     936:	c5 de       	rcall	.-630    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1645
     938:	80 93 94 38 	sts	0x3894, r24	; 0x803894 <my+0x1>
getCV():
     93c:	83 e0       	ldi	r24, 0x03	; 3
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:245
    my.accelTime            = dcc.getCV(   3 ) ;
     93e:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1645
     940:	c0 de       	rcall	.-640    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
     942:	80 93 95 38 	sts	0x3895, r24	; 0x803895 <my+0x2>
getCV():
     946:	84 e0       	ldi	r24, 0x04	; 4
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:246
    my.decelTime            = dcc.getCV(   4 ) ;
     948:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1645
     94a:	bb de       	rcall	.-650    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
     94c:	80 93 96 38 	sts	0x3896, r24	; 0x803896 <my+0x3>
getCV():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:247
    my.maxSpeed             = dcc.getCV(   5 ) ;
     950:	85 e0       	ldi	r24, 0x05	; 5
     952:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:248
    my.manufactorVersion    =   1 ;               // dcc.getCV(   7 ) ;
     954:	b6 de       	rcall	.-660    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
     956:	80 93 97 38 	sts	0x3897, r24	; 0x803897 <my+0x4>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:249
    my.manufactorID         = 123 ;               // dcc.getCV(   8 ) ; // I should get me a valid number registered somewhere..?
     95a:	81 e0       	ldi	r24, 0x01	; 1
     95c:	80 93 98 38 	sts	0x3898, r24	; 0x803898 <my+0x5>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1645
     960:	8b e7       	ldi	r24, 0x7B	; 123
     962:	80 93 99 38 	sts	0x3899, r24	; 0x803899 <my+0x6>
getCV():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:250
    my.addrLow              = dcc.getCV(  17 ) ;
     966:	81 e1       	ldi	r24, 0x11	; 17
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1645
     968:	90 e0       	ldi	r25, 0x00	; 0
     96a:	ab de       	rcall	.-682    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
     96c:	80 93 9a 38 	sts	0x389A, r24	; 0x80389a <my+0x7>
getCV():
     970:	82 e1       	ldi	r24, 0x12	; 18
     972:	90 e0       	ldi	r25, 0x00	; 0
     974:	a6 de       	rcall	.-692    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
     976:	80 93 9b 38 	sts	0x389B, r24	; 0x80389b <my+0x8>
getCV():
     97a:	8d e1       	ldi	r24, 0x1D	; 29
     97c:	90 e0       	ldi	r25, 0x00	; 0
     97e:	a1 de       	rcall	.-702    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
     980:	80 93 9c 38 	sts	0x389C, r24	; 0x80389c <my+0x9>
getCV():
     984:	81 e4       	ldi	r24, 0x41	; 65
     986:	90 e0       	ldi	r25, 0x00	; 0
     988:	9c de       	rcall	.-712    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:254
    my.addrHigh             = dcc.getCV(  18 ) ;
    my.modeControl          = dcc.getCV(  29 ) ;
    my.kickStartTime        = dcc.getCV(  65 ) ;
    my.mode                 = dcc.getCV( 112 ) ;
     98a:	80 93 9d 38 	sts	0x389D, r24	; 0x80389d <my+0xa>
getCV():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1645
     98e:	80 e7       	ldi	r24, 0x70	; 112
     990:	90 e0       	ldi	r25, 0x00	; 0
     992:	97 de       	rcall	.-722    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
     994:	80 93 9e 38 	sts	0x389E, r24	; 0x80389e <my+0xb>
getCV():
     998:	81 e7       	ldi	r24, 0x71	; 113
     99a:	90 e0       	ldi	r25, 0x00	; 0
     99c:	92 de       	rcall	.-732    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
     99e:	80 93 9f 38 	sts	0x389F, r24	; 0x80389f <my+0xc>
getCV():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:256
    my.F1dir                = dcc.getCV( 113 ) ;
    my.F1time               = dcc.getCV( 114 ) ;
     9a2:	82 e7       	ldi	r24, 0x72	; 114
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1645
     9a4:	90 e0       	ldi	r25, 0x00	; 0
     9a6:	8d de       	rcall	.-742    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
     9a8:	80 93 a0 38 	sts	0x38A0, r24	; 0x8038a0 <my+0xd>
getCV():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:257
    my.F1pseudo             = dcc.getCV( 115 ) ;
     9ac:	83 e7       	ldi	r24, 0x73	; 115
     9ae:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1645
     9b0:	88 de       	rcall	.-752    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
     9b2:	80 93 a1 38 	sts	0x38A1, r24	; 0x8038a1 <my+0xe>
getCV():
     9b6:	84 e7       	ldi	r24, 0x74	; 116
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:258
    my.F2dir                = dcc.getCV( 116 ) ;
     9b8:	90 e0       	ldi	r25, 0x00	; 0
     9ba:	83 de       	rcall	.-762    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1645
     9bc:	80 93 a2 38 	sts	0x38A2, r24	; 0x8038a2 <my+0xf>
getCV():
     9c0:	85 e7       	ldi	r24, 0x75	; 117
     9c2:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:259
    my.F2time               = dcc.getCV( 117 ) ;
     9c4:	7e de       	rcall	.-772    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
     9c6:	80 93 a3 38 	sts	0x38A3, r24	; 0x8038a3 <my+0x10>
getCV():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1645
     9ca:	86 e7       	ldi	r24, 0x76	; 118
     9cc:	90 e0       	ldi	r25, 0x00	; 0
     9ce:	79 de       	rcall	.-782    	; 0x6c2 <readCV(unsigned int)>
_Z6loadCVv():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:260
    my.F2pseudo             = dcc.getCV( 118 ) ;
     9d0:	80 93 a4 38 	sts	0x38A4, r24	; 0x8038a4 <my+0x11>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:261
}
     9d4:	08 95       	ret

000009d6 <notifyCVResetFactoryDefault>:
notifyCVResetFactoryDefault():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:337
}


void notifyCVResetFactoryDefault()
{
    dcc.setCV(511, 123 ) ; // ensure that new CV will be loaded
     9d6:	6b e7       	ldi	r22, 0x7B	; 123
     9d8:	8f ef       	ldi	r24, 0xFF	; 255
     9da:	91 e0       	ldi	r25, 0x01	; 1
     9dc:	64 de       	rcall	.-824    	; 0x6a6 <NmraDcc::setCV(unsigned int, unsigned char) [clone .constprop.11]>
     9de:	5a cf       	rjmp	.-332    	; 0x894 <loadCV()>

000009e0 <validCV(unsigned int, unsigned char)>:
_Z7validCVjh():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:338
    loadCV() ;
     9e0:	1f 93       	push	r17
     9e2:	cf 93       	push	r28
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:821
    return true;
    #endif
}

uint8_t validCV (uint16_t CV, uint8_t Writable)
{
     9e4:	df 93       	push	r29
     9e6:	ec 01       	movw	r28, r24
     9e8:	16 2f       	mov	r17, r22
     9ea:	08 97       	sbiw	r24, 0x08	; 8
     9ec:	71 f4       	brne	.+28     	; 0xa0a <validCV(unsigned int, unsigned char)+0x2a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:822
    if (notifyCVResetFactoryDefault && (CV == CV_MANUFACTURER_ID)  && Writable)
     9ee:	66 23       	and	r22, r22
     9f0:	11 f1       	breq	.+68     	; 0xa36 <validCV(unsigned int, unsigned char)+0x56>
     9f2:	f1 df       	rcall	.-30     	; 0x9d6 <notifyCVResetFactoryDefault>
     9f4:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:823
        notifyCVResetFactoryDefault();
     9f6:	90 e0       	ldi	r25, 0x00	; 0
     9f8:	89 2b       	or	r24, r25
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:825

    if (notifyCVValid)
     9fa:	b9 f0       	breq	.+46     	; 0xa2a <validCV(unsigned int, unsigned char)+0x4a>
     9fc:	61 2f       	mov	r22, r17
     9fe:	ce 01       	movw	r24, r28
     a00:	df 91       	pop	r29
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:826
        return notifyCVValid (CV, Writable) ;
     a02:	cf 91       	pop	r28
     a04:	1f 91       	pop	r17
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:837

    if (Writable && ( (CV ==CV_VERSION_ID) || (CV == CV_MANUFACTURER_ID)))
        Valid = 0 ;

    return Valid ;
}
     a06:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:826
{
    if (notifyCVResetFactoryDefault && (CV == CV_MANUFACTURER_ID)  && Writable)
        notifyCVResetFactoryDefault();

    if (notifyCVValid)
        return notifyCVValid (CV, Writable) ;
     a0a:	80 e0       	ldi	r24, 0x00	; 0
     a0c:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:825
uint8_t validCV (uint16_t CV, uint8_t Writable)
{
    if (notifyCVResetFactoryDefault && (CV == CV_MANUFACTURER_ID)  && Writable)
        notifyCVResetFactoryDefault();

    if (notifyCVValid)
     a0e:	89 2b       	or	r24, r25
     a10:	a9 f7       	brne	.-22     	; 0x9fc <validCV(unsigned int, unsigned char)+0x1c>
     a12:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:830
        return notifyCVValid (CV, Writable) ;

    uint8_t Valid = 1 ;

    if (CV > MAXCV)
     a14:	c1 15       	cp	r28, r1
     a16:	95 e1       	ldi	r25, 0x15	; 21
     a18:	d9 07       	cpc	r29, r25
     a1a:	08 f0       	brcs	.+2      	; 0xa1e <validCV(unsigned int, unsigned char)+0x3e>
     a1c:	80 e0       	ldi	r24, 0x00	; 0
     a1e:	11 11       	cpse	r17, r1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:833
        Valid = 0 ;

    if (Writable && ( (CV ==CV_VERSION_ID) || (CV == CV_MANUFACTURER_ID)))
     a20:	05 c0       	rjmp	.+10     	; 0xa2c <validCV(unsigned int, unsigned char)+0x4c>
     a22:	df 91       	pop	r29
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:837
        Valid = 0 ;

    return Valid ;
}
     a24:	cf 91       	pop	r28
     a26:	1f 91       	pop	r17
     a28:	08 95       	ret
     a2a:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:828
        notifyCVResetFactoryDefault();

    if (notifyCVValid)
        return notifyCVValid (CV, Writable) ;

    uint8_t Valid = 1 ;
     a2c:	27 97       	sbiw	r28, 0x07	; 7
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:833

    if (CV > MAXCV)
        Valid = 0 ;

    if (Writable && ( (CV ==CV_VERSION_ID) || (CV == CV_MANUFACTURER_ID)))
     a2e:	22 97       	sbiw	r28, 0x02	; 2
     a30:	c0 f7       	brcc	.-16     	; 0xa22 <validCV(unsigned int, unsigned char)+0x42>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:834
        Valid = 0 ;
     a32:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:825
uint8_t validCV (uint16_t CV, uint8_t Writable)
{
    if (notifyCVResetFactoryDefault && (CV == CV_MANUFACTURER_ID)  && Writable)
        notifyCVResetFactoryDefault();

    if (notifyCVValid)
     a34:	f6 cf       	rjmp	.-20     	; 0xa22 <validCV(unsigned int, unsigned char)+0x42>
     a36:	80 e0       	ldi	r24, 0x00	; 0
     a38:	90 e0       	ldi	r25, 0x00	; 0
     a3a:	89 2b       	or	r24, r25
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:828
        return notifyCVValid (CV, Writable) ;

    uint8_t Valid = 1 ;
     a3c:	f9 f6       	brne	.-66     	; 0x9fc <validCV(unsigned int, unsigned char)+0x1c>
     a3e:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:910

    return DccProcState.myDccAddress ;
}

void processDirectCVOperation (uint8_t Cmd, uint16_t CVAddr, uint8_t Value, void (*ackFunction) ())
{
     a40:	f0 cf       	rjmp	.-32     	; 0xa22 <validCV(unsigned int, unsigned char)+0x42>

00000a42 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())>:
_Z24processDirectCVOperationhjhPFvvE():
     a42:	bf 92       	push	r11
     a44:	cf 92       	push	r12
     a46:	df 92       	push	r13
     a48:	ef 92       	push	r14
     a4a:	ff 92       	push	r15
     a4c:	0f 93       	push	r16
     a4e:	1f 93       	push	r17
     a50:	cf 93       	push	r28
     a52:	df 93       	push	r29
     a54:	8b 01       	movw	r16, r22
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:912
    // is it a Byte Operation
    if (Cmd & 0x04)
     a56:	b4 2e       	mov	r11, r20
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:915
    {
        // Perform the Write Operation
        if (Cmd & 0x08)
     a58:	69 01       	movw	r12, r18
     a5a:	82 ff       	sbrs	r24, 2
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:917
        {
            if (validCV (CVAddr, 1))
     a5c:	1f c0       	rjmp	.+62     	; 0xa9c <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x5a>
     a5e:	83 ff       	sbrs	r24, 3
     a60:	15 c0       	rjmp	.+42     	; 0xa8c <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x4a>
     a62:	61 e0       	ldi	r22, 0x01	; 1
     a64:	c8 01       	movw	r24, r16
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:920
            {
                DB_PRINT ("CV: %d Byte Write: %02X", CVAddr, Value)
                if (writeCV (CVAddr, Value) == Value)
     a66:	bc df       	rcall	.-136    	; 0x9e0 <validCV(unsigned int, unsigned char)>
     a68:	88 23       	and	r24, r24
     a6a:	a9 f1       	breq	.+106    	; 0xad6 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x94>
     a6c:	6b 2d       	mov	r22, r11
     a6e:	c8 01       	movw	r24, r16
     a70:	b5 dd       	rcall	.-1174   	; 0x5dc <writeCV(unsigned int, unsigned char)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:921
                    ackFunction();
     a72:	8b 11       	cpse	r24, r11
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:980
                        ackFunction() ;
                }
            }
        }
    }
}
     a74:	30 c0       	rjmp	.+96     	; 0xad6 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x94>
     a76:	f6 01       	movw	r30, r12
     a78:	df 91       	pop	r29
     a7a:	cf 91       	pop	r28
     a7c:	1f 91       	pop	r17
     a7e:	0f 91       	pop	r16
     a80:	ff 90       	pop	r15
     a82:	ef 90       	pop	r14
     a84:	df 90       	pop	r13
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:921
        {
            if (validCV (CVAddr, 1))
            {
                DB_PRINT ("CV: %d Byte Write: %02X", CVAddr, Value)
                if (writeCV (CVAddr, Value) == Value)
                    ackFunction();
     a86:	cf 90       	pop	r12
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:927
            }
        }

        else  // Perform the Verify Operation
        {
            if (validCV (CVAddr, 0))
     a88:	bf 90       	pop	r11
     a8a:	09 94       	ijmp
     a8c:	60 e0       	ldi	r22, 0x00	; 0
     a8e:	c8 01       	movw	r24, r16
     a90:	a7 df       	rcall	.-178    	; 0x9e0 <validCV(unsigned int, unsigned char)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:930
            {
                DB_PRINT ("CV: %d Byte Read: %02X", CVAddr, Value)
                if (readCV (CVAddr) == Value)
     a92:	88 23       	and	r24, r24
     a94:	01 f1       	breq	.+64     	; 0xad6 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x94>
     a96:	c8 01       	movw	r24, r16
     a98:	14 de       	rcall	.-984    	; 0x6c2 <readCV(unsigned int)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:938
        }
    }
    // Perform the Bit-Wise Operation
    else
    {
        uint8_t BitMask = (1 << (Value & 0x07)) ;
     a9a:	eb cf       	rjmp	.-42     	; 0xa72 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x30>
     a9c:	84 2f       	mov	r24, r20
     a9e:	87 70       	andi	r24, 0x07	; 7
     aa0:	c1 e0       	ldi	r28, 0x01	; 1
     aa2:	d0 e0       	ldi	r29, 0x00	; 0
     aa4:	7e 01       	movw	r14, r28
     aa6:	01 c0       	rjmp	.+2      	; 0xaaa <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x68>
     aa8:	ee 0c       	add	r14, r14
     aaa:	8a 95       	dec	r24
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:939
        uint8_t BitValue = Value & 0x08 ;
     aac:	ea f7       	brpl	.-6      	; 0xaa8 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x66>
     aae:	d4 2f       	mov	r29, r20
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:942
        uint8_t BitWrite = Value & 0x10 ;

        uint8_t tempValue = readCV (CVAddr) ;   // Read the Current CV Value
     ab0:	d8 70       	andi	r29, 0x08	; 8
     ab2:	cb 01       	movw	r24, r22
     ab4:	06 de       	rcall	.-1012   	; 0x6c2 <readCV(unsigned int)>
     ab6:	c8 2f       	mov	r28, r24
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:947

        DB_PRINT ("CV: %d Current Value: %02X  Bit-Wise Mode: %s  Mask: %02X  Value: %02X", CVAddr, tempValue, BitWrite ? "Write":"Read", BitMask, BitValue);

        // Perform the Bit Write Operation
        if (BitWrite)
     ab8:	b4 fe       	sbrs	r11, 4
     aba:	1a c0       	rjmp	.+52     	; 0xaf0 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0xae>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:949
        {
            if (validCV (CVAddr, 1))
     abc:	61 e0       	ldi	r22, 0x01	; 1
     abe:	c8 01       	movw	r24, r16
     ac0:	8f df       	rcall	.-226    	; 0x9e0 <validCV(unsigned int, unsigned char)>
     ac2:	88 23       	and	r24, r24
     ac4:	41 f0       	breq	.+16     	; 0xad6 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x94>
     ac6:	dd 23       	and	r29, r29
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:951
            {
                if (BitValue)
     ac8:	81 f0       	breq	.+32     	; 0xaea <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0xa8>
     aca:	ce 29       	or	r28, r14
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:952
                    tempValue |= BitMask ;     // Turn the Bit On
     acc:	6c 2f       	mov	r22, r28
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:957

                else
                    tempValue &= ~BitMask ;  // Turn the Bit Off

                if (writeCV (CVAddr, tempValue) == tempValue)
     ace:	c8 01       	movw	r24, r16
     ad0:	85 dd       	rcall	.-1270   	; 0x5dc <writeCV(unsigned int, unsigned char)>
     ad2:	8c 17       	cp	r24, r28
     ad4:	81 f2       	breq	.-96     	; 0xa76 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x34>
     ad6:	df 91       	pop	r29
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:980
                        ackFunction() ;
                }
            }
        }
    }
}
     ad8:	cf 91       	pop	r28
     ada:	1f 91       	pop	r17
     adc:	0f 91       	pop	r16
     ade:	ff 90       	pop	r15
     ae0:	ef 90       	pop	r14
     ae2:	df 90       	pop	r13
     ae4:	cf 90       	pop	r12
     ae6:	bf 90       	pop	r11
     ae8:	08 95       	ret
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:955
            {
                if (BitValue)
                    tempValue |= BitMask ;     // Turn the Bit On

                else
                    tempValue &= ~BitMask ;  // Turn the Bit Off
     aea:	e0 94       	com	r14
     aec:	ce 21       	and	r28, r14
     aee:	ee cf       	rjmp	.-36     	; 0xacc <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x8a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:965
        }

        // Perform the Bit Verify Operation
        else
        {
            if (validCV (CVAddr, 0))
     af0:	60 e0       	ldi	r22, 0x00	; 0
     af2:	c8 01       	movw	r24, r16
     af4:	75 df       	rcall	.-278    	; 0x9e0 <validCV(unsigned int, unsigned char)>
     af6:	88 23       	and	r24, r24
     af8:	71 f3       	breq	.-36     	; 0xad6 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x94>
     afa:	ce 21       	and	r28, r14
     afc:	dd 23       	and	r29, r29
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:967
            {
                if (BitValue)
     afe:	19 f0       	breq	.+6      	; 0xb06 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0xc4>
     b00:	c1 11       	cpse	r28, r1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:969
                {
                    if (tempValue & BitMask)
     b02:	b9 cf       	rjmp	.-142    	; 0xa76 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x34>
     b04:	e8 cf       	rjmp	.-48     	; 0xad6 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x94>
     b06:	cc 23       	and	r28, r28
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:974
                        ackFunction() ;
                }
                else
                {
                    if (! (tempValue & BitMask))
     b08:	09 f4       	brne	.+2      	; 0xb0c <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0xca>
     b0a:	b5 cf       	rjmp	.-150    	; 0xa76 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x34>
     b0c:	e4 cf       	rjmp	.-56     	; 0xad6 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())+0x94>

00000b0e <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)>:
_Z27processMultiFunctionMessagej13DCC_ADDR_TYPEhhh():
     b0e:	cf 92       	push	r12
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:985
}

/////////////////////////////////////////////////////////////////////////
#ifdef NMRA_DCC_PROCESS_MULTIFUNCTION
void processMultiFunctionMessage (uint16_t Addr, DCC_ADDR_TYPE AddrType, uint8_t Cmd, uint8_t Data1, uint8_t Data2)
{
     b10:	df 92       	push	r13
     b12:	ef 92       	push	r14
     b14:	ff 92       	push	r15
     b16:	0f 93       	push	r16
     b18:	1f 93       	push	r17
     b1a:	cf 93       	push	r28
     b1c:	df 93       	push	r29
     b1e:	7c 01       	movw	r14, r24
     b20:	6b 01       	movw	r12, r22
     b22:	c4 2f       	mov	r28, r20
     b24:	12 2f       	mov	r17, r18
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:991
    uint8_t  speed ;
    uint16_t CVAddr ;
    DCC_DIRECTION dir ;
    DCC_SPEED_STEPS speedSteps ;

    uint8_t  CmdMasked = Cmd & 0b11100000 ;
     b26:	d4 2f       	mov	r29, r20
     b28:	d0 7e       	andi	r29, 0xE0	; 224
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:994

    // If we are an Accessory Decoder
    if (DccProcState.Flags & FLAGS_DCC_ACCESSORY_DECODER)
     b2a:	80 91 ad 38 	lds	r24, 0x38AD	; 0x8038ad <DccProcState>
     b2e:	87 ff       	sbrs	r24, 7
     b30:	29 c0       	rjmp	.+82     	; 0xb84 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x76>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:998
    {
        // and this isn't an Ops Mode Write or we are NOT faking the Multifunction Ops mode address in CV 33+34 or
        // it's not our fake address, then return
        if ( (CmdMasked != 0b11100000) || (DccProcState.OpsModeAddressBaseCV == 0))
     b32:	d0 3e       	cpi	r29, 0xE0	; 224
     b34:	a9 f5       	brne	.+106    	; 0xba0 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x92>
     b36:	80 91 ae 38 	lds	r24, 0x38AE	; 0x8038ae <DccProcState+0x1>
     b3a:	88 23       	and	r24, r24
     b3c:	89 f1       	breq	.+98     	; 0xba0 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x92>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1001
            return ;

        uint16_t FakeOpsAddr = readCV (DccProcState.OpsModeAddressBaseCV) | (readCV (DccProcState.OpsModeAddressBaseCV + 1) << 8) ;
     b3e:	90 e0       	ldi	r25, 0x00	; 0
     b40:	c0 dd       	rcall	.-1152   	; 0x6c2 <readCV(unsigned int)>
     b42:	d8 2f       	mov	r29, r24
     b44:	80 91 ae 38 	lds	r24, 0x38AE	; 0x8038ae <DccProcState+0x1>
     b48:	90 e0       	ldi	r25, 0x00	; 0
     b4a:	01 96       	adiw	r24, 0x01	; 1
     b4c:	ba dd       	rcall	.-1164   	; 0x6c2 <readCV(unsigned int)>
     b4e:	98 2f       	mov	r25, r24
     b50:	8d 2f       	mov	r24, r29
     b52:	e8 16       	cp	r14, r24
     b54:	f9 06       	cpc	r15, r25
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1004
        uint16_t OpsAddr = Addr & 0x3FFF ;

        if (OpsAddr != FakeOpsAddr)
     b56:	21 f5       	brne	.+72     	; 0xba0 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x92>
     b58:	6c 2f       	mov	r22, r28
     b5a:	70 e0       	ldi	r23, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1150
            break;
        }
        break;

    case 0b11100000:  // CV Access
        CVAddr = ( ( (Cmd & 0x03) << 8) | Data1) + 1 ;
     b5c:	76 2f       	mov	r23, r22
     b5e:	66 27       	eor	r22, r22
     b60:	66 27       	eor	r22, r22
     b62:	73 70       	andi	r23, 0x03	; 3
     b64:	61 2b       	or	r22, r17
     b66:	6f 5f       	subi	r22, 0xFF	; 255
     b68:	7f 4f       	sbci	r23, 0xFF	; 255
     b6a:	25 eb       	ldi	r18, 0xB5	; 181
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1152

        processDirectCVOperation (Cmd, CVAddr, Data2, ackAdvancedCV) ;
     b6c:	33 e0       	ldi	r19, 0x03	; 3
     b6e:	40 2f       	mov	r20, r16
     b70:	8c 2f       	mov	r24, r28
     b72:	df 91       	pop	r29
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1155
        break;
    }
}
     b74:	cf 91       	pop	r28
     b76:	1f 91       	pop	r17
     b78:	0f 91       	pop	r16
     b7a:	ff 90       	pop	r15
     b7c:	ef 90       	pop	r14
     b7e:	df 90       	pop	r13
     b80:	cf 90       	pop	r12
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1152
        break;

    case 0b11100000:  // CV Access
        CVAddr = ( ( (Cmd & 0x03) << 8) | Data1) + 1 ;

        processDirectCVOperation (Cmd, CVAddr, Data2, ackAdvancedCV) ;
     b82:	5f cf       	rjmp	.-322    	; 0xa42 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())>
     b84:	80 fd       	sbrc	r24, 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1009
        if (OpsAddr != FakeOpsAddr)
            return ;
    }

    // We are looking for FLAGS_MY_ADDRESS_ONLY but it does not match and it is not a Broadcast Address then return
    else if ( (DccProcState.Flags & FLAGS_MY_ADDRESS_ONLY) && (Addr != getMyAddr()) && (Addr != 0))
     b86:	31 c0       	rjmp	.+98     	; 0xbea <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0xdc>
     b88:	d0 36       	cpi	r29, 0x60	; 96
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1012
        return ;

    switch (CmdMasked)
     b8a:	09 f4       	brne	.+2      	; 0xb8e <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x80>
     b8c:	61 c0       	rjmp	.+194    	; 0xc50 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x142>
     b8e:	88 f4       	brcc	.+34     	; 0xbb2 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0xa4>
     b90:	d0 32       	cpi	r29, 0x20	; 32
     b92:	09 f4       	brne	.+2      	; 0xb96 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x88>
     b94:	45 c0       	rjmp	.+138    	; 0xc20 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x112>
     b96:	d0 34       	cpi	r29, 0x40	; 64
     b98:	09 f4       	brne	.+2      	; 0xb9c <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x8e>
     b9a:	5a c0       	rjmp	.+180    	; 0xc50 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x142>
     b9c:	dd 23       	and	r29, r29
     b9e:	69 f1       	breq	.+90     	; 0xbfa <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0xec>
     ba0:	df 91       	pop	r29
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1155
        CVAddr = ( ( (Cmd & 0x03) << 8) | Data1) + 1 ;

        processDirectCVOperation (Cmd, CVAddr, Data2, ackAdvancedCV) ;
        break;
    }
}
     ba2:	cf 91       	pop	r28
     ba4:	1f 91       	pop	r17
     ba6:	0f 91       	pop	r16
     ba8:	ff 90       	pop	r15
     baa:	ef 90       	pop	r14
     bac:	df 90       	pop	r13
     bae:	cf 90       	pop	r12
     bb0:	08 95       	ret
     bb2:	d0 3a       	cpi	r29, 0xA0	; 160
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1012

    // We are looking for FLAGS_MY_ADDRESS_ONLY but it does not match and it is not a Broadcast Address then return
    else if ( (DccProcState.Flags & FLAGS_MY_ADDRESS_ONLY) && (Addr != getMyAddr()) && (Addr != 0))
        return ;

    switch (CmdMasked)
     bb4:	09 f4       	brne	.+2      	; 0xbb8 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0xaa>
     bb6:	7f c0       	rjmp	.+254    	; 0xcb6 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x1a8>
     bb8:	88 f4       	brcc	.+34     	; 0xbdc <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0xce>
     bba:	2c 2f       	mov	r18, r28
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1120

    case 0b10000000:  // Function Group 0..4
        if (notifyDccFunc)
        {
            // function light is controlled by this package (28 or 128 speed steps)
            notifyDccFunc (Addr, AddrType, FN_0_4, Cmd & 0b00011111) ;
     bbc:	2f 71       	andi	r18, 0x1F	; 31
     bbe:	41 e0       	ldi	r20, 0x01	; 1
     bc0:	50 e0       	ldi	r21, 0x00	; 0
     bc2:	d0 38       	cpi	r29, 0x80	; 128
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1012

    // We are looking for FLAGS_MY_ADDRESS_ONLY but it does not match and it is not a Broadcast Address then return
    else if ( (DccProcState.Flags & FLAGS_MY_ADDRESS_ONLY) && (Addr != getMyAddr()) && (Addr != 0))
        return ;

    switch (CmdMasked)
     bc4:	69 f7       	brne	.-38     	; 0xba0 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x92>
     bc6:	b6 01       	movw	r22, r12
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1128

    case 0b10100000:  // Function Group 5..8
        if (notifyDccFunc)
        {
            if (Cmd & 0b00010000)
                notifyDccFunc (Addr, AddrType, FN_5_8,  Cmd & 0b00001111) ;
     bc8:	c7 01       	movw	r24, r14
     bca:	df 91       	pop	r29
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1155
        CVAddr = ( ( (Cmd & 0x03) << 8) | Data1) + 1 ;

        processDirectCVOperation (Cmd, CVAddr, Data2, ackAdvancedCV) ;
        break;
    }
}
     bcc:	cf 91       	pop	r28
     bce:	1f 91       	pop	r17
     bd0:	0f 91       	pop	r16
     bd2:	ff 90       	pop	r15
     bd4:	ef 90       	pop	r14
     bd6:	df 90       	pop	r13
     bd8:	cf 90       	pop	r12
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1128

    case 0b10100000:  // Function Group 5..8
        if (notifyDccFunc)
        {
            if (Cmd & 0b00010000)
                notifyDccFunc (Addr, AddrType, FN_5_8,  Cmd & 0b00001111) ;
     bda:	d1 cd       	rjmp	.-1118   	; 0x77e <notifyDccFunc>
     bdc:	d0 3c       	cpi	r29, 0xC0	; 192
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1012

    // We are looking for FLAGS_MY_ADDRESS_ONLY but it does not match and it is not a Broadcast Address then return
    else if ( (DccProcState.Flags & FLAGS_MY_ADDRESS_ONLY) && (Addr != getMyAddr()) && (Addr != 0))
        return ;

    switch (CmdMasked)
     bde:	09 f4       	brne	.+2      	; 0xbe2 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0xd4>
     be0:	73 c0       	rjmp	.+230    	; 0xcc8 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x1ba>
     be2:	d0 3e       	cpi	r29, 0xE0	; 224
     be4:	09 f4       	brne	.+2      	; 0xbe8 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0xda>
     be6:	b8 cf       	rjmp	.-144    	; 0xb58 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x4a>
     be8:	db cf       	rjmp	.-74     	; 0xba0 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x92>
     bea:	76 dd       	rcall	.-1300   	; 0x6d8 <getMyAddr()>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1009
        if (OpsAddr != FakeOpsAddr)
            return ;
    }

    // We are looking for FLAGS_MY_ADDRESS_ONLY but it does not match and it is not a Broadcast Address then return
    else if ( (DccProcState.Flags & FLAGS_MY_ADDRESS_ONLY) && (Addr != getMyAddr()) && (Addr != 0))
     bec:	8e 15       	cp	r24, r14
     bee:	9f 05       	cpc	r25, r15
     bf0:	59 f2       	breq	.-106    	; 0xb88 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x7a>
     bf2:	e1 14       	cp	r14, r1
     bf4:	f1 04       	cpc	r15, r1
     bf6:	41 f2       	breq	.-112    	; 0xb88 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x7a>
     bf8:	d3 cf       	rjmp	.-90     	; 0xba0 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x92>
     bfa:	8c 2f       	mov	r24, r28
     bfc:	8e 70       	andi	r24, 0x0E	; 14
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1015
        return ;

    switch (CmdMasked)
    {
    case 0b00000000:  // Decoder Control
        switch (Cmd & 0b00001110)
     bfe:	81 f6       	brne	.-96     	; 0xba0 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x92>
     c00:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1018
        {
        case 0b00000000:
            if (notifyDccReset)
     c02:	90 e0       	ldi	r25, 0x00	; 0
     c04:	89 2b       	or	r24, r25
     c06:	61 f2       	breq	.-104    	; 0xba0 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x92>
     c08:	8c 2f       	mov	r24, r28
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1019
                notifyDccReset (Cmd & 0b00000001) ;
     c0a:	81 70       	andi	r24, 0x01	; 1
     c0c:	df 91       	pop	r29
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1155
        CVAddr = ( ( (Cmd & 0x03) << 8) | Data1) + 1 ;

        processDirectCVOperation (Cmd, CVAddr, Data2, ackAdvancedCV) ;
        break;
    }
}
     c0e:	cf 91       	pop	r28
     c10:	1f 91       	pop	r17
     c12:	0f 91       	pop	r16
     c14:	ff 90       	pop	r15
     c16:	ef 90       	pop	r14
     c18:	df 90       	pop	r13
     c1a:	cf 90       	pop	r12
     c1c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1019
    case 0b00000000:  // Decoder Control
        switch (Cmd & 0b00001110)
        {
        case 0b00000000:
            if (notifyDccReset)
                notifyDccReset (Cmd & 0b00000001) ;
     c20:	cf 71       	andi	r28, 0x1F	; 31
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1040
            ;
        }
        break ;

    case 0b00100000:  // Advanced Operations
        switch (Cmd & 0b00011111)
     c22:	cf 31       	cpi	r28, 0x1F	; 31
     c24:	09 f0       	breq	.+2      	; 0xc28 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x11a>
     c26:	bc cf       	rjmp	.-136    	; 0xba0 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x92>
     c28:	41 2f       	mov	r20, r17
     c2a:	4f 77       	andi	r20, 0x7F	; 127
     c2c:	69 f0       	breq	.+26     	; 0xc48 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x13a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1045
        {
        case 0b00011111:
            if (notifyDccSpeed)
            {
                switch (Data1 & 0b01111111)
     c2e:	41 30       	cpi	r20, 0x01	; 1
     c30:	69 f0       	breq	.+26     	; 0xc4c <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x13e>
     c32:	11 1f       	adc	r17, r17
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1058
                    break ;

                default:          // 2..127
                    speed = (Data1 & 0b01111111) ;
                }
                dir = (DCC_DIRECTION) ( (Data1 & 0b10000000) >> 7) ;
     c34:	11 27       	eor	r17, r17
     c36:	11 1f       	adc	r17, r17
     c38:	21 2f       	mov	r18, r17
     c3a:	30 e0       	ldi	r19, 0x00	; 0
     c3c:	0f e7       	ldi	r16, 0x7F	; 127
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1059
                notifyDccSpeed (Addr, AddrType, speed, dir, SPEED_STEP_128) ;
     c3e:	10 e0       	ldi	r17, 0x00	; 0
     c40:	b6 01       	movw	r22, r12
     c42:	c7 01       	movw	r24, r14
     c44:	fb dd       	rcall	.-1034   	; 0x83c <notifyDccSpeed>
     c46:	ac cf       	rjmp	.-168    	; 0xba0 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x92>
     c48:	41 e0       	ldi	r20, 0x01	; 1
     c4a:	f3 cf       	rjmp	.-26     	; 0xc32 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x124>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1048
            if (notifyDccSpeed)
            {
                switch (Data1 & 0b01111111)
                {
                case 0b00000000:  // 0=STOP
                    speed = 1 ;     // => 1
     c4c:	40 e0       	ldi	r20, 0x00	; 0
     c4e:	f1 cf       	rjmp	.-30     	; 0xc32 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x124>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1052
                    break ;

                case 0b00000001:  // 1=EMERGENCY_STOP
                    speed = 0 ;     // => 0
     c50:	2c 2f       	mov	r18, r28
     c52:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1074
        #else
        speedSteps = SPEED_STEP_28 ;
        #endif
        if (notifyDccSpeed)
        {
            switch (Cmd & 0b00011111)
     c54:	8c 2f       	mov	r24, r28
     c56:	8f 71       	andi	r24, 0x1F	; 31
     c58:	81 30       	cpi	r24, 0x01	; 1
     c5a:	29 f0       	breq	.+10     	; 0xc66 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x158>
     c5c:	30 f0       	brcs	.+12     	; 0xc6a <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x15c>
     c5e:	80 31       	cpi	r24, 0x10	; 16
     c60:	21 f0       	breq	.+8      	; 0xc6a <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x15c>
     c62:	81 31       	cpi	r24, 0x11	; 17
     c64:	f1 f4       	brne	.+60     	; 0xca2 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x194>
     c66:	40 e0       	ldi	r20, 0x00	; 0
     c68:	01 c0       	rjmp	.+2      	; 0xc6c <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x15e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1083
                speed = 1 ;       // => 1
                break ;

            case 0b00000001:    // 0 0001 = EMERGENCY STOP
            case 0b00010001:    // 1 0001 = EMERGENCY STOP
                speed = 0 ;       // => 0
     c6a:	41 e0       	ldi	r20, 0x01	; 1
     c6c:	25 fb       	bst	r18, 5
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1078
        {
            switch (Cmd & 0b00011111)
            {
            case 0b00000000:    // 0 0000 = STOP
            case 0b00010000:    // 1 0000 = STOP
                speed = 1 ;       // => 1
     c6e:	22 27       	eor	r18, r18
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1100
                    speed = ( ( (Cmd & 0b00001111) << 1) | ( (Cmd & 0b00010000) >> 4)) - 2 ; // => 2..29
                    #ifdef NMRA_DCC_ENABLE_14_SPEED_STEP_MODE
                }
                    #endif
            }
            dir = (DCC_DIRECTION) ( (Cmd & 0b00100000) >> 5) ;
     c70:	20 f9       	bld	r18, 0
     c72:	0d e1       	ldi	r16, 0x1D	; 29
     c74:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1101
            notifyDccSpeed (Addr, AddrType, speed, dir, speedSteps) ;
     c76:	30 e0       	ldi	r19, 0x00	; 0
     c78:	b6 01       	movw	r22, r12
     c7a:	c7 01       	movw	r24, r14
     c7c:	df dd       	rcall	.-1090   	; 0x83c <notifyDccSpeed>
     c7e:	80 e0       	ldi	r24, 0x00	; 0
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	89 2b       	or	r24, r25
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1103
        }
        if (notifyDccSpeedRaw)
     c84:	09 f4       	brne	.+2      	; 0xc88 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x17a>
     c86:	8c cf       	rjmp	.-232    	; 0xba0 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x92>
     c88:	4c 2f       	mov	r20, r28
     c8a:	b6 01       	movw	r22, r12
     c8c:	c7 01       	movw	r24, r14
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1104
            notifyDccSpeedRaw (Addr, AddrType, Cmd);
     c8e:	df 91       	pop	r29
     c90:	cf 91       	pop	r28
     c92:	1f 91       	pop	r17
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1155
        CVAddr = ( ( (Cmd & 0x03) << 8) | Data1) + 1 ;

        processDirectCVOperation (Cmd, CVAddr, Data2, ackAdvancedCV) ;
        break;
    }
}
     c94:	0f 91       	pop	r16
     c96:	ff 90       	pop	r15
     c98:	ef 90       	pop	r14
     c9a:	df 90       	pop	r13
     c9c:	cf 90       	pop	r12
     c9e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
     ca2:	c9 01       	movw	r24, r18
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1104
            }
            dir = (DCC_DIRECTION) ( (Cmd & 0b00100000) >> 5) ;
            notifyDccSpeed (Addr, AddrType, speed, dir, speedSteps) ;
        }
        if (notifyDccSpeedRaw)
            notifyDccSpeedRaw (Addr, AddrType, Cmd);
     ca4:	88 0f       	add	r24, r24
     ca6:	99 1f       	adc	r25, r25
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1095
                    speed = (Cmd & 0b00001111) ; // => 2..15
                }
                else
                {
                #endif
                    speed = ( ( (Cmd & 0b00001111) << 1) | ( (Cmd & 0b00010000) >> 4)) - 2 ; // => 2..29
     ca8:	8e 71       	andi	r24, 0x1E	; 30
     caa:	c4 fb       	bst	r28, 4
     cac:	44 27       	eor	r20, r20
     cae:	40 f9       	bld	r20, 0
     cb0:	48 2b       	or	r20, r24
     cb2:	42 50       	subi	r20, 0x02	; 2
     cb4:	db cf       	rjmp	.-74     	; 0xc6c <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x15e>
     cb6:	2c 2f       	mov	r18, r28
     cb8:	2f 70       	andi	r18, 0x0F	; 15
     cba:	43 e0       	ldi	r20, 0x03	; 3
     cbc:	50 e0       	ldi	r21, 0x00	; 0
     cbe:	c4 ff       	sbrs	r28, 4
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1130
        if (notifyDccFunc)
        {
            if (Cmd & 0b00010000)
                notifyDccFunc (Addr, AddrType, FN_5_8,  Cmd & 0b00001111) ;
            else
                notifyDccFunc (Addr, AddrType, FN_9_12, Cmd & 0b00001111) ;
     cc0:	82 cf       	rjmp	.-252    	; 0xbc6 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0xb8>
     cc2:	42 e0       	ldi	r20, 0x02	; 2
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1127
        break;

    case 0b10100000:  // Function Group 5..8
        if (notifyDccFunc)
        {
            if (Cmd & 0b00010000)
     cc4:	50 e0       	ldi	r21, 0x00	; 0
     cc6:	7f cf       	rjmp	.-258    	; 0xbc6 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0xb8>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1128
                notifyDccFunc (Addr, AddrType, FN_5_8,  Cmd & 0b00001111) ;
     cc8:	cf 71       	andi	r28, 0x1F	; 31
     cca:	ce 31       	cpi	r28, 0x1E	; 30
     ccc:	39 f0       	breq	.+14     	; 0xcdc <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x1ce>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1135
                notifyDccFunc (Addr, AddrType, FN_9_12, Cmd & 0b00001111) ;
        }
        break;

    case 0b11000000:  // Feature Expansion Instruction
        switch (Cmd & 0b00011111)
     cce:	cf 31       	cpi	r28, 0x1F	; 31
     cd0:	09 f0       	breq	.+2      	; 0xcd4 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x1c6>
     cd2:	66 cf       	rjmp	.-308    	; 0xba0 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0x92>
     cd4:	21 2f       	mov	r18, r17
     cd6:	45 e0       	ldi	r20, 0x05	; 5
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1144
                notifyDccFunc (Addr, AddrType, FN_13_20, Data1) ;
            break;

        case 0b00011111:
            if (notifyDccFunc)
                notifyDccFunc (Addr, AddrType, FN_21_28, Data1) ;
     cd8:	50 e0       	ldi	r21, 0x00	; 0
     cda:	75 cf       	rjmp	.-278    	; 0xbc6 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0xb8>
     cdc:	21 2f       	mov	r18, r17
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1139
    case 0b11000000:  // Feature Expansion Instruction
        switch (Cmd & 0b00011111)
        {
        case 0b00011110:
            if (notifyDccFunc)
                notifyDccFunc (Addr, AddrType, FN_13_20, Data1) ;
     cde:	44 e0       	ldi	r20, 0x04	; 4
     ce0:	50 e0       	ldi	r21, 0x00	; 0
     ce2:	71 cf       	rjmp	.-286    	; 0xbc6 <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)+0xb8>

00000ce4 <followSpeed()>:
_Z11followSpeedv():
     ce4:	cf 92       	push	r12
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:92
NmraDcc dcc;
Weistra pwm(1, 2, 50, 100);


void followSpeed()
{
     ce6:	df 92       	push	r13
     ce8:	ef 92       	push	r14
     cea:	ff 92       	push	r15
     cec:	80 91 5d 38 	lds	r24, 0x385D	; 0x80385d <currentSpeed>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:93
    if( currentSpeed < setPoint ) currentSpeed ++ ;
     cf0:	90 91 88 38 	lds	r25, 0x3888	; 0x803888 <setPoint>
     cf4:	89 17       	cp	r24, r25
     cf6:	1c f4       	brge	.+6      	; 0xcfe <followSpeed()+0x1a>
     cf8:	8f 5f       	subi	r24, 0xFF	; 255
     cfa:	80 93 5d 38 	sts	0x385D, r24	; 0x80385d <currentSpeed>
     cfe:	80 91 5d 38 	lds	r24, 0x385D	; 0x80385d <currentSpeed>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:94
    if( currentSpeed > setPoint ) currentSpeed -- ;
     d02:	98 17       	cp	r25, r24
     d04:	1c f4       	brge	.+6      	; 0xd0c <followSpeed()+0x28>
     d06:	81 50       	subi	r24, 0x01	; 1
     d08:	80 93 5d 38 	sts	0x385D, r24	; 0x80385d <currentSpeed>
     d0c:	a0 91 5d 38 	lds	r26, 0x385D	; 0x80385d <currentSpeed>
setSpeed():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:95
    pwm.setSpeed( currentSpeed ) ;
     d10:	a7 ff       	sbrs	r26, 7
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:106


void Weistra::setSpeed( int8_t speed)
{
    byte frequency;
    if( speed < 0 ) dir = 1 ; // 1 is reverse
     d12:	5f c0       	rjmp	.+190    	; 0xdd2 <followSpeed()+0xee>
     d14:	81 e0       	ldi	r24, 0x01	; 1
     d16:	80 93 77 38 	sts	0x3877, r24	; 0x803877 <pwm+0x15>
     d1a:	0a 2e       	mov	r0, r26
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:109
    if( speed > 0 ) dir = 0 ;

    speed = abs( speed ) ;
     d1c:	00 0c       	add	r0, r0
     d1e:	bb 0b       	sbc	r27, r27
     d20:	b7 ff       	sbrs	r27, 7
     d22:	03 c0       	rjmp	.+6      	; 0xd2a <followSpeed()+0x46>
     d24:	b1 95       	neg	r27
     d26:	a1 95       	neg	r26
     d28:	b1 09       	sbc	r27, r1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:110
    if( speed > 0 ) speed = map( speed, 0, 100, minSpeed, maxSpeed ) ; // if speed is not 0, map speed accoring to min and max settings.
     d2a:	1a 16       	cp	r1, r26
     d2c:	cc f4       	brge	.+50     	; 0xd60 <followSpeed()+0x7c>
     d2e:	c0 90 74 38 	lds	r12, 0x3874	; 0x803874 <pwm+0x12>
     d32:	d1 2c       	mov	r13, r1
     d34:	f1 2c       	mov	r15, r1
     d36:	e1 2c       	mov	r14, r1
     d38:	20 91 75 38 	lds	r18, 0x3875	; 0x803875 <pwm+0x13>
     d3c:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore\api/Common.cpp:5
     d3e:	50 e0       	ldi	r21, 0x00	; 0
     d40:	40 e0       	ldi	r20, 0x00	; 0
map():
     d42:	2c 19       	sub	r18, r12
     d44:	3d 09       	sbc	r19, r13
     d46:	4e 09       	sbc	r20, r14
     d48:	5f 09       	sbc	r21, r15
     d4a:	0a 2e       	mov	r0, r26
     d4c:	00 0c       	add	r0, r0
     d4e:	bb 0b       	sbc	r27, r27
     d50:	a8 d7       	rcall	.+3920   	; 0x1ca2 <__mulshisi3>
     d52:	24 e6       	ldi	r18, 0x64	; 100
     d54:	30 e0       	ldi	r19, 0x00	; 0
     d56:	40 e0       	ldi	r20, 0x00	; 0
     d58:	50 e0       	ldi	r21, 0x00	; 0
     d5a:	6e d7       	rcall	.+3804   	; 0x1c38 <__divmodsi4>
setSpeed():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:110
     d5c:	a2 2f       	mov	r26, r18
     d5e:	ac 0d       	add	r26, r12
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:112

    newDutyCycle = constrain( speed, 0, 100 ) ; // speed limit = 0 - 100
     d60:	a7 fd       	sbrc	r26, 7
     d62:	3d c0       	rjmp	.+122    	; 0xdde <followSpeed()+0xfa>
     d64:	0a 2e       	mov	r0, r26
     d66:	00 0c       	add	r0, r0
     d68:	bb 0b       	sbc	r27, r27
     d6a:	a5 36       	cpi	r26, 0x65	; 101
     d6c:	b1 05       	cpc	r27, r1
     d6e:	14 f0       	brlt	.+4      	; 0xd74 <followSpeed()+0x90>
     d70:	a4 e6       	ldi	r26, 0x64	; 100
     d72:	b0 e0       	ldi	r27, 0x00	; 0
     d74:	6a 2f       	mov	r22, r26
     d76:	a0 93 71 38 	sts	0x3871, r26	; 0x803871 <pwm+0xf>
     d7a:	c0 90 72 38 	lds	r12, 0x3872	; 0x803872 <pwm+0x10>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:114

    if( newDutyCycle <= 10 ) { frequency = Fmin; }
     d7e:	ab 30       	cpi	r26, 0x0B	; 11
     d80:	d0 f0       	brcs	.+52     	; 0xdb6 <followSpeed()+0xd2>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:115
    else                     { frequency = map( newDutyCycle, 10, 100, Fmin, Fmax ) ; }
     d82:	d1 2c       	mov	r13, r1
     d84:	f1 2c       	mov	r15, r1
     d86:	e1 2c       	mov	r14, r1
     d88:	20 91 73 38 	lds	r18, 0x3873	; 0x803873 <pwm+0x11>
     d8c:	30 e0       	ldi	r19, 0x00	; 0
     d8e:	50 e0       	ldi	r21, 0x00	; 0
     d90:	40 e0       	ldi	r20, 0x00	; 0
map():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore\api/Common.cpp:5
     d92:	2c 19       	sub	r18, r12
     d94:	3d 09       	sbc	r19, r13
     d96:	4e 09       	sbc	r20, r14
     d98:	5f 09       	sbc	r21, r15
setSpeed():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:115
     d9a:	70 e0       	ldi	r23, 0x00	; 0
     d9c:	90 e0       	ldi	r25, 0x00	; 0
     d9e:	80 e0       	ldi	r24, 0x00	; 0
map():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore\api/Common.cpp:5
     da0:	6a 50       	subi	r22, 0x0A	; 10
     da2:	71 09       	sbc	r23, r1
     da4:	81 09       	sbc	r24, r1
     da6:	91 09       	sbc	r25, r1
     da8:	25 d7       	rcall	.+3658   	; 0x1bf4 <__mulsi3>
     daa:	2a e5       	ldi	r18, 0x5A	; 90
     dac:	30 e0       	ldi	r19, 0x00	; 0
     dae:	40 e0       	ldi	r20, 0x00	; 0
     db0:	50 e0       	ldi	r21, 0x00	; 0
     db2:	42 d7       	rcall	.+3716   	; 0x1c38 <__divmodsi4>
setSpeed():
     db4:	c2 0e       	add	r12, r18
     db6:	6c 2d       	mov	r22, r12
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:115
     db8:	70 e0       	ldi	r23, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:117

    newIntervalTime = 10000 / frequency; // > between 100us and 500us
     dba:	80 e1       	ldi	r24, 0x10	; 16
     dbc:	97 e2       	ldi	r25, 0x27	; 39
     dbe:	29 d7       	rcall	.+3666   	; 0x1c12 <__divmodhi4>
     dc0:	60 93 66 38 	sts	0x3866, r22	; 0x803866 <pwm+0x4>
     dc4:	70 93 67 38 	sts	0x3867, r23	; 0x803867 <pwm+0x5>
_Z11followSpeedv():
     dc8:	ff 90       	pop	r15
     dca:	ef 90       	pop	r14
     dcc:	df 90       	pop	r13
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:96
}
     dce:	cf 90       	pop	r12
     dd0:	08 95       	ret
setSpeed():
     dd2:	aa 23       	and	r26, r26
     dd4:	09 f4       	brne	.+2      	; 0xdd8 <followSpeed()+0xf4>
     dd6:	a1 cf       	rjmp	.-190    	; 0xd1a <followSpeed()+0x36>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:107

void Weistra::setSpeed( int8_t speed)
{
    byte frequency;
    if( speed < 0 ) dir = 1 ; // 1 is reverse
    if( speed > 0 ) dir = 0 ;
     dd8:	10 92 77 38 	sts	0x3877, r1	; 0x803877 <pwm+0x15>
     ddc:	9e cf       	rjmp	.-196    	; 0xd1a <followSpeed()+0x36>
_Z11followSpeedv():
     dde:	a0 e0       	ldi	r26, 0x00	; 0
     de0:	c9 cf       	rjmp	.-110    	; 0xd74 <followSpeed()+0x90>

00000de2 <digitalWrite>:
digitalWrite():
     de2:	cf 93       	push	r28
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:112

    speed = abs( speed ) ;
    if( speed > 0 ) speed = map( speed, 0, 100, minSpeed, maxSpeed ) ; // if speed is not 0, map speed accoring to min and max settings.

    newDutyCycle = constrain( speed, 0, 100 ) ; // speed limit = 0 - 100
     de4:	df 93       	push	r29
check_valid_digital_pin():
     de6:	28 2f       	mov	r18, r24
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:240
    default:
      break;
  }
}

void digitalWrite(uint8_t pin, uint8_t val) {
     de8:	30 e0       	ldi	r19, 0x00	; 0
digitalWrite():
     dea:	e9 01       	movw	r28, r18
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/Arduino.h:814
#if !defined(NUM_TOTAL_PINS)
  #define NUM_TOTAL_PINS                (NUM_DIGITAL_PINS) /* Used the same way as NUM_DIGITAL_PINS. so it doesn't mean what it's named  - I didn't make the convention*/
#endif

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin)) {
     dec:	c6 58       	subi	r28, 0x86	; 134
     dee:	d2 46       	sbci	r29, 0x62	; 98
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:243
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     df0:	88 81       	ld	r24, Y
     df2:	8f 3f       	cpi	r24, 0xFF	; 255
     df4:	09 f4       	brne	.+2      	; 0xdf8 <digitalWrite+0x16>
     df6:	3f c0       	rjmp	.+126    	; 0xe76 <digitalWrite+0x94>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:244
  if (bit_mask == NOT_A_PIN) {
     df8:	a9 01       	movw	r20, r18
     dfa:	48 59       	subi	r20, 0x98	; 152
     dfc:	52 46       	sbci	r21, 0x62	; 98
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:249
    return;
  }

  /* Get port */
  PORT_t *port = digitalPinToPortStruct(pin);
     dfe:	da 01       	movw	r26, r20
     e00:	ec 91       	ld	r30, X
     e02:	b0 e2       	ldi	r27, 0x20	; 32
     e04:	eb 9f       	mul	r30, r27
     e06:	f0 01       	movw	r30, r0
     e08:	11 24       	eor	r1, r1
     e0a:	fc 5f       	subi	r31, 0xFC	; 252
     e0c:	61 11       	cpse	r22, r1
     e0e:	36 c0       	rjmp	.+108    	; 0xe7c <digitalWrite+0x9a>
     e10:	86 83       	std	Z+6, r24	; 0x06
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:257
  the behavior of digitalWrite() on classic AVR devices, where
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
     e12:	90 81       	ld	r25, Z
     e14:	89 23       	and	r24, r25
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:258
    port->OUTCLR = bit_mask;
     e16:	a1 f4       	brne	.+40     	; 0xe40 <digitalWrite+0x5e>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:282
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
     e18:	c9 01       	movw	r24, r18
     e1a:	8a 5a       	subi	r24, 0xAA	; 170
     e1c:	92 46       	sbci	r25, 0x62	; 98
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:289
      pull up is enabled if this function is called.
      Should we purposely implement this side effect?
    */

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
     e1e:	dc 01       	movw	r26, r24
     e20:	9c 91       	ld	r25, X
     e22:	30 97       	sbiw	r30, 0x00	; 0
     e24:	69 f1       	breq	.+90     	; 0xe80 <digitalWrite+0x9e>
     e26:	98 30       	cpi	r25, 0x08	; 8
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:292

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     e28:	58 f5       	brcc	.+86     	; 0xe80 <digitalWrite+0x9e>
     e2a:	70 96       	adiw	r30, 0x10	; 16
     e2c:	e9 0f       	add	r30, r25
     e2e:	f1 1d       	adc	r31, r1
     e30:	9f b7       	in	r25, 0x3f	; 63
     e32:	f8 94       	cli
     e34:	80 81       	ld	r24, Z
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:295

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
     e36:	61 11       	cpse	r22, r1
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:296
    cli();
     e38:	26 c0       	rjmp	.+76     	; 0xe86 <digitalWrite+0xa4>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:300

    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     e3a:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:298

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
    cli();

    if (val == LOW) {
     e3c:	80 83       	st	Z, r24
     e3e:	9f bf       	out	0x3f, r25	; 63
turnOffPWM():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:300
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
     e40:	2c 5b       	subi	r18, 0xBC	; 188
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:303
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     e42:	32 46       	sbci	r19, 0x62	; 98
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:307
    }

    /* Restore system status */
    SREG = status;
     e44:	f9 01       	movw	r30, r18
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:107
   * any timers with minimum overhead - critical on these parts
   * Since nothing that will show up here can have more than one
   * one bit set, binary and will give 0x00 if that bit is cleared
   * which is NOT_ON_TIMER.
   */
  uint8_t digital_pin_timer =  digitalPinToTimer(pin) & __PeripheralControl;
     e46:	90 81       	ld	r25, Z
     e48:	99 23       	and	r25, r25
     e4a:	a9 f0       	breq	.+42     	; 0xe76 <digitalWrite+0x94>
     e4c:	88 81       	ld	r24, Y
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:109
  /* end megaTinyCore-specific section */
  if (digital_pin_timer== NOT_ON_TIMER) {
     e4e:	90 34       	cpi	r25, 0x40	; 64
     e50:	09 f1       	breq	.+66     	; 0xe94 <digitalWrite+0xb2>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:113
    return;
  }

  uint8_t bit_mask = digitalPinToBitMask(pin);
     e52:	90 38       	cpi	r25, 0x80	; 128
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:116
  // TCB_t *timerB;

  switch (digital_pin_timer) {
     e54:	e1 f0       	breq	.+56     	; 0xe8e <digitalWrite+0xac>
     e56:	90 31       	cpi	r25, 0x10	; 16
     e58:	71 f4       	brne	.+28     	; 0xe76 <digitalWrite+0x94>
     e5a:	da 01       	movw	r26, r20
     e5c:	9c 91       	ld	r25, X
     e5e:	91 30       	cpi	r25, 0x01	; 1
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:132
          }
          if (bit_mask > 0x04) {  // -> bit_pos > 2 -> output channel controlled by HCMP
            bit_mask <<= 1;       // mind the gap (between LCMP and HCMP)
          }
        #else
          if (digitalPinToPort(pin) == PB) {        // WO0-WO2, Bitmask has one of these bits 1: 0b00hhhlll.
     e60:	a1 f4       	brne	.+40     	; 0xe8a <digitalWrite+0xa8>
     e62:	85 30       	cpi	r24, 0x05	; 5
     e64:	10 f0       	brcs	.+4      	; 0xe6a <digitalWrite+0x88>
     e66:	88 0f       	add	r24, r24
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:133
            if (bit_mask > 0x04) { // Is it one of the three high ones? If so
     e68:	82 95       	swap	r24
     e6a:	90 91 01 0a 	lds	r25, 0x0A01	; 0x800a01 <digital_pin_to_bit_mask+0x7f6c87>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:135
              bit_mask <<= 1;      // nudge it 1 place left swap nybbles since that's 1 clock faster than 3 rightshifts.
              _SWAP(bit_mask);     // swap nybbles since that's 1 clock faster than 3 rightshifts.
     e6e:	80 95       	com	r24
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:142
          } else {
            // Otherwise, it's WO3-5. These will always be on 0b00hhh000,. Here since we ARE working with a high half timer, we need to just leftshift it once.
            bit_mask <<= 1;
          }
        #endif
        TCA0.SPLIT.CTRLB &= ~bit_mask;
     e70:	89 23       	and	r24, r25
     e72:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <digital_pin_to_bit_mask+0x7f6c87>
digitalWrite():
     e76:	df 91       	pop	r29
     e78:	cf 91       	pop	r28
     e7a:	08 95       	ret
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:320
   * analogWritten() 255, then digitallyWritten() to HIGH, which
   * would turn it off for the time between turnOffPWM() and
   * PORT->OUTCLR)
   * Since there's no penalty, why make a glitch we don't have to? */
  turnOffPWM(pin);
}
     e7c:	85 83       	std	Z+5, r24	; 0x05
     e7e:	c9 cf       	rjmp	.-110    	; 0xe12 <digitalWrite+0x30>
     e80:	f0 e0       	ldi	r31, 0x00	; 0
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:278
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
     e82:	e0 e0       	ldi	r30, 0x00	; 0
     e84:	d5 cf       	rjmp	.-86     	; 0xe30 <digitalWrite+0x4e>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:292

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
     e86:	88 60       	ori	r24, 0x08	; 8
     e88:	d9 cf       	rjmp	.-78     	; 0xe3c <digitalWrite+0x5a>
turnOffPWM():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:303
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
     e8a:	88 0f       	add	r24, r24
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:139
              bit_mask <<= 1;      // nudge it 1 place left swap nybbles since that's 1 clock faster than 3 rightshifts.
              _SWAP(bit_mask);     // swap nybbles since that's 1 clock faster than 3 rightshifts.
            }
          } else {
            // Otherwise, it's WO3-5. These will always be on 0b00hhh000,. Here since we ARE working with a high half timer, we need to just leftshift it once.
            bit_mask <<= 1;
     e8c:	ee cf       	rjmp	.-36     	; 0xe6a <digitalWrite+0x88>
     e8e:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <digital_pin_to_bit_mask+0x7f6926>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:157
    /* We don't need the type b timers as this core does not use them for PWM      */

    // 1-series parts have a DAC that we can use...
    #if defined(DAC0)
      case DACOUT:
        DAC0.CTRLA = 0x00;
     e92:	f1 cf       	rjmp	.-30     	; 0xe76 <digitalWrite+0x94>
digitalWrite():
     e94:	20 e4       	ldi	r18, 0x40	; 64
turnOffPWM():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:194
            #endif

            SREG = oldSREG;
          }
        #else
          uint8_t fc_mask = (bit_mask == 0x02 ? 0x80 : 0x40);
     e96:	82 30       	cpi	r24, 0x02	; 2
     e98:	09 f4       	brne	.+2      	; 0xe9c <digitalWrite+0xba>
digitalWrite():
     e9a:	20 e8       	ldi	r18, 0x80	; 128
turnOffPWM():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:195
          if (TCD0.FAULTCTRL & fc_mask) {
     e9c:	90 91 92 0a 	lds	r25, 0x0A92	; 0x800a92 <digital_pin_to_bit_mask+0x7f6d18>
     ea0:	92 23       	and	r25, r18
     ea2:	49 f3       	breq	.-46     	; 0xe76 <digitalWrite+0x94>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:196
            uint8_t oldSREG = SREG;
     ea4:	6f b7       	in	r22, 0x3f	; 63
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:197
            cli();
     ea6:	f8 94       	cli
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:200
            // uint8_t TCD0_prescaler=TCD0.CTRLA&(~TCD_ENABLE_bm);
            //
            TCD0.CTRLA &= ~TCD_ENABLE_bm;
     ea8:	90 91 80 0a 	lds	r25, 0x0A80	; 0x800a80 <digital_pin_to_bit_mask+0x7f6d06>
     eac:	9e 7f       	andi	r25, 0xFE	; 254
     eae:	90 93 80 0a 	sts	0x0A80, r25	; 0x800a80 <digital_pin_to_bit_mask+0x7f6d06>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:201
            _PROTECTED_WRITE(TCD0.FAULTCTRL, TCD0.FAULTCTRL & (~fc_mask));
     eb2:	40 91 92 0a 	lds	r20, 0x0A92	; 0x800a92 <digital_pin_to_bit_mask+0x7f6d18>
     eb6:	30 e0       	ldi	r19, 0x00	; 0
     eb8:	20 95       	com	r18
     eba:	30 95       	com	r19
     ebc:	50 e0       	ldi	r21, 0x00	; 0
     ebe:	24 23       	and	r18, r20
     ec0:	35 23       	and	r19, r21
     ec2:	98 ed       	ldi	r25, 0xD8	; 216
     ec4:	94 bf       	out	0x34, r25	; 52
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:202
            while (!(TCD0.STATUS & TCD_ENRDY_bm)); // wait until it can be re-enabled
     ec6:	20 93 92 0a 	sts	0x0A92, r18	; 0x800a92 <digital_pin_to_bit_mask+0x7f6d18>
     eca:	90 91 8e 0a 	lds	r25, 0x0A8E	; 0x800a8e <digital_pin_to_bit_mask+0x7f6d14>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:203
            TCD0.CTRLA |= TCD_ENABLE_bm;           // re-enable it
     ece:	90 ff       	sbrs	r25, 0
     ed0:	fc cf       	rjmp	.-8      	; 0xeca <digitalWrite+0xe8>
     ed2:	90 91 80 0a 	lds	r25, 0x0A80	; 0x800a80 <digital_pin_to_bit_mask+0x7f6d06>
     ed6:	91 60       	ori	r25, 0x01	; 1
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:220
                  PORTA.PIN6CTRL &= ~(PORT_INVEN_bm);
                } else {
                  PORTA.PIN7CTRL &= ~(PORT_INVEN_bm);
                }
              #else
                if (bit_mask == 0x01) {
     ed8:	90 93 80 0a 	sts	0x0A80, r25	; 0x800a80 <digital_pin_to_bit_mask+0x7f6d06>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:221
                  PORTC.PIN0CTRL &= ~(PORT_INVEN_bm);
     edc:	81 30       	cpi	r24, 0x01	; 1
     ede:	39 f4       	brne	.+14     	; 0xeee <digitalWrite+0x10c>
     ee0:	80 91 50 04 	lds	r24, 0x0450	; 0x800450 <digital_pin_to_bit_mask+0x7f66d6>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:227
                } else {
                  PORTC.PIN1CTRL &= ~(PORT_INVEN_bm);
                }
              #endif
            #endif
            SREG = oldSREG;
     ee4:	8f 77       	andi	r24, 0x7F	; 127
     ee6:	80 93 50 04 	sts	0x0450, r24	; 0x800450 <digital_pin_to_bit_mask+0x7f66d6>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:223
                }
              #else
                if (bit_mask == 0x01) {
                  PORTC.PIN0CTRL &= ~(PORT_INVEN_bm);
                } else {
                  PORTC.PIN1CTRL &= ~(PORT_INVEN_bm);
     eea:	6f bf       	out	0x3f, r22	; 63
     eec:	c4 cf       	rjmp	.-120    	; 0xe76 <digitalWrite+0x94>
     eee:	80 91 51 04 	lds	r24, 0x0451	; 0x800451 <digital_pin_to_bit_mask+0x7f66d7>
     ef2:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:294
    if( num == A.Fx ) A.state = state ;
    if( num == B.Fx ) B.state = state ;
}

void notifyCVAck()
{
     ef4:	80 93 51 04 	sts	0x0451, r24	; 0x800451 <digital_pin_to_bit_mask+0x7f66d7>
     ef8:	f8 cf       	rjmp	.-16     	; 0xeea <digitalWrite+0x108>

00000efa <notifyCVAck>:
notifyCVAck():
     efa:	cf 92       	push	r12
     efc:	df 92       	push	r13
     efe:	ef 92       	push	r14
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:295
    digitalWrite(1,  LOW ) ;
     f00:	ff 92       	push	r15
     f02:	cf 93       	push	r28
     f04:	df 93       	push	r29
     f06:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:296
    digitalWrite(2, HIGH ) ;
     f08:	81 e0       	ldi	r24, 0x01	; 1
     f0a:	6b df       	rcall	.-298    	; 0xde2 <digitalWrite>
     f0c:	61 e0       	ldi	r22, 0x01	; 1
     f0e:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:975
      }
    }
  }
#elif (PROGMEM_SIZE >= 16384 && !defined(MILLIS_USE_TIMERRTC))
  void delay(uint32_t ms) { /* Interrupts will not prolong this less flash-efficient delay */
    uint16_t start = (uint16_t) micros();
     f10:	68 df       	rcall	.-304    	; 0xde2 <digitalWrite>
delay():
     f12:	31 d9       	rcall	.-3486   	; 0x176 <micros>
     f14:	eb 01       	movw	r28, r22
     f16:	86 e0       	ldi	r24, 0x06	; 6
     f18:	c8 2e       	mov	r12, r24
     f1a:	d1 2c       	mov	r13, r1
     f1c:	e1 2c       	mov	r14, r1
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:977
    while (ms > 0) {
      while (((uint16_t) micros() - start) >= 1000 && ms) {
     f1e:	f1 2c       	mov	r15, r1
     f20:	2a d9       	rcall	.-3500   	; 0x176 <micros>
     f22:	6c 1b       	sub	r22, r28
     f24:	7d 0b       	sbc	r23, r29
     f26:	68 3e       	cpi	r22, 0xE8	; 232
     f28:	73 40       	sbci	r23, 0x03	; 3
     f2a:	b8 f0       	brcs	.+46     	; 0xf5a <notifyCVAck+0x60>
     f2c:	c1 14       	cp	r12, r1
     f2e:	d1 04       	cpc	r13, r1
     f30:	e1 04       	cpc	r14, r1
     f32:	f1 04       	cpc	r15, r1
     f34:	51 f4       	brne	.+20     	; 0xf4a <notifyCVAck+0x50>
notifyCVAck():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:298
    delay(6);
    digitalWrite(2,  LOW ) ;
     f36:	60 e0       	ldi	r22, 0x00	; 0
     f38:	82 e0       	ldi	r24, 0x02	; 2
     f3a:	53 df       	rcall	.-346    	; 0xde2 <digitalWrite>
     f3c:	df 91       	pop	r29
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:301

    loadCV() ; // after a write, reload CV.
}
     f3e:	cf 91       	pop	r28
     f40:	ff 90       	pop	r15
     f42:	ef 90       	pop	r14
     f44:	df 90       	pop	r13
     f46:	cf 90       	pop	r12
     f48:	a5 cc       	rjmp	.-1718   	; 0x894 <loadCV()>
delay():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:300
    digitalWrite(1,  LOW ) ;
    digitalWrite(2, HIGH ) ;
    delay(6);
    digitalWrite(2,  LOW ) ;

    loadCV() ; // after a write, reload CV.
     f4a:	81 e0       	ldi	r24, 0x01	; 1
     f4c:	c8 1a       	sub	r12, r24
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:978
        ms-- ;
     f4e:	d1 08       	sbc	r13, r1
     f50:	e1 08       	sbc	r14, r1
     f52:	f1 08       	sbc	r15, r1
     f54:	c8 51       	subi	r28, 0x18	; 24
     f56:	dc 4f       	sbci	r29, 0xFC	; 252
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:979
        start += 1000;
     f58:	e3 cf       	rjmp	.-58     	; 0xf20 <notifyCVAck+0x26>
     f5a:	c1 14       	cp	r12, r1
     f5c:	d1 04       	cpc	r13, r1
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:976
    }
  }
#elif (PROGMEM_SIZE >= 16384 && !defined(MILLIS_USE_TIMERRTC))
  void delay(uint32_t ms) { /* Interrupts will not prolong this less flash-efficient delay */
    uint16_t start = (uint16_t) micros();
    while (ms > 0) {
     f5e:	e1 04       	cpc	r14, r1
     f60:	f1 04       	cpc	r15, r1
     f62:	f1 f6       	brne	.-68     	; 0xf20 <notifyCVAck+0x26>
     f64:	e8 cf       	rjmp	.-48     	; 0xf36 <notifyCVAck+0x3c>

00000f66 <ackCV()>:
_Z5ackCVv():
     f66:	c9 cf       	rjmp	.-110    	; 0xefa <notifyCVAck>

00000f68 <pinMode.constprop.10>:
pinMode.constprop.10():
     f68:	82 31       	cpi	r24, 0x12	; 18
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:782
void ackCV (void)
{
    if (notifyCVAck)
    {
        DB_PRINT ("ackCV: Send Basic ACK");
        notifyCVAck() ;
     f6a:	d0 f4       	brcc	.+52     	; 0xfa0 <pinMode.constprop.10+0x38>
check_valid_digital_pin():
     f6c:	90 e0       	ldi	r25, 0x00	; 0
pinMode.constprop.10():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:44
}

void pinMode(uint8_t pin, uint8_t mode) {
  check_valid_digital_pin(pin);         /* generate compile error if a constant that is not a valid pin is used as the pin */
  check_valid_pin_mode(mode);           /* generate compile error if a constant that is not a valid pin mode is used as the mode */
  uint8_t bit_mask = digitalPinToBitMask(pin);
     f6e:	fc 01       	movw	r30, r24
     f70:	e6 58       	subi	r30, 0x86	; 134
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/Arduino.h:814
     f72:	f2 46       	sbci	r31, 0x62	; 98
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:44
     f74:	20 81       	ld	r18, Z
     f76:	2f 3f       	cpi	r18, 0xFF	; 255
     f78:	99 f0       	breq	.+38     	; 0xfa0 <pinMode.constprop.10+0x38>
     f7a:	fc 01       	movw	r30, r24
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:45
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     f7c:	e8 59       	subi	r30, 0x98	; 152
     f7e:	f2 46       	sbci	r31, 0x62	; 98
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:48
    return;                             /* ignore invalid pins passed at runtime */
  }
  volatile uint8_t * port_base = (volatile uint8_t *) (uint16_t) ((&PORTA) + digitalPinToPort(pin));
     f80:	e0 81       	ld	r30, Z
     f82:	30 e2       	ldi	r19, 0x20	; 32
     f84:	e3 9f       	mul	r30, r19
     f86:	f0 01       	movw	r30, r0
     f88:	11 24       	eor	r1, r1
     f8a:	fc 5f       	subi	r31, 0xFC	; 252
     f8c:	21 83       	std	Z+1, r18	; 0x01
     f8e:	8a 5a       	subi	r24, 0xAA	; 170
     f90:	92 46       	sbci	r25, 0x62	; 98
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:51
  if (mode & 0x01) {
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
     f92:	dc 01       	movw	r26, r24
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:77
  // then load with displacement 2 clocks. IFF the compiler puts this pointer into Y or Z, it is faster and smaller
  // by 2 bytes and one clock. And let's hope it is, because the code above would suck too if it was in X.
  // Handwritten assembly that exploited the knowledge that there will never be a carry would save 1 word and 1 clock.
  // and could probably save at least several times that in initializing the port_base pointer. But if you're using
  // pinMode you probably don't care.
  port_base += (uint8_t) digitalPinToBitPosition(pin);
     f94:	8c 91       	ld	r24, X
     f96:	e8 0f       	add	r30, r24
     f98:	f1 1d       	adc	r31, r1
     f9a:	80 89       	ldd	r24, Z+16	; 0x10
     f9c:	87 7f       	andi	r24, 0xF7	; 247
     f9e:	80 8b       	std	Z+16, r24	; 0x10
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:78
  bit_mask = *(port_base + 0x10);
     fa0:	08 95       	ret

00000fa2 <clearDccProcState(unsigned char)>:
_Z17clearDccProcStateh():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:82
  if (mode & 2) {
    bit_mask |= 0x08;
  } else {
    bit_mask &= 0xF7;
     fa2:	ec da       	rcall	.-2600   	; 0x57c <resetServiceModeTimer(unsigned char)>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring_digital.c:85
  }
  *(port_base + 0x10) = bit_mask;
}
     fa4:	ed ea       	ldi	r30, 0xAD	; 173
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1239
}

/////////////////////////////////////////////////////////////////////////
void clearDccProcState (uint8_t inServiceMode)
{
    resetServiceModeTimer (inServiceMode) ;
     fa6:	f8 e3       	ldi	r31, 0x38	; 56
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1242

    // Set the Page Register to it's default of 1 only on the first Reset
    DccProcState.PageRegister = 1 ;
     fa8:	81 e0       	ldi	r24, 0x01	; 1
     faa:	87 83       	std	Z+7, r24	; 0x07
     fac:	10 86       	std	Z+8, r1	; 0x08
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1245

    // Clear the LastMsg buffer and DuplicateCount in preparation for possible CV programming
    DccProcState.DuplicateCount = 0 ;
     fae:	e6 eb       	ldi	r30, 0xB6	; 182
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1246
    memset (&DccProcState.LastMsg, 0, sizeof (DCC_MSG)) ;
     fb0:	f8 e3       	ldi	r31, 0x38	; 56
     fb2:	88 e0       	ldi	r24, 0x08	; 8
     fb4:	df 01       	movw	r26, r30
     fb6:	1d 92       	st	X+, r1
     fb8:	8a 95       	dec	r24
     fba:	e9 f7       	brne	.-6      	; 0xfb6 <clearDccProcState(unsigned char)+0x14>
     fbc:	08 95       	ret

00000fbe <__vector_15>:
__vector_15():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1247
}
     fbe:	ef 93       	push	r30
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:200
      }
      RTC.INTFLAGS = RTC_OVF_bm | RTC_CMP_bm; // clear flag
    }
  #else
    ISR(MILLIS_TIMER_VECTOR, ISR_NAKED) {
      __asm__ __volatile__(
     fc0:	ff 93       	push	r31
     fc2:	ef e2       	ldi	r30, 0x2F	; 47
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:294
          #endif
          _timer->INTFLAGS = TCB_CAPT_bm;   // reset Interrupt flag of TCBx
        }
      */
    #else // TCA0 or TCD0, also naked
      __asm__ __volatile__(
     fc4:	f8 e3       	ldi	r31, 0x38	; 56
     fc6:	8f 93       	push	r24
     fc8:	8f b7       	in	r24, 0x3f	; 63
     fca:	8f 93       	push	r24
     fcc:	9f 93       	push	r25
     fce:	7f 93       	push	r23
     fd0:	70 e0       	ldi	r23, 0x00	; 0
     fd2:	80 81       	ld	r24, Z
     fd4:	91 81       	ldd	r25, Z+1	; 0x01
     fd6:	80 5d       	subi	r24, 0xD0	; 208
     fd8:	9c 4f       	sbci	r25, 0xFC	; 252
     fda:	80 83       	st	Z, r24
     fdc:	91 83       	std	Z+1, r25	; 0x01
     fde:	88 5e       	subi	r24, 0xE8	; 232
     fe0:	93 40       	sbci	r25, 0x03	; 3
     fe2:	18 f0       	brcs	.+6      	; 0xfea <lower>
     fe4:	80 83       	st	Z, r24
     fe6:	91 83       	std	Z+1, r25	; 0x01
     fe8:	7f 5f       	subi	r23, 0xFF	; 255

00000fea <lower>:
     fea:	92 81       	ldd	r25, Z+2	; 0x02
     fec:	97 0f       	add	r25, r23
     fee:	92 83       	std	Z+2, r25	; 0x02
     ff0:	80 e0       	ldi	r24, 0x00	; 0
     ff2:	93 81       	ldd	r25, Z+3	; 0x03
     ff4:	98 1f       	adc	r25, r24
     ff6:	93 83       	std	Z+3, r25	; 0x03
     ff8:	94 81       	ldd	r25, Z+4	; 0x04
     ffa:	98 1f       	adc	r25, r24
     ffc:	94 83       	std	Z+4, r25	; 0x04
     ffe:	95 81       	ldd	r25, Z+5	; 0x05
    1000:	98 1f       	adc	r25, r24
    1002:	95 83       	std	Z+5, r25	; 0x05
    1004:	96 81       	ldd	r25, Z+6	; 0x06
    1006:	9f 5f       	subi	r25, 0xFF	; 255
    1008:	96 83       	std	Z+6, r25	; 0x06
    100a:	97 81       	ldd	r25, Z+7	; 0x07
    100c:	9f 4f       	sbci	r25, 0xFF	; 255
    100e:	97 83       	std	Z+7, r25	; 0x07
    1010:	90 85       	ldd	r25, Z+8	; 0x08
    1012:	9f 4f       	sbci	r25, 0xFF	; 255
    1014:	90 87       	std	Z+8, r25	; 0x08
    1016:	91 85       	ldd	r25, Z+9	; 0x09
    1018:	9f 4f       	sbci	r25, 0xFF	; 255
    101a:	91 87       	std	Z+9, r25	; 0x09
    101c:	81 e0       	ldi	r24, 0x01	; 1
    101e:	80 93 8d 0a 	sts	0x0A8D, r24	; 0x800a8d <digital_pin_to_bit_mask+0x7f6d13>
    1022:	7f 91       	pop	r23
    1024:	9f 91       	pop	r25
    1026:	8f 91       	pop	r24
    1028:	8f bf       	out	0x3f, r24	; 63
    102a:	8f 91       	pop	r24
    102c:	ff 91       	pop	r31
    102e:	ef 91       	pop	r30
    1030:	18 95       	reti

00001032 <__vector_5>:
__vector_5():
    1032:	0f 93       	push	r16
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:356
      __builtin_unreachable();
    }
    #endif
    #ifdef PORTC_PINS
      ISR(PORTC_PORT_vect, ISR_NAKED) {
      asm volatile(
    1034:	04 e0       	ldi	r16, 0x04	; 4
    1036:	06 c0       	rjmp	.+12     	; 0x1044 <isrBody>

00001038 <__vector_4>:
__vector_4():
    1038:	0f 93       	push	r16
    103a:	02 e0       	ldi	r16, 0x02	; 2
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:342
      ::);
    __builtin_unreachable();
    }
    #ifdef PORTB_PINS
      ISR(PORTB_PORT_vect, ISR_NAKED) {
      asm volatile(
    103c:	03 c0       	rjmp	.+6      	; 0x1044 <isrBody>

0000103e <__vector_3>:
__vector_3():
    103e:	0f 93       	push	r16
    1040:	00 e0       	ldi	r16, 0x00	; 0
    1042:	00 c0       	rjmp	.+0      	; 0x1044 <isrBody>

00001044 <isrBody>:
isrBody():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:329
 * then it's just a matter of making sure we pop everything we pushed onto the stack in the reverse order, including r16 followed by the reti to exit the interrupt..
*/

  #if defined(CORE_ATTACH_ALL)
    ISR(PORTA_PORT_vect, ISR_NAKED) {
    asm volatile(
    1044:	0f 92       	push	r0
    1046:	0f b6       	in	r0, 0x3f	; 63
    1048:	0f 92       	push	r0
    104a:	1f 92       	push	r1
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:114
      SREG = oldSREG;
    }
  }
#if !defined(CORE_ATTACH_EARLYCLEAR)
  void __attribute__((naked)) __attribute__((used)) __attribute__((noreturn)) isrBody() {
    asm volatile (
    104c:	11 24       	eor	r1, r1
    104e:	ff 92       	push	r15
    1050:	1f 93       	push	r17
    1052:	2f 93       	push	r18
    1054:	3f 93       	push	r19
    1056:	4f 93       	push	r20
    1058:	5f 93       	push	r21
    105a:	6f 93       	push	r22
    105c:	7f 93       	push	r23
    105e:	8f 93       	push	r24
    1060:	9f 93       	push	r25
    1062:	af 93       	push	r26
    1064:	bf 93       	push	r27
    1066:	cf 93       	push	r28
    1068:	df 93       	push	r29
    106a:	ef 93       	push	r30
    106c:	ff 93       	push	r31
    106e:	a0 e0       	ldi	r26, 0x00	; 0
    1070:	b8 e3       	ldi	r27, 0x38	; 56
    1072:	a0 0f       	add	r26, r16
    1074:	b1 1d       	adc	r27, r1
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/WInterrupts.c:142
      "push  r28"        "\n\t" // Not call used, but we use it.
      "push  r29"        "\n\t" // same thing.
      "push  r30"        "\n\t"
      "push  r31"        "\n\t"
      ::);
    asm volatile (  // This gets us the address of intFunc in Y pointer reg.
    1076:	cd 91       	ld	r28, X+
    1078:	dc 91       	ld	r29, X
    107a:	00 0f       	add	r16, r16
    107c:	0d 5f       	subi	r16, 0xFD	; 253
    107e:	a0 2f       	mov	r26, r16
    1080:	b0 e0       	ldi	r27, 0x00	; 0
    1082:	fc 90       	ld	r15, X
    1084:	10 97       	sbiw	r26, 0x00	; 0
    1086:	61 f0       	breq	.+24     	; 0x10a0 <AIntEnd>
    1088:	1f 2d       	mov	r17, r15

0000108a <AIntLoop>:
    108a:	16 95       	lsr	r17
    108c:	18 f0       	brcs	.+6      	; 0x1094 <AIntLoop+0xa>
    108e:	41 f0       	breq	.+16     	; 0x10a0 <AIntEnd>
    1090:	22 96       	adiw	r28, 0x02	; 2
    1092:	fb cf       	rjmp	.-10     	; 0x108a <AIntLoop>
    1094:	e9 91       	ld	r30, Y+
    1096:	f9 91       	ld	r31, Y+
    1098:	30 97       	sbiw	r30, 0x00	; 0
    109a:	b9 f3       	breq	.-18     	; 0x108a <AIntLoop>
    109c:	09 95       	icall
    109e:	f5 cf       	rjmp	.-22     	; 0x108a <AIntLoop>

000010a0 <AIntEnd>:
    10a0:	a0 2f       	mov	r26, r16
    10a2:	b0 e0       	ldi	r27, 0x00	; 0
    10a4:	fc 92       	st	X, r15
    10a6:	ff 91       	pop	r31
    10a8:	ef 91       	pop	r30
    10aa:	df 91       	pop	r29
    10ac:	cf 91       	pop	r28
    10ae:	bf 91       	pop	r27
    10b0:	af 91       	pop	r26
    10b2:	9f 91       	pop	r25
    10b4:	8f 91       	pop	r24
    10b6:	7f 91       	pop	r23
    10b8:	6f 91       	pop	r22
    10ba:	5f 91       	pop	r21
    10bc:	4f 91       	pop	r20
    10be:	3f 91       	pop	r19
    10c0:	2f 91       	pop	r18
    10c2:	1f 91       	pop	r17
    10c4:	ff 90       	pop	r15
    10c6:	1f 90       	pop	r1
    10c8:	0f 90       	pop	r0
    10ca:	0f be       	out	0x3f, r0	; 63
    10cc:	0f 90       	pop	r0
    10ce:	0f 91       	pop	r16
    10d0:	18 95       	reti

000010d2 <main>:
main():
    10d2:	cf 93       	push	r28
    10d4:	df 93       	push	r29
    10d6:	00 d0       	rcall	.+0      	; 0x10d8 <main+0x6>
    10d8:	00 d0       	rcall	.+0      	; 0x10da <main+0x8>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/main.cpp:49
 * called first in non-optiboot configurations (neither is needed on Optibooot configurations() *
 * an extra bit of initialization code in .init3 to fix the vectors and still happen if user    *
 * overrides main. In the past there was a USB-related function here, that is removed, as work  *
 * will be needed in any event at the core level if VUSB-based "stuff" arrives, but really I'm  *
 * just waiting for the DU-series now                                                           */
int main() {
    10da:	cd b7       	in	r28, 0x3d	; 61
    10dc:	de b7       	in	r29, 0x3e	; 62
init_clock():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1549
    #if (defined(CLOCK_TUNE_INTERNAL))
      tune_internal(); // Will be inlined as only called once. Just too long and ugly to put two implementations in middle of this.
    #else
      #if (F_CPU == 20000000)
        /* No division on clock */
        _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
    10de:	88 ed       	ldi	r24, 0xD8	; 216
    10e0:	90 e0       	ldi	r25, 0x00	; 0
    10e2:	84 bf       	out	0x34, r24	; 52
    10e4:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <digital_pin_to_bit_mask+0x7f62e7>
init_ADC0():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1664


/********************************* ADC ****************************************/
void __attribute__((weak)) init_ADC0() {
  ADC_t* pADC;
  _fastPtr_d(pADC, &ADC0);
    10e8:	e0 e0       	ldi	r30, 0x00	; 0
    10ea:	f6 e0       	ldi	r31, 0x06	; 6
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1685
   **************************************************************************/
    //                              30 MHz / 32 = 937 kHz,  32 MHz / 32 =  1 MHz.
    #if   F_CPU   > 24000000     // 24 MHz / 16 = 1.5 MHz,  25 MHz / 32 =  780 kHz
      pADC->CTRLC  = ADC_PRESC_DIV32_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #elif F_CPU  >= 12000000    // 16 MHz / 16 = 1.0 MHz,  20 MHz / 16 = 1.25 MHz
      pADC->CTRLC  = ADC_PRESC_DIV16_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    10ec:	83 e5       	ldi	r24, 0x53	; 83
    10ee:	82 83       	std	Z+2, r24	; 0x02
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1696
      pADC->CTRLC  =  ADC_PRESC_DIV2_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #endif
    #if   (F_CPU == 6000000 || F_CPU == 12000000 || F_CPU == 24000000 || F_CPU ==25000000)
      pADC->SAMPCTRL = (7); // 9 ADC clocks, 12 us
    #elif (F_CPU == 5000000 || F_CPU == 10000000 || F_CPU == 20000000)
      pADC->SAMPCTRL = (13);   // 15 ADC clock,s 12 us
    10f0:	8d e0       	ldi	r24, 0x0D	; 13
    10f2:	85 83       	std	Z+5, r24	; 0x05
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1700
    #else
      pADC->SAMPCTRL = (10); // 12 ADC clocks, 12 us
    #endif
    pADC->CTRLD    = ADC_INITDLY_DLY16_gc;
    10f4:	80 e2       	ldi	r24, 0x20	; 32
    10f6:	83 83       	std	Z+3, r24	; 0x03
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1701
    pADC->CTRLA    = ADC_ENABLE_bm;
    10f8:	81 e0       	ldi	r24, 0x01	; 1
    10fa:	80 83       	st	Z, r24
init_TCA0():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1791

void __attribute__((weak)) init_TCA0() {
  /*  TYPE A TIMER   */
  #if !defined(TCA_BUFFERED_3PIN)
    #if defined(PORTMUX_CTRLC)
      PORTMUX.CTRLC = TCA_PORTMUX;
    10fc:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <digital_pin_to_bit_mask+0x7f6488>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1795
    #else
      PORTMUX.TCAROUTEA = TCA_PORTMUX;
    #endif
    TCA0.SPLIT.CTRLD   = TCA_SPLIT_SPLITM_bm;
    1100:	80 93 03 0a 	sts	0x0A03, r24	; 0x800a03 <digital_pin_to_bit_mask+0x7f6c89>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1796
    TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
    1104:	9e ef       	ldi	r25, 0xFE	; 254
    1106:	90 93 26 0a 	sts	0x0A26, r25	; 0x800a26 <digital_pin_to_bit_mask+0x7f6cac>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1797
    TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
    110a:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <digital_pin_to_bit_mask+0x7f6cad>
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1798
    TCA0.SPLIT.CTRLA   = (TIMERA_PRESCALER_bm | TCA_SPLIT_ENABLE_bm);
    110e:	9b e0       	ldi	r25, 0x0B	; 11
    1110:	90 93 00 0a 	sts	0x0A00, r25	; 0x800a00 <digital_pin_to_bit_mask+0x7f6c86>
init_millis():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1440
      #endif
    #elif defined(MILLIS_USE_TIMERA1)
      TCA1.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
    #elif defined(MILLIS_USE_TIMERD0)
      TCD_t* pTCD;
      _fastPtr_d(pTCD, &TCD0);
    1114:	e0 e8       	ldi	r30, 0x80	; 128
    1116:	fa e0       	ldi	r31, 0x0A	; 10
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1441
      pTCD->CMPBCLR        = TIME_TRACKING_TIMER_PERIOD; // essentially, this is TOP
    1118:	2d ef       	ldi	r18, 0xFD	; 253
    111a:	31 e0       	ldi	r19, 0x01	; 1
    111c:	26 a7       	std	Z+46, r18	; 0x2e
    111e:	37 a7       	std	Z+47, r19	; 0x2f
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1442
      pTCD->CTRLB          = 0x00; // oneramp mode
    1120:	11 82       	std	Z+1, r1	; 0x01
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1443
      pTCD->CTRLC          = 0x80;
    1122:	90 e8       	ldi	r25, 0x80	; 128
    1124:	92 83       	std	Z+2, r25	; 0x02
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1444
      pTCD->INTCTRL        = 0x01; // enable interrupt
    1126:	84 87       	std	Z+12, r24	; 0x0c
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1445
      pTCD->CTRLA          = TIMERD0_PRESCALER | 0x01; // set clock source and enable!
    1128:	81 e1       	ldi	r24, 0x11	; 17
    112a:	80 83       	st	Z, r24
init():
C:\Users\sknippels\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.8\cores\megatinycore/wiring.c:1530
    init_millis();
  #endif
  /*************************** ENABLE GLOBAL INTERRUPTS *************************/
  // Finally, after everything is initialized, we go ahead and enable interrupts.
  if (onAfterInit()) {
    sei();
    112c:	78 94       	sei
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1598
{
    #if defined(ESP8266) ||  defined(ESP32) || defined(ARDUINO_ARCH_RP2040)
    EEPROM.begin (MAXCV);
    #endif
    // Clear all the static member variables
    memset (&DccRx, 0, sizeof (DccRx));
    112e:	ef e3       	ldi	r30, 0x3F	; 63
    1130:	f8 e3       	ldi	r31, 0x38	; 56
    1132:	86 e1       	ldi	r24, 0x16	; 22
    1134:	df 01       	movw	r26, r30
    1136:	1d 92       	st	X+, r1
    1138:	8a 95       	dec	r24
    113a:	e9 f7       	brne	.-6      	; 0x1136 <main+0x64>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1604

    MODE_TP1; // only for debugging and timing measurement
    MODE_TP2;
    MODE_TP3;
    MODE_TP4;
    bitMax = MAX_ONEBITFULL;
    113c:	82 e9       	ldi	r24, 0x92	; 146
    113e:	90 e0       	ldi	r25, 0x00	; 0
    1140:	80 93 3d 38 	sts	0x383D, r24	; 0x80383d <bitMax>
    1144:	90 93 3e 38 	sts	0x383E, r25	; 0x80383e <bitMax+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1605
    bitMin = MIN_ONEBITFULL;
    1148:	82 e5       	ldi	r24, 0x52	; 82
    114a:	90 e0       	ldi	r25, 0x00	; 0
    114c:	80 93 3b 38 	sts	0x383B, r24	; 0x80383b <bitMin>
    1150:	90 93 3c 38 	sts	0x383C, r25	; 0x80383c <bitMin+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1607

    DccProcState.Flags = Flags ;
    1154:	10 92 ad 38 	sts	0x38AD, r1	; 0x8038ad <DccProcState>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1608
    DccProcState.OpsModeAddressBaseCV = OpsModeAddressBaseCV ;
    1158:	10 92 ae 38 	sts	0x38AE, r1	; 0x8038ae <DccProcState+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1609
    DccProcState.myDccAddress = -1;
    115c:	8f ef       	ldi	r24, 0xFF	; 255
    115e:	9f ef       	ldi	r25, 0xFF	; 255
    1160:	80 93 c3 38 	sts	0x38C3, r24	; 0x8038c3 <DccProcState+0x16>
    1164:	90 93 c4 38 	sts	0x38C4, r25	; 0x8038c4 <DccProcState+0x17>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1610
    DccProcState.inAccDecDCCAddrNextReceivedMode = 0;
    1168:	10 92 c5 38 	sts	0x38C5, r1	; 0x8038c5 <DccProcState+0x18>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1612

    ISREdge = RISING;
    116c:	83 e0       	ldi	r24, 0x03	; 3
    116e:	80 93 3a 38 	sts	0x383A, r24	; 0x80383a <ISREdge>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1614
    // level checking to detect false IRQ's fired by glitches
    ISRLevel = DccProcState.ExtIntMask;
    1172:	80 91 c2 38 	lds	r24, 0x38C2	; 0x8038c2 <DccProcState+0x15>
    1176:	80 93 39 38 	sts	0x3839, r24	; 0x803839 <ISRLevel>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1621

    #ifdef ESP32
    ISRWatch = ISREdge;
    attachInterrupt (DccProcState.ExtIntNum, ExternalInterruptHandler, CHANGE);
    #else
    attachInterrupt (DccProcState.ExtIntNum, ExternalInterruptHandler, RISING);
    117a:	63 e0       	ldi	r22, 0x03	; 3
    117c:	80 91 be 38 	lds	r24, 0x38BE	; 0x8038be <DccProcState+0x11>
    1180:	0e 94 73 00 	call	0xe6	; 0xe6 <attachInterrupt.constprop.7>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1627
    #endif

    // Set the Bits that control Multifunction or Accessory behaviour
    // and if the Accessory decoder optionally handles Output Addressing
    // we need to peal off the top two bits
    DccProcState.cv29Value = writeCV (CV_29_CONFIG, (readCV (CV_29_CONFIG) & ~FLAGS_CV29_BITS) | (Flags & FLAGS_CV29_BITS)) ;
    1184:	8d e1       	ldi	r24, 0x1D	; 29
    1186:	90 e0       	ldi	r25, 0x00	; 0
    1188:	9c da       	rcall	.-2760   	; 0x6c2 <readCV(unsigned int)>
    118a:	68 2f       	mov	r22, r24
    118c:	6f 73       	andi	r22, 0x3F	; 63
    118e:	8d e1       	ldi	r24, 0x1D	; 29
    1190:	90 e0       	ldi	r25, 0x00	; 0
    1192:	24 da       	rcall	.-3000   	; 0x5dc <writeCV(unsigned int, unsigned char)>
    1194:	80 93 c6 38 	sts	0x38C6, r24	; 0x8038c6 <DccProcState+0x19>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1633

    uint8_t doAutoFactoryDefault = 0;
    if ( (Flags & FLAGS_AUTO_FACTORY_DEFAULT) && (readCV (CV_VERSION_ID) == 255) && (readCV (CV_MANUFACTURER_ID) == 255))
        doAutoFactoryDefault = 1;

    writeCV (CV_VERSION_ID, VersionId) ;
    1198:	6a e0       	ldi	r22, 0x0A	; 10
    119a:	87 e0       	ldi	r24, 0x07	; 7
    119c:	90 e0       	ldi	r25, 0x00	; 0
    119e:	1e da       	rcall	.-3012   	; 0x5dc <writeCV(unsigned int, unsigned char)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1634
    writeCV (CV_MANUFACTURER_ID, ManufacturerId) ;
    11a0:	6d e0       	ldi	r22, 0x0D	; 13
    11a2:	88 e0       	ldi	r24, 0x08	; 8
    11a4:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1636

    clearDccProcState (0);
    11a6:	1a da       	rcall	.-3020   	; 0x5dc <writeCV(unsigned int, unsigned char)>
    11a8:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:25
} 


void Weistra::begin()
{
    pinMode(trackPin1, OUTPUT);
    11aa:	fb de       	rcall	.-522    	; 0xfa2 <clearDccProcState(unsigned char)>
begin():
    11ac:	80 91 6e 38 	lds	r24, 0x386E	; 0x80386e <pwm+0xc>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:26
    pinMode(trackPin2, OUTPUT);
    11b0:	db de       	rcall	.-586    	; 0xf68 <pinMode.constprop.10>
    11b2:	80 91 6f 38 	lds	r24, 0x386F	; 0x80386f <pwm+0xd>
    11b6:	d8 de       	rcall	.-592    	; 0xf68 <pinMode.constprop.10>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:28

    uint8_t port1 = digitalPinToPort( trackPin1 );
    11b8:	20 91 6e 38 	lds	r18, 0x386E	; 0x80386e <pwm+0xc>
main():
    11bc:	8f ef       	ldi	r24, 0xFF	; 255
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:29
    trackPin1     = digitalPinToBitMask( trackPin1 );
    11be:	9f ef       	ldi	r25, 0xFF	; 255
begin():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:28
void Weistra::begin()
{
    pinMode(trackPin1, OUTPUT);
    pinMode(trackPin2, OUTPUT);

    uint8_t port1 = digitalPinToPort( trackPin1 );
    11c0:	22 31       	cpi	r18, 0x12	; 18
    11c2:	48 f4       	brcc	.+18     	; 0x11d6 <main+0x104>
    11c4:	30 e0       	ldi	r19, 0x00	; 0
    11c6:	f9 01       	movw	r30, r18
    11c8:	e8 59       	subi	r30, 0x98	; 152
    11ca:	f2 46       	sbci	r31, 0x62	; 98
    11cc:	80 81       	ld	r24, Z
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:29
    trackPin1     = digitalPinToBitMask( trackPin1 );
    11ce:	26 58       	subi	r18, 0x86	; 134
    11d0:	32 46       	sbci	r19, 0x62	; 98
    11d2:	f9 01       	movw	r30, r18
    11d4:	90 81       	ld	r25, Z
    11d6:	90 93 6e 38 	sts	0x386E, r25	; 0x80386e <pwm+0xc>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:30
    portx_p1      = portOutputRegister( port1 );
    11da:	83 30       	cpi	r24, 0x03	; 3
    11dc:	08 f0       	brcs	.+2      	; 0x11e0 <main+0x10e>
    11de:	6c c0       	rjmp	.+216    	; 0x12b8 <main+0x1e6>
    11e0:	90 e0       	ldi	r25, 0x00	; 0
    11e2:	80 96       	adiw	r24, 0x20	; 32
    11e4:	35 e0       	ldi	r19, 0x05	; 5
    11e6:	88 0f       	add	r24, r24
    11e8:	99 1f       	adc	r25, r25
    11ea:	3a 95       	dec	r19
    11ec:	e1 f7       	brne	.-8      	; 0x11e6 <main+0x114>
    11ee:	04 96       	adiw	r24, 0x04	; 4
    11f0:	80 93 84 38 	sts	0x3884, r24	; 0x803884 <pwm+0x22>
    11f4:	90 93 85 38 	sts	0x3885, r25	; 0x803885 <pwm+0x23>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:32

    if( trackPin2 != 255 )
    11f8:	20 91 6f 38 	lds	r18, 0x386F	; 0x80386f <pwm+0xd>
    11fc:	2f 3f       	cpi	r18, 0xFF	; 255
    11fe:	e9 f0       	breq	.+58     	; 0x123a <main+0x168>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:34
    {
        uint8_t port2 = digitalPinToPort( trackPin2 );
    1200:	22 31       	cpi	r18, 0x12	; 18
    1202:	08 f0       	brcs	.+2      	; 0x1206 <main+0x134>
    1204:	d8 c4       	rjmp	.+2480   	; 0x1bb6 <main+0xae4>
    1206:	30 e0       	ldi	r19, 0x00	; 0
    1208:	f9 01       	movw	r30, r18
    120a:	e8 59       	subi	r30, 0x98	; 152
    120c:	f2 46       	sbci	r31, 0x62	; 98
    120e:	80 81       	ld	r24, Z
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:35
        trackPin2     = digitalPinToBitMask( trackPin2 );
    1210:	26 58       	subi	r18, 0x86	; 134
    1212:	32 46       	sbci	r19, 0x62	; 98
    1214:	d9 01       	movw	r26, r18
    1216:	9c 91       	ld	r25, X
    1218:	90 93 6f 38 	sts	0x386F, r25	; 0x80386f <pwm+0xd>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:36
        portx_p2      = portOutputRegister( port2 );
    121c:	83 30       	cpi	r24, 0x03	; 3
    121e:	08 f0       	brcs	.+2      	; 0x1222 <main+0x150>
    1220:	cd c4       	rjmp	.+2458   	; 0x1bbc <main+0xaea>
    1222:	90 e0       	ldi	r25, 0x00	; 0
    1224:	80 96       	adiw	r24, 0x20	; 32
    1226:	25 e0       	ldi	r18, 0x05	; 5
    1228:	88 0f       	add	r24, r24
    122a:	99 1f       	adc	r25, r25
    122c:	2a 95       	dec	r18
    122e:	e1 f7       	brne	.-8      	; 0x1228 <main+0x156>
    1230:	04 96       	adiw	r24, 0x04	; 4
    1232:	80 93 86 38 	sts	0x3886, r24	; 0x803886 <pwm+0x24>
    1236:	90 93 87 38 	sts	0x3887, r25	; 0x803887 <pwm+0x25>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:39
    }

    state = 1 ;
    123a:	81 e0       	ldi	r24, 0x01	; 1
    123c:	80 93 76 38 	sts	0x3876, r24	; 0x803876 <pwm+0x14>
setup():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:268
void setup()
{
    dcc.init(MAN_ID_DIY|FLAGS_MY_ADDRESS_ONLY, 10, 0, 0);
    pwm.begin();

    loadCV() ;
    1240:	29 db       	rcall	.-2478   	; 0x894 <loadCV()>
execDccProcessor():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1386
                        {
                            DB_PRINT ("eDP: Set BAddr:%d", BoardAddress);
                            writeCV (CV_ACCESSORY_DECODER_ADDRESS_LSB, (uint8_t) (BoardAddress % 64));
                            writeCV (CV_ACCESSORY_DECODER_ADDRESS_MSB, (uint8_t) (BoardAddress / 64));

                            if (notifyDccAccBoardAddrSet)
    1242:	10 e0       	ldi	r17, 0x00	; 0
    1244:	21 2e       	mov	r2, r17
    1246:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:127
        REPEAT_MS( 50 )
        {
            followSpeed() ;

            if( setPoint > currentSpeed ) state = accelerating ;
            if( setPoint < currentSpeed ) state = decelerating ;
    1248:	31 2e       	mov	r3, r17
throttle():
    124a:	04 e0       	ldi	r16, 0x04	; 4
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1715
}

////////////////////////////////////////////////////////////////////////
uint8_t NmraDcc::process()
{
    if (DccProcState.inServiceMode)
    124c:	50 2e       	mov	r5, r16
process():
    124e:	80 91 af 38 	lds	r24, 0x38AF	; 0x8038af <DccProcState+0x2>
    1252:	88 23       	and	r24, r24
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1717
    {
        if ( (millis() - DccProcState.LastServiceModeMillis) > 20L)
    1254:	a1 f0       	breq	.+40     	; 0x127e <main+0x1ac>
    1256:	86 d9       	rcall	.-3316   	; 0x564 <millis>
    1258:	00 91 b0 38 	lds	r16, 0x38B0	; 0x8038b0 <DccProcState+0x3>
    125c:	10 91 b1 38 	lds	r17, 0x38B1	; 0x8038b1 <DccProcState+0x4>
    1260:	20 91 b2 38 	lds	r18, 0x38B2	; 0x8038b2 <DccProcState+0x5>
    1264:	30 91 b3 38 	lds	r19, 0x38B3	; 0x8038b3 <DccProcState+0x6>
    1268:	60 1b       	sub	r22, r16
    126a:	71 0b       	sbc	r23, r17
    126c:	82 0b       	sbc	r24, r18
    126e:	93 0b       	sbc	r25, r19
    1270:	65 31       	cpi	r22, 0x15	; 21
    1272:	71 05       	cpc	r23, r1
    1274:	81 05       	cpc	r24, r1
    1276:	91 05       	cpc	r25, r1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1719
        {
            clearDccProcState (0) ;
    1278:	10 f0       	brcs	.+4      	; 0x127e <main+0x1ac>
    127a:	80 e0       	ldi	r24, 0x00	; 0
    127c:	92 de       	rcall	.-732    	; 0xfa2 <clearDccProcState(unsigned char)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1723
        }
    }

    if (DccRx.DataReady)
    127e:	80 91 41 38 	lds	r24, 0x3841	; 0x803841 <DccRx+0x2>
    1282:	88 23       	and	r24, r24
    1284:	09 f4       	brne	.+2      	; 0x1288 <main+0x1b6>
    1286:	3a c0       	rjmp	.+116    	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1729
    {
        // We need to do this check with interrupts disabled
        #ifdef ESP32
        portENTER_CRITICAL (&mux);
        #else
        noInterrupts();
    1288:	f8 94       	cli
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1731
        #endif
        Msg = DccRx.PacketCopy ;
    128a:	88 e0       	ldi	r24, 0x08	; 8
    128c:	ed e4       	ldi	r30, 0x4D	; 77
    128e:	f8 e3       	ldi	r31, 0x38	; 56
    1290:	a5 ea       	ldi	r26, 0xA5	; 165
    1292:	b8 e3       	ldi	r27, 0x38	; 56
    1294:	01 90       	ld	r0, Z+
    1296:	0d 92       	st	X+, r0
    1298:	8a 95       	dec	r24
    129a:	e1 f7       	brne	.-8      	; 0x1294 <main+0x1c2>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1732
        DccRx.DataReady = 0 ;
    129c:	10 92 41 38 	sts	0x3841, r1	; 0x803841 <DccRx+0x2>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1737

        #ifdef ESP32
        portEXIT_CRITICAL (&mux);
        #else
        interrupts();
    12a0:	78 94       	sei
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1744
        // Checking of the XOR-byte is now done in the ISR already
        #ifdef DCC_DBGVAR
        countOf.Tel++;
        #endif
        // Clear trailing bytes
        for (byte i=Msg.Size; i< MAX_DCC_MESSAGE_LEN; i++) Msg.Data[i] = 0;
    12a2:	80 91 a5 38 	lds	r24, 0x38A5	; 0x8038a5 <dcc>
    12a6:	e8 2f       	mov	r30, r24
    12a8:	f0 e0       	ldi	r31, 0x00	; 0
    12aa:	e9 55       	subi	r30, 0x59	; 89
    12ac:	f7 4c       	sbci	r31, 0xC7	; 199
    12ae:	86 30       	cpi	r24, 0x06	; 6
    12b0:	30 f4       	brcc	.+12     	; 0x12be <main+0x1ec>
    12b2:	11 92       	st	Z+, r1
    12b4:	8f 5f       	subi	r24, 0xFF	; 255
    12b6:	fb cf       	rjmp	.-10     	; 0x12ae <main+0x1dc>
main():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:30
    pinMode(trackPin1, OUTPUT);
    pinMode(trackPin2, OUTPUT);

    uint8_t port1 = digitalPinToPort( trackPin1 );
    trackPin1     = digitalPinToBitMask( trackPin1 );
    portx_p1      = portOutputRegister( port1 );
    12b8:	90 e0       	ldi	r25, 0x00	; 0
    12ba:	80 e0       	ldi	r24, 0x00	; 0
    12bc:	98 cf       	rjmp	.-208    	; 0x11ee <main+0x11c>
process():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1746

        if (notifyDccMsg) 	notifyDccMsg (&Msg);
    12be:	e0 e0       	ldi	r30, 0x00	; 0
    12c0:	f0 e0       	ldi	r31, 0x00	; 0
    12c2:	ef 2b       	or	r30, r31
    12c4:	21 f0       	breq	.+8      	; 0x12ce <main+0x1fc>
    12c6:	85 ea       	ldi	r24, 0xA5	; 165
    12c8:	98 e3       	ldi	r25, 0x38	; 56
    12ca:	0e 94 00 00 	call	0	; 0x0 <__vectors>
execDccProcessor():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1270
#endif

///////////////////////////////////////////////////////////////////////////////
void execDccProcessor (DCC_MSG * pDccMsg)
{
    if ( (pDccMsg->Data[0] == 0) && (pDccMsg->Data[1] == 0))
    12ce:	80 91 a7 38 	lds	r24, 0x38A7	; 0x8038a7 <dcc+0x2>
    12d2:	81 11       	cpse	r24, r1
    12d4:	8e c0       	rjmp	.+284    	; 0x13f2 <main+0x320>
    12d6:	90 91 a8 38 	lds	r25, 0x38A8	; 0x8038a8 <dcc+0x3>
    12da:	91 11       	cpse	r25, r1
    12dc:	8a c0       	rjmp	.+276    	; 0x13f2 <main+0x320>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1272
    {
        if (notifyDccReset)
    12de:	b0 e0       	ldi	r27, 0x00	; 0
    12e0:	cb 2e       	mov	r12, r27
    12e2:	b0 e0       	ldi	r27, 0x00	; 0
    12e4:	db 2e       	mov	r13, r27
    12e6:	cd 28       	or	r12, r13
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1273
            notifyDccReset (0) ;
    12e8:	11 f0       	breq	.+4      	; 0x12ee <main+0x21c>
    12ea:	0e 94 00 00 	call	0	; 0x0 <__vectors>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1277

        #ifdef NMRA_DCC_PROCESS_SERVICEMODE
        // If this is the first Reset then perform some one-shot actions as we maybe about to enter service mode
        if (DccProcState.inServiceMode)
    12ee:	80 91 af 38 	lds	r24, 0x38AF	; 0x8038af <DccProcState+0x2>
    12f2:	88 23       	and	r24, r24
    12f4:	09 f4       	brne	.+2      	; 0x12f8 <main+0x226>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1278
            resetServiceModeTimer (1) ;
    12f6:	7a c0       	rjmp	.+244    	; 0x13ec <main+0x31a>
    12f8:	81 e0       	ldi	r24, 0x01	; 1
    12fa:	40 d9       	rcall	.-3456   	; 0x57c <resetServiceModeTimer(unsigned char)>
loop():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:275

void loop()
{
    dcc.process();

    if( (my.mode & AM_FUNCTION_DECODER) == false ) throttle() ;
    12fc:	80 91 9e 38 	lds	r24, 0x389E	; 0x80389e <my+0xb>
    1300:	80 fd       	sbrc	r24, 0
    1302:	53 c3       	rjmp	.+1702   	; 0x19aa <main+0x8d8>
throttle():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:111

void throttle()
{
    static uint8 state = stationairy ;

    switch( state )
    1304:	80 91 89 38 	lds	r24, 0x3889	; 0x803889 <throttle()::state>
    1308:	82 30       	cpi	r24, 0x02	; 2
    130a:	09 f4       	brne	.+2      	; 0x130e <main+0x23c>
    130c:	ec c2       	rjmp	.+1496   	; 0x18e6 <main+0x814>
    130e:	08 f0       	brcs	.+2      	; 0x1312 <main+0x240>
    1310:	a5 c2       	rjmp	.+1354   	; 0x185c <main+0x78a>
    1312:	88 23       	and	r24, r24
    1314:	09 f4       	brne	.+2      	; 0x1318 <main+0x246>
    1316:	d6 c2       	rjmp	.+1452   	; 0x18c4 <main+0x7f2>
    1318:	81 30       	cpi	r24, 0x01	; 1
    131a:	09 f0       	breq	.+2      	; 0x131e <main+0x24c>
    131c:	98 cf       	rjmp	.-208    	; 0x124e <main+0x17c>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:118
    case stationairy:
        if( setPoint > 0 ) state = kickStart ;
        break ;

    case kickStart:
        if( pwm.kickStart( my.kickStartTime ) ) state = accelerating ; // sets kick start, returns true when pulse has passed
    131e:	80 91 9d 38 	lds	r24, 0x389D	; 0x80389d <my+0xa>
    1322:	c8 2e       	mov	r12, r24
    1324:	d1 2c       	mov	r13, r1
    1326:	f1 2c       	mov	r15, r1
    1328:	e1 2c       	mov	r14, r1
kickStart():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:142
    return state ;
}

uint8_t Weistra::kickStart( uint32_t _kickStartTime ) // sets a kickstart pulse for a certain duration
{
    if( state == 1 )
    132a:	80 91 76 38 	lds	r24, 0x3876	; 0x803876 <pwm+0x14>
    132e:	81 30       	cpi	r24, 0x01	; 1
    1330:	69 f5       	brne	.+90     	; 0x138c <main+0x2ba>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:143
    {   state = 0 ;
    1332:	10 92 76 38 	sts	0x3876, r1	; 0x803876 <pwm+0x14>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:145

        *portx_p1 &= ~trackPin1 ; // ensure they are both OFF
    1336:	e0 91 84 38 	lds	r30, 0x3884	; 0x803884 <pwm+0x22>
    133a:	f0 91 85 38 	lds	r31, 0x3885	; 0x803885 <pwm+0x23>
    133e:	90 81       	ld	r25, Z
    1340:	80 91 6e 38 	lds	r24, 0x386E	; 0x80386e <pwm+0xc>
    1344:	80 95       	com	r24
    1346:	89 23       	and	r24, r25
    1348:	80 83       	st	Z, r24
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:146
        *portx_p2 &= ~trackPin2 ;
    134a:	e0 91 86 38 	lds	r30, 0x3886	; 0x803886 <pwm+0x24>
    134e:	f0 91 87 38 	lds	r31, 0x3887	; 0x803887 <pwm+0x25>
    1352:	90 81       	ld	r25, Z
    1354:	80 91 6f 38 	lds	r24, 0x386F	; 0x80386f <pwm+0xd>
    1358:	80 95       	com	r24
    135a:	89 23       	and	r24, r25
    135c:	80 83       	st	Z, r24
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:148

        if(dir) *portx_p1 |=  trackPin1 ; // set one high
    135e:	80 91 77 38 	lds	r24, 0x3877	; 0x803877 <pwm+0x15>
    1362:	88 23       	and	r24, r24
    1364:	09 f4       	brne	.+2      	; 0x1368 <main+0x296>
    1366:	b7 c2       	rjmp	.+1390   	; 0x18d6 <main+0x804>
    1368:	e0 91 84 38 	lds	r30, 0x3884	; 0x803884 <pwm+0x22>
    136c:	f0 91 85 38 	lds	r31, 0x3885	; 0x803885 <pwm+0x23>
    1370:	80 81       	ld	r24, Z
    1372:	90 91 6e 38 	lds	r25, 0x386E	; 0x80386e <pwm+0xc>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:151
        else    *portx_p2 |=  trackPin2 ;

        prevTime2 = millis() ;          // load the time
    1376:	89 2b       	or	r24, r25
    1378:	80 83       	st	Z, r24
    137a:	f4 d8       	rcall	.-3608   	; 0x564 <millis>
    137c:	60 93 7e 38 	sts	0x387E, r22	; 0x80387e <pwm+0x1c>
    1380:	70 93 7f 38 	sts	0x387F, r23	; 0x80387f <pwm+0x1d>
    1384:	80 93 80 38 	sts	0x3880, r24	; 0x803880 <pwm+0x1e>
    1388:	90 93 81 38 	sts	0x3881, r25	; 0x803881 <pwm+0x1f>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:154
    }

    if( millis() - prevTime2 > _kickStartTime // and wait...
    138c:	eb d8       	rcall	.-3626   	; 0x564 <millis>
    138e:	00 91 7e 38 	lds	r16, 0x387E	; 0x80387e <pwm+0x1c>
    1392:	10 91 7f 38 	lds	r17, 0x387F	; 0x80387f <pwm+0x1d>
    1396:	20 91 80 38 	lds	r18, 0x3880	; 0x803880 <pwm+0x1e>
    139a:	30 91 81 38 	lds	r19, 0x3881	; 0x803881 <pwm+0x1f>
    139e:	60 1b       	sub	r22, r16
    13a0:	71 0b       	sbc	r23, r17
    13a2:	82 0b       	sbc	r24, r18
    13a4:	93 0b       	sbc	r25, r19
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:155
    &&  state == 0 )
    13a6:	c6 16       	cp	r12, r22
    13a8:	d7 06       	cpc	r13, r23
    13aa:	e8 06       	cpc	r14, r24
    13ac:	f9 06       	cpc	r15, r25
    13ae:	08 f0       	brcs	.+2      	; 0x13b2 <main+0x2e0>
    13b0:	4e cf       	rjmp	.-356    	; 0x124e <main+0x17c>
    13b2:	80 91 76 38 	lds	r24, 0x3876	; 0x803876 <pwm+0x14>
    13b6:	81 11       	cpse	r24, r1
    13b8:	4a cf       	rjmp	.-364    	; 0x124e <main+0x17c>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:157
    {     
        state = 1 ;
    13ba:	81 e0       	ldi	r24, 0x01	; 1
    13bc:	80 93 76 38 	sts	0x3876, r24	; 0x803876 <pwm+0x14>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:158
        *portx_p1 &= ~trackPin1 ;   // kill both outputs
    13c0:	e0 91 84 38 	lds	r30, 0x3884	; 0x803884 <pwm+0x22>
    13c4:	f0 91 85 38 	lds	r31, 0x3885	; 0x803885 <pwm+0x23>
    13c8:	90 81       	ld	r25, Z
    13ca:	80 91 6e 38 	lds	r24, 0x386E	; 0x80386e <pwm+0xc>
    13ce:	80 95       	com	r24
    13d0:	89 23       	and	r24, r25
    13d2:	80 83       	st	Z, r24
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:159
        *portx_p2 &= ~trackPin2 ;
    13d4:	e0 91 86 38 	lds	r30, 0x3886	; 0x803886 <pwm+0x24>
    13d8:	f0 91 87 38 	lds	r31, 0x3887	; 0x803887 <pwm+0x25>
    13dc:	90 81       	ld	r25, Z
    13de:	80 91 6f 38 	lds	r24, 0x386F	; 0x80386f <pwm+0xd>
    13e2:	80 95       	com	r24
    13e4:	89 23       	and	r24, r25
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:118
    13e6:	80 83       	st	Z, r24
throttle():
    13e8:	83 e0       	ldi	r24, 0x03	; 3
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1280
        else
            clearDccProcState (1);
    13ea:	72 c2       	rjmp	.+1252   	; 0x18d0 <main+0x7fe>
execDccProcessor():
    13ec:	81 e0       	ldi	r24, 0x01	; 1
    13ee:	d9 dd       	rcall	.-1102   	; 0xfa2 <clearDccProcState(unsigned char)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1287
    }

    else
    {
        #ifdef NMRA_DCC_PROCESS_SERVICEMODE
        if (DccProcState.inServiceMode && (pDccMsg->Data[0] >= 112) && (pDccMsg->Data[0] < 128))
    13f0:	85 cf       	rjmp	.-246    	; 0x12fc <main+0x22a>
    13f2:	90 91 af 38 	lds	r25, 0x38AF	; 0x8038af <DccProcState+0x2>
    13f6:	99 23       	and	r25, r25
    13f8:	09 f4       	brne	.+2      	; 0x13fc <main+0x32a>
    13fa:	90 c0       	rjmp	.+288    	; 0x151c <main+0x44a>
    13fc:	80 57       	subi	r24, 0x70	; 112
    13fe:	80 31       	cpi	r24, 0x10	; 16
    1400:	08 f0       	brcs	.+2      	; 0x1404 <main+0x332>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1289
        {
            resetServiceModeTimer (1) ;
    1402:	8a c0       	rjmp	.+276    	; 0x1518 <main+0x446>
    1404:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1292

            //Only check the DCC Packet "Size" and "Data" fields and ignore the "PreambleBits" as they can be different to the previous packet
            if (pDccMsg->Size != DccProcState.LastMsg.Size || memcmp (pDccMsg->Data, &DccProcState.LastMsg.Data, pDccMsg->Size) != 0)
    1406:	ba d8       	rcall	.-3724   	; 0x57c <resetServiceModeTimer(unsigned char)>
    1408:	d0 90 a5 38 	lds	r13, 0x38A5	; 0x8038a5 <dcc>
    140c:	db 82       	std	Y+3, r13	; 0x03
    140e:	80 91 b6 38 	lds	r24, 0x38B6	; 0x8038b6 <DccProcState+0x9>
    1412:	d8 12       	cpse	r13, r24
    1414:	09 c0       	rjmp	.+18     	; 0x1428 <main+0x356>
    1416:	4d 2d       	mov	r20, r13
    1418:	50 e0       	ldi	r21, 0x00	; 0
    141a:	68 eb       	ldi	r22, 0xB8	; 184
    141c:	78 e3       	ldi	r23, 0x38	; 56
    141e:	87 ea       	ldi	r24, 0xA7	; 167
    1420:	98 e3       	ldi	r25, 0x38	; 56
    1422:	81 d4       	rcall	.+2306   	; 0x1d26 <memcmp>
    1424:	89 2b       	or	r24, r25
    1426:	61 f0       	breq	.+24     	; 0x1440 <main+0x36e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1294
            {
                DccProcState.DuplicateCount = 0 ;
    1428:	10 92 b5 38 	sts	0x38B5, r1	; 0x8038b5 <DccProcState+0x8>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1295
                memcpy (&DccProcState.LastMsg, pDccMsg, sizeof (DCC_MSG)) ;
    142c:	88 e0       	ldi	r24, 0x08	; 8
    142e:	e5 ea       	ldi	r30, 0xA5	; 165
    1430:	f8 e3       	ldi	r31, 0x38	; 56
    1432:	a6 eb       	ldi	r26, 0xB6	; 182
    1434:	b8 e3       	ldi	r27, 0x38	; 56
    1436:	01 90       	ld	r0, Z+
    1438:	0d 92       	st	X+, r0
    143a:	8a 95       	dec	r24
    143c:	e1 f7       	brne	.-8      	; 0x1436 <main+0x364>
    143e:	5e cf       	rjmp	.-324    	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1300
            }
            // Wait until you see 2 identical packets before acting on a Service Mode Packet
            else
            {
                DccProcState.DuplicateCount++ ;
    1440:	80 91 b5 38 	lds	r24, 0x38B5	; 0x8038b5 <DccProcState+0x8>
    1444:	8f 5f       	subi	r24, 0xFF	; 255
    1446:	80 93 b5 38 	sts	0x38B5, r24	; 0x8038b5 <DccProcState+0x8>
processServiceModeOperation():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1164
#ifdef NMRA_DCC_PROCESS_SERVICEMODE
void processServiceModeOperation (DCC_MSG * pDccMsg)
{
    uint16_t CVAddr ;
    uint8_t Value ;
    if (pDccMsg->Size == 3) // 3 Byte Packets are for Address Only, Register and Paged Mode
    144a:	2b 81       	ldd	r18, Y+3	; 0x03
    144c:	23 30       	cpi	r18, 0x03	; 3
    144e:	09 f0       	breq	.+2      	; 0x1452 <main+0x380>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1168
    {
        uint8_t RegisterAddr ;
        DB_PRINT ("CV Address, Register & Paged Mode Operation");
        RegisterAddr = pDccMsg->Data[0] & 0x07 ;
    1450:	4b c0       	rjmp	.+150    	; 0x14e8 <main+0x416>
    1452:	20 91 a7 38 	lds	r18, 0x38A7	; 0x8038a7 <dcc+0x2>
    1456:	82 2f       	mov	r24, r18
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1169
        Value = pDccMsg->Data[1] ;
    1458:	87 70       	andi	r24, 0x07	; 7
    145a:	10 91 a8 38 	lds	r17, 0x38A8	; 0x8038a8 <dcc+0x3>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1171

        if (RegisterAddr == 5)
    145e:	85 30       	cpi	r24, 0x05	; 5
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1173
        {
            DccProcState.PageRegister = Value ;
    1460:	21 f4       	brne	.+8      	; 0x146a <main+0x398>
    1462:	10 93 b4 38 	sts	0x38B4, r17	; 0x8038b4 <DccProcState+0x7>
ackCV():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:782
void ackCV (void)
{
    if (notifyCVAck)
    {
        DB_PRINT ("ackCV: Send Basic ACK");
        notifyCVAck() ;
    1466:	49 dd       	rcall	.-1390   	; 0xefa <notifyCVAck>
    1468:	49 cf       	rjmp	.-366    	; 0x12fc <main+0x22a>
processServiceModeOperation():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1179
            ackCV();
        }

        else
        {
            if (RegisterAddr == 4)
    146a:	84 30       	cpi	r24, 0x04	; 4
    146c:	69 f1       	breq	.+90     	; 0x14c8 <main+0x3f6>
    146e:	48 2f       	mov	r20, r24
    1470:	50 e0       	ldi	r21, 0x00	; 0
    1472:	4b 83       	std	Y+3, r20	; 0x03
    1474:	5c 83       	std	Y+4, r21	; 0x04
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1182
                CVAddr = CV_29_CONFIG ;

            else if ( (RegisterAddr <= 3) && (DccProcState.PageRegister > 0))
    1476:	84 30       	cpi	r24, 0x04	; 4
    1478:	00 f5       	brcc	.+64     	; 0x14ba <main+0x3e8>
    147a:	80 91 b4 38 	lds	r24, 0x38B4	; 0x8038b4 <DccProcState+0x7>
    147e:	88 23       	and	r24, r24
    1480:	e1 f0       	breq	.+56     	; 0x14ba <main+0x3e8>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1183
                CVAddr = ( (DccProcState.PageRegister - 1) * 4) + RegisterAddr + 1 ;
    1482:	81 50       	subi	r24, 0x01	; 1
    1484:	99 0b       	sbc	r25, r25
    1486:	88 0f       	add	r24, r24
    1488:	99 1f       	adc	r25, r25
    148a:	88 0f       	add	r24, r24
    148c:	99 1f       	adc	r25, r25
    148e:	48 0f       	add	r20, r24
    1490:	59 1f       	adc	r21, r25
    1492:	4f 5f       	subi	r20, 0xFF	; 255
    1494:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1188

            else
                CVAddr = RegisterAddr + 1 ;

            if (pDccMsg->Data[0] & 0x08)  // Perform the Write Operation
    1496:	4b 83       	std	Y+3, r20	; 0x03
    1498:	5c 83       	std	Y+4, r21	; 0x04
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1190
            {
                if (validCV (CVAddr, 1))
    149a:	23 ff       	sbrs	r18, 3
    149c:	1a c0       	rjmp	.+52     	; 0x14d2 <main+0x400>
    149e:	61 e0       	ldi	r22, 0x01	; 1
    14a0:	8b 81       	ldd	r24, Y+3	; 0x03
    14a2:	9c 81       	ldd	r25, Y+4	; 0x04
    14a4:	9d da       	rcall	.-2758   	; 0x9e0 <validCV(unsigned int, unsigned char)>
    14a6:	88 23       	and	r24, r24
    14a8:	09 f4       	brne	.+2      	; 0x14ac <main+0x3da>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1192
                {
                    if (writeCV (CVAddr, Value) == Value)
    14aa:	28 cf       	rjmp	.-432    	; 0x12fc <main+0x22a>
    14ac:	61 2f       	mov	r22, r17
    14ae:	8b 81       	ldd	r24, Y+3	; 0x03
    14b0:	9c 81       	ldd	r25, Y+4	; 0x04
    14b2:	94 d8       	rcall	.-3800   	; 0x5dc <writeCV(unsigned int, unsigned char)>
    14b4:	18 13       	cpse	r17, r24
    14b6:	22 cf       	rjmp	.-444    	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1186

            else if ( (RegisterAddr <= 3) && (DccProcState.PageRegister > 0))
                CVAddr = ( (DccProcState.PageRegister - 1) * 4) + RegisterAddr + 1 ;

            else
                CVAddr = RegisterAddr + 1 ;
    14b8:	d6 cf       	rjmp	.-84     	; 0x1466 <main+0x394>
    14ba:	6b 81       	ldd	r22, Y+3	; 0x03
    14bc:	7c 81       	ldd	r23, Y+4	; 0x04
    14be:	6f 5f       	subi	r22, 0xFF	; 255
    14c0:	7f 4f       	sbci	r23, 0xFF	; 255
    14c2:	6b 83       	std	Y+3, r22	; 0x03
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1180
        }

        else
        {
            if (RegisterAddr == 4)
                CVAddr = CV_29_CONFIG ;
    14c4:	7c 83       	std	Y+4, r23	; 0x04
    14c6:	e9 cf       	rjmp	.-46     	; 0x149a <main+0x3c8>
main():
    14c8:	8d e1       	ldi	r24, 0x1D	; 29
    14ca:	90 e0       	ldi	r25, 0x00	; 0
    14cc:	8b 83       	std	Y+3, r24	; 0x03
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1199
                }
            }

            else  // Perform the Verify Operation
            {
                if (validCV (CVAddr, 0))
    14ce:	9c 83       	std	Y+4, r25	; 0x04
    14d0:	e4 cf       	rjmp	.-56     	; 0x149a <main+0x3c8>
processServiceModeOperation():
    14d2:	60 e0       	ldi	r22, 0x00	; 0
    14d4:	8b 81       	ldd	r24, Y+3	; 0x03
    14d6:	9c 81       	ldd	r25, Y+4	; 0x04
    14d8:	83 da       	rcall	.-2810   	; 0x9e0 <validCV(unsigned int, unsigned char)>
    14da:	88 23       	and	r24, r24
    14dc:	09 f4       	brne	.+2      	; 0x14e0 <main+0x40e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1201
                {
                    if (readCV (CVAddr) == Value)
    14de:	0e cf       	rjmp	.-484    	; 0x12fc <main+0x22a>
    14e0:	8b 81       	ldd	r24, Y+3	; 0x03
    14e2:	9c 81       	ldd	r25, Y+4	; 0x04
    14e4:	ee d8       	rcall	.-3620   	; 0x6c2 <readCV(unsigned int)>
    14e6:	e6 cf       	rjmp	.-52     	; 0x14b4 <main+0x3e2>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1208
                }
            }
        }
    }

    else if (pDccMsg->Size == 4) // 4 Byte Packets are for Direct Byte & Bit Mode
    14e8:	9b 81       	ldd	r25, Y+3	; 0x03
    14ea:	94 30       	cpi	r25, 0x04	; 4
    14ec:	09 f0       	breq	.+2      	; 0x14f0 <main+0x41e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1211
    {
        DB_PRINT ("CV Direct Byte and Bit Mode Mode Operation");
        CVAddr = ( ( (pDccMsg->Data[0] & 0x03) << 8) | pDccMsg->Data[1]) + 1 ;
    14ee:	06 cf       	rjmp	.-500    	; 0x12fc <main+0x22a>
    14f0:	80 91 a7 38 	lds	r24, 0x38A7	; 0x8038a7 <dcc+0x2>
    14f4:	68 2f       	mov	r22, r24
    14f6:	70 e0       	ldi	r23, 0x00	; 0
    14f8:	76 2f       	mov	r23, r22
    14fa:	66 27       	eor	r22, r22
    14fc:	66 27       	eor	r22, r22
    14fe:	73 70       	andi	r23, 0x03	; 3
    1500:	90 91 a8 38 	lds	r25, 0x38A8	; 0x8038a8 <dcc+0x3>
    1504:	69 2b       	or	r22, r25
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1214
        Value = pDccMsg->Data[2] ;

        processDirectCVOperation (pDccMsg->Data[0] & 0b00001100, CVAddr, Value, ackCV) ;
    1506:	6f 5f       	subi	r22, 0xFF	; 255
    1508:	7f 4f       	sbci	r23, 0xFF	; 255
    150a:	23 eb       	ldi	r18, 0xB3	; 179
    150c:	37 e0       	ldi	r19, 0x07	; 7
    150e:	40 91 a9 38 	lds	r20, 0x38A9	; 0x8038a9 <dcc+0x4>
    1512:	8c 70       	andi	r24, 0x0C	; 12
    1514:	96 da       	rcall	.-2772   	; 0xa42 <processDirectCVOperation(unsigned char, unsigned int, unsigned char, void (*)())>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1308
        }

        else
        {
            if (DccProcState.inServiceMode)
                clearDccProcState (0);
    1516:	f2 ce       	rjmp	.-540    	; 0x12fc <main+0x22a>
execDccProcessor():
    1518:	80 e0       	ldi	r24, 0x00	; 0
    151a:	43 dd       	rcall	.-1402   	; 0xfa2 <clearDccProcState(unsigned char)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1312
        #endif

            // Idle Packet
            if ( (pDccMsg->Data[0] == 0b11111111) && (pDccMsg->Data[1] == 0))
    151c:	80 91 a7 38 	lds	r24, 0x38A7	; 0x8038a7 <dcc+0x2>
    1520:	8f 3f       	cpi	r24, 0xFF	; 255
    1522:	61 f4       	brne	.+24     	; 0x153c <main+0x46a>
    1524:	80 91 a8 38 	lds	r24, 0x38A8	; 0x8038a8 <dcc+0x3>
    1528:	81 11       	cpse	r24, r1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1314
            {
                if (notifyDccIdle)
    152a:	e8 ce       	rjmp	.-560    	; 0x12fc <main+0x22a>
    152c:	a0 e0       	ldi	r26, 0x00	; 0
    152e:	b0 e0       	ldi	r27, 0x00	; 0
    1530:	ab 2b       	or	r26, r27
    1532:	09 f4       	brne	.+2      	; 0x1536 <main+0x464>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1315
                    notifyDccIdle() ;
    1534:	e3 ce       	rjmp	.-570    	; 0x12fc <main+0x22a>
    1536:	0e 94 00 00 	call	0	; 0x0 <__vectors>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1320
            }

            #ifdef NMRA_DCC_PROCESS_MULTIFUNCTION
            // Multi Function Decoders (7-bit address)
            else if (pDccMsg->Data[0] < 128)
    153a:	e0 ce       	rjmp	.-576    	; 0x12fc <main+0x22a>
    153c:	87 fd       	sbrc	r24, 7
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1321
                processMultiFunctionMessage (pDccMsg->Data[0], DCC_ADDR_SHORT, pDccMsg->Data[1], pDccMsg->Data[2], pDccMsg->Data[3]) ;
    153e:	0b c0       	rjmp	.+22     	; 0x1556 <main+0x484>
    1540:	00 91 aa 38 	lds	r16, 0x38AA	; 0x8038aa <dcc+0x5>
    1544:	20 91 a9 38 	lds	r18, 0x38A9	; 0x8038a9 <dcc+0x4>
    1548:	40 91 a8 38 	lds	r20, 0x38A8	; 0x8038a8 <dcc+0x3>
    154c:	70 e0       	ldi	r23, 0x00	; 0
    154e:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1532
            else if (pDccMsg->Data[0] < 232)
            {
                uint16_t Address ;
                Address = ( (pDccMsg->Data[0] - 192) << 8) | pDccMsg->Data[1];
                //TODO should we convert Address to 1 .. 10239 ?
                processMultiFunctionMessage (Address, DCC_ADDR_LONG, pDccMsg->Data[2], pDccMsg->Data[3], pDccMsg->Data[4]) ;
    1550:	90 e0       	ldi	r25, 0x00	; 0
    1552:	dd da       	rcall	.-2630   	; 0xb0e <processMultiFunctionMessage(unsigned int, DCC_ADDR_TYPE, unsigned char, unsigned char, unsigned char)>
    1554:	d3 ce       	rjmp	.-602    	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1324
            // Multi Function Decoders (7-bit address)
            else if (pDccMsg->Data[0] < 128)
                processMultiFunctionMessage (pDccMsg->Data[0], DCC_ADDR_SHORT, pDccMsg->Data[1], pDccMsg->Data[2], pDccMsg->Data[3]) ;

            // Basic Accessory Decoders (9-bit) & Extended Accessory Decoders (11-bit)
            else if (pDccMsg->Data[0] < 192)
    1556:	80 3c       	cpi	r24, 0xC0	; 192
    1558:	08 f0       	brcs	.+2      	; 0x155c <main+0x48a>
    155a:	6d c1       	rjmp	.+730    	; 0x1836 <main+0x764>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1329
            #else
            else if ( (pDccMsg->Data[0] >= 128) && (pDccMsg->Data[0] < 192))
            #endif
            {
                if (DccProcState.Flags & FLAGS_DCC_ACCESSORY_DECODER)
    155c:	90 91 ad 38 	lds	r25, 0x38AD	; 0x8038ad <DccProcState>
    1560:	97 ff       	sbrs	r25, 7
    1562:	cc ce       	rjmp	.-616    	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1339

                    #ifdef DEBUG_PRINT
                    SerialPrintPacketHex (F ("eDP: AccCmd: "), pDccMsg);
                    #endif

                    BoardAddress = ( ( (~pDccMsg->Data[1]) & 0b01110000) << 2) | (pDccMsg->Data[0] & 0b00111111) ;
    1564:	40 91 a8 38 	lds	r20, 0x38A8	; 0x8038a8 <dcc+0x3>
    1568:	24 2f       	mov	r18, r20
    156a:	30 e0       	ldi	r19, 0x00	; 0
    156c:	f9 01       	movw	r30, r18
    156e:	e0 95       	com	r30
    1570:	f0 95       	com	r31
    1572:	ee 0f       	add	r30, r30
    1574:	ff 1f       	adc	r31, r31
    1576:	ee 0f       	add	r30, r30
    1578:	ff 1f       	adc	r31, r31
    157a:	e0 7c       	andi	r30, 0xC0	; 192
    157c:	f1 70       	andi	r31, 0x01	; 1
    157e:	8f 73       	andi	r24, 0x3F	; 63
    1580:	e8 2b       	or	r30, r24
    1582:	eb 83       	std	Y+3, r30	; 0x03
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1340
                    TurnoutPairIndex = (pDccMsg->Data[1] & 0b00000110) >> 1;
    1584:	fc 83       	std	Y+4, r31	; 0x04
    1586:	35 95       	asr	r19
    1588:	27 95       	ror	r18
    158a:	f2 2f       	mov	r31, r18
    158c:	f3 70       	andi	r31, 0x03	; 3
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1345
                    DB_PRINT ("eDP: BAddr:%d, Index:%d", BoardAddress, TurnoutPairIndex);

                    // First check for Legacy Accessory Decoder Configuration Variable Access Instruction
                    // as it's got a different format to the others
                    if ( (pDccMsg->Size == 5) && ( (pDccMsg->Data[1] & 0b10001100) == 0b00001100))
    158e:	4f 2e       	mov	r4, r31
    1590:	80 91 a5 38 	lds	r24, 0x38A5	; 0x8038a5 <dcc>
    1594:	85 30       	cpi	r24, 0x05	; 5
    1596:	71 f5       	brne	.+92     	; 0x15f4 <main+0x522>
    1598:	4c 78       	andi	r20, 0x8C	; 140
    159a:	4c 30       	cpi	r20, 0x0C	; 12
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1349
                    {
                        DB_PRINT ("eDP: Legacy Accessory Decoder CV Access Command");
                        // Check if this command is for our address or the broadcast address
                        if ( (BoardAddress != getMyAddr()) && (BoardAddress < 511))
    159c:	59 f5       	brne	.+86     	; 0x15f4 <main+0x522>
    159e:	9c d8       	rcall	.-3784   	; 0x6d8 <getMyAddr()>
    15a0:	cb 80       	ldd	r12, Y+3	; 0x03
    15a2:	dc 80       	ldd	r13, Y+4	; 0x04
    15a4:	8c 15       	cp	r24, r12
    15a6:	9d 05       	cpc	r25, r13
    15a8:	31 f0       	breq	.+12     	; 0x15b6 <main+0x4e4>
    15aa:	2f ef       	ldi	r18, 0xFF	; 255
    15ac:	c2 16       	cp	r12, r18
    15ae:	21 e0       	ldi	r18, 0x01	; 1
    15b0:	d2 06       	cpc	r13, r18
    15b2:	09 f0       	breq	.+2      	; 0x15b6 <main+0x4e4>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1355
                        {
                            DB_PRINT ("eDP: Board Address Not Matched");
                            return;
                        }

                        uint16_t cvAddress = ( (pDccMsg->Data[1] & 0b00000011) << 8) + pDccMsg->Data[2] + 1;
    15b4:	a3 ce       	rjmp	.-698    	; 0x12fc <main+0x22a>
    15b6:	30 91 a8 38 	lds	r19, 0x38A8	; 0x8038a8 <dcc+0x3>
    15ba:	43 2f       	mov	r20, r19
    15bc:	50 e0       	ldi	r21, 0x00	; 0
    15be:	74 2f       	mov	r23, r20
    15c0:	66 27       	eor	r22, r22
    15c2:	66 27       	eor	r22, r22
    15c4:	73 70       	andi	r23, 0x03	; 3
    15c6:	80 91 a9 38 	lds	r24, 0x38A9	; 0x8038a9 <dcc+0x4>
    15ca:	68 0f       	add	r22, r24
    15cc:	71 1d       	adc	r23, r1
    15ce:	6f 5f       	subi	r22, 0xFF	; 255
    15d0:	7f 4f       	sbci	r23, 0xFF	; 255
    15d2:	6b 83       	std	Y+3, r22	; 0x03
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1356
                        uint8_t  cvValue   = pDccMsg->Data[3];
    15d4:	7c 83       	std	Y+4, r23	; 0x04
    15d6:	10 91 aa 38 	lds	r17, 0x38AA	; 0x8038aa <dcc+0x5>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1498
                            DB_PRINT ("eDP: Unsupported OPS Mode Instruction:%d", insType);
                            break; // We only support Write Byte or Bit Manipulation

                        case OPS_INS_WRITE_BYTE:
                            DB_PRINT ("eDP: CV:%d Value:%d", cvAddress, cvValue);
                            if (validCV (cvAddress, 1))
    15da:	61 e0       	ldi	r22, 0x01	; 1
    15dc:	8b 81       	ldd	r24, Y+3	; 0x03
    15de:	9c 81       	ldd	r25, Y+4	; 0x04
    15e0:	ff d9       	rcall	.-3074   	; 0x9e0 <validCV(unsigned int, unsigned char)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1499
                                writeCV (cvAddress, cvValue);
    15e2:	61 2f       	mov	r22, r17
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1498
                            DB_PRINT ("eDP: Unsupported OPS Mode Instruction:%d", insType);
                            break; // We only support Write Byte or Bit Manipulation

                        case OPS_INS_WRITE_BYTE:
                            DB_PRINT ("eDP: CV:%d Value:%d", cvAddress, cvValue);
                            if (validCV (cvAddress, 1))
    15e4:	88 23       	and	r24, r24
    15e6:	09 f4       	brne	.+2      	; 0x15ea <main+0x518>
    15e8:	89 ce       	rjmp	.-750    	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1515
                            if ( (cvValue & 0b00010000) && validCV (cvAddress, 1))
                            {
                                uint8_t currentValue = readCV (cvAddress);
                                uint8_t newValueMask = 1 << (cvValue & 0b00000111);
                                if (cvValue & 0b00001000)
                                    writeCV (cvAddress, currentValue | newValueMask);
    15ea:	8b 81       	ldd	r24, Y+3	; 0x03
    15ec:	9c 81       	ldd	r25, Y+4	; 0x04
    15ee:	0e 94 ee 02 	call	0x5dc	; 0x5dc <writeCV(unsigned int, unsigned char)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1364
                            writeCV (cvAddress, cvValue);
                        return;
                    }


                    OutputAddress = ( ( (BoardAddress - 1) << 2) | TurnoutPairIndex) + 1 ; //decoder output addresses start with 1, packet address range starts with 0
    15f2:	84 ce       	rjmp	.-760    	; 0x12fc <main+0x22a>
    15f4:	eb 80       	ldd	r14, Y+3	; 0x03
    15f6:	fc 80       	ldd	r15, Y+4	; 0x04
    15f8:	71 e0       	ldi	r23, 0x01	; 1
    15fa:	e7 1a       	sub	r14, r23
    15fc:	f1 08       	sbc	r15, r1
    15fe:	ee 0c       	add	r14, r14
    1600:	ff 1c       	adc	r15, r15
    1602:	ee 0c       	add	r14, r14
    1604:	ff 1c       	adc	r15, r15
    1606:	e4 28       	or	r14, r4
    1608:	87 01       	movw	r16, r14
    160a:	0f 5f       	subi	r16, 0xFF	; 255
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1368
                    // ( according to NMRA 9.2.2 )
                    DB_PRINT ("eDP: OAddr:%d", OutputAddress);

                    if (DccProcState.inAccDecDCCAddrNextReceivedMode)
    160c:	1f 4f       	sbci	r17, 0xFF	; 255
    160e:	80 91 c5 38 	lds	r24, 0x38C5	; 0x8038c5 <DccProcState+0x18>
    1612:	88 23       	and	r24, r24
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1370
                    {
                        if (DccProcState.Flags & FLAGS_OUTPUT_ADDRESS_MODE)
    1614:	f1 f0       	breq	.+60     	; 0x1652 <main+0x580>
    1616:	96 ff       	sbrs	r25, 6
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1374
                        {
                            DB_PRINT ("eDP: Set OAddr:%d", OutputAddress);
                            //uint16_t storedOutputAddress = OutputAddress + 1; // The value stored in CV1 & 9 for Output Addressing Mode is + 1
                            writeCV (CV_ACCESSORY_DECODER_ADDRESS_LSB, (uint8_t) (OutputAddress % 256));
    1618:	40 c0       	rjmp	.+128    	; 0x169a <main+0x5c8>
    161a:	c8 01       	movw	r24, r16
    161c:	60 e0       	ldi	r22, 0x00	; 0
    161e:	71 e0       	ldi	r23, 0x01	; 1
    1620:	f8 d2       	rcall	.+1520   	; 0x1c12 <__divmodhi4>
    1622:	68 2f       	mov	r22, r24
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	90 e0       	ldi	r25, 0x00	; 0
    1628:	0e 94 ee 02 	call	0x5dc	; 0x5dc <writeCV(unsigned int, unsigned char)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1375
                            writeCV (CV_ACCESSORY_DECODER_ADDRESS_MSB, (uint8_t) (OutputAddress / 256));
    162c:	c8 01       	movw	r24, r16
    162e:	17 ff       	sbrs	r17, 7
    1630:	02 c0       	rjmp	.+4      	; 0x1636 <main+0x564>
    1632:	81 50       	subi	r24, 0x01	; 1
    1634:	9f 4f       	sbci	r25, 0xFF	; 255
    1636:	69 2f       	mov	r22, r25
    1638:	89 e0       	ldi	r24, 0x09	; 9
    163a:	90 e0       	ldi	r25, 0x00	; 0
    163c:	0e 94 ee 02 	call	0x5dc	; 0x5dc <writeCV(unsigned int, unsigned char)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1377

                            if (notifyDccAccOutputAddrSet)
    1640:	80 e0       	ldi	r24, 0x00	; 0
    1642:	90 e0       	ldi	r25, 0x00	; 0
    1644:	89 2b       	or	r24, r25
    1646:	19 f0       	breq	.+6      	; 0x164e <main+0x57c>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1378
                                notifyDccAccOutputAddrSet (OutputAddress);
    1648:	c8 01       	movw	r24, r16
    164a:	0e 94 00 00 	call	0	; 0x0 <__vectors>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1390

                            if (notifyDccAccBoardAddrSet)
                                notifyDccAccBoardAddrSet (BoardAddress);
                        }

                        DccProcState.inAccDecDCCAddrNextReceivedMode = 0; // Reset the mode now that we have set the address
    164e:	10 92 c5 38 	sts	0x38C5, r1	; 0x8038c5 <DccProcState+0x18>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1394
                    }

                    // If we're filtering addresses, does the address match our address or is it a broadcast address? If NOT then return
                    if (DccProcState.Flags & FLAGS_MY_ADDRESS_ONLY)
    1652:	80 91 ad 38 	lds	r24, 0x38AD	; 0x8038ad <DccProcState>
    1656:	80 fd       	sbrc	r24, 0
    1658:	3b c0       	rjmp	.+118    	; 0x16d0 <main+0x5fe>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1417
                        }
                        DB_PRINT ("eDP: Address Matched");
                    }


                    if ( (pDccMsg->Size == 4) && ( (pDccMsg->Data[1] & 0b10001001) == 1))	// Extended Accessory Decoder Control Packet Format
    165a:	80 91 a5 38 	lds	r24, 0x38A5	; 0x8038a5 <dcc>
    165e:	84 30       	cpi	r24, 0x04	; 4
    1660:	09 f0       	breq	.+2      	; 0x1664 <main+0x592>
    1662:	52 c0       	rjmp	.+164    	; 0x1708 <main+0x636>
    1664:	80 91 a8 38 	lds	r24, 0x38A8	; 0x8038a8 <dcc+0x3>
    1668:	89 78       	andi	r24, 0x89	; 137
    166a:	81 30       	cpi	r24, 0x01	; 1
    166c:	09 f0       	breq	.+2      	; 0x1670 <main+0x59e>
    166e:	46 ce       	rjmp	.-884    	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1423
                    {
                        // According to the NMRA Dcc Spec the Signal State should only use the lower 5 Bits,
                        // however some manufacturers seem to allow/use all 8 bits, so we'll relax that constraint for now
                        uint8_t state = pDccMsg->Data[2] ;
                        DB_PRINT ("eDP: OAddr:%d  Extended State:%0X", OutputAddress, state);
                        if (notifyDccSigOutputState)
    1670:	40 e0       	ldi	r20, 0x00	; 0
    1672:	50 e0       	ldi	r21, 0x00	; 0
    1674:	45 2b       	or	r20, r21
    1676:	29 f0       	breq	.+10     	; 0x1682 <main+0x5b0>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1424
                            notifyDccSigOutputState (OutputAddress, state);
    1678:	60 91 a9 38 	lds	r22, 0x38A9	; 0x8038a9 <dcc+0x4>
    167c:	c8 01       	movw	r24, r16
    167e:	0e 94 00 00 	call	0	; 0x0 <__vectors>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1427

                        // old callback ( for compatibility with 1.4.2, not to be used in new designs )
                        if (notifyDccSigState)
    1682:	60 e0       	ldi	r22, 0x00	; 0
    1684:	70 e0       	ldi	r23, 0x00	; 0
    1686:	67 2b       	or	r22, r23
    1688:	09 f4       	brne	.+2      	; 0x168c <main+0x5ba>
    168a:	38 ce       	rjmp	.-912    	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1428
                            notifyDccSigState (OutputAddress, TurnoutPairIndex, pDccMsg->Data[2]) ;
    168c:	40 91 a9 38 	lds	r20, 0x38A9	; 0x8038a9 <dcc+0x4>
    1690:	64 2d       	mov	r22, r4
    1692:	c8 01       	movw	r24, r16
    1694:	0e 94 00 00 	call	0	; 0x0 <__vectors>
    1698:	31 ce       	rjmp	.-926    	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1383
                                notifyDccAccOutputAddrSet (OutputAddress);
                        }
                        else
                        {
                            DB_PRINT ("eDP: Set BAddr:%d", BoardAddress);
                            writeCV (CV_ACCESSORY_DECODER_ADDRESS_LSB, (uint8_t) (BoardAddress % 64));
    169a:	6b 81       	ldd	r22, Y+3	; 0x03
    169c:	7c 81       	ldd	r23, Y+4	; 0x04
    169e:	6f 73       	andi	r22, 0x3F	; 63
    16a0:	77 27       	eor	r23, r23
    16a2:	81 e0       	ldi	r24, 0x01	; 1
    16a4:	90 e0       	ldi	r25, 0x00	; 0
    16a6:	0e 94 ee 02 	call	0x5dc	; 0x5dc <writeCV(unsigned int, unsigned char)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1384
                            writeCV (CV_ACCESSORY_DECODER_ADDRESS_MSB, (uint8_t) (BoardAddress / 64));
    16aa:	6b 81       	ldd	r22, Y+3	; 0x03
    16ac:	7c 81       	ldd	r23, Y+4	; 0x04
    16ae:	46 e0       	ldi	r20, 0x06	; 6
    16b0:	75 95       	asr	r23
    16b2:	67 95       	ror	r22
    16b4:	4a 95       	dec	r20
    16b6:	e1 f7       	brne	.-8      	; 0x16b0 <main+0x5de>
    16b8:	89 e0       	ldi	r24, 0x09	; 9
    16ba:	90 e0       	ldi	r25, 0x00	; 0
    16bc:	0e 94 ee 02 	call	0x5dc	; 0x5dc <writeCV(unsigned int, unsigned char)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1386

                            if (notifyDccAccBoardAddrSet)
    16c0:	21 14       	cp	r2, r1
    16c2:	31 04       	cpc	r3, r1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1387
                                notifyDccAccBoardAddrSet (BoardAddress);
    16c4:	21 f2       	breq	.-120    	; 0x164e <main+0x57c>
    16c6:	8b 81       	ldd	r24, Y+3	; 0x03
    16c8:	9c 81       	ldd	r25, Y+4	; 0x04
    16ca:	0e 94 00 00 	call	0	; 0x0 <__vectors>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1396
                    }

                    // If we're filtering addresses, does the address match our address or is it a broadcast address? If NOT then return
                    if (DccProcState.Flags & FLAGS_MY_ADDRESS_ONLY)
                    {
                        if (DccProcState.Flags & FLAGS_OUTPUT_ADDRESS_MODE)
    16ce:	bf cf       	rjmp	.-130    	; 0x164e <main+0x57c>
    16d0:	86 ff       	sbrs	r24, 6
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1399
                        {
                            DB_PRINT (" AddrChk: OAddr:%d, BAddr:%d, myAddr:%d Chk=%d", OutputAddress, BoardAddress, getMyAddr(), OutputAddress != getMyAddr());
                            if (OutputAddress != getMyAddr()  &&  OutputAddress < 2045)
    16d2:	0b c0       	rjmp	.+22     	; 0x16ea <main+0x618>
    16d4:	01 d8       	rcall	.-4094   	; 0x6d8 <getMyAddr()>
    16d6:	80 17       	cp	r24, r16
    16d8:	91 07       	cpc	r25, r17
    16da:	09 f4       	brne	.+2      	; 0x16de <main+0x60c>
    16dc:	be cf       	rjmp	.-132    	; 0x165a <main+0x588>
    16de:	0d 3f       	cpi	r16, 0xFD	; 253
    16e0:	97 e0       	ldi	r25, 0x07	; 7
    16e2:	19 07       	cpc	r17, r25
    16e4:	0c f0       	brlt	.+2      	; 0x16e8 <main+0x616>
    16e6:	b9 cf       	rjmp	.-142    	; 0x165a <main+0x588>
    16e8:	09 ce       	rjmp	.-1006   	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1407
                                return;
                            }
                        }
                        else
                        {
                            if ( (BoardAddress != getMyAddr()) && (BoardAddress < 511))
    16ea:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <getMyAddr()>
    16ee:	cb 80       	ldd	r12, Y+3	; 0x03
    16f0:	dc 80       	ldd	r13, Y+4	; 0x04
    16f2:	8c 15       	cp	r24, r12
    16f4:	9d 05       	cpc	r25, r13
    16f6:	09 f4       	brne	.+2      	; 0x16fa <main+0x628>
    16f8:	b0 cf       	rjmp	.-160    	; 0x165a <main+0x588>
    16fa:	2f ef       	ldi	r18, 0xFF	; 255
    16fc:	c2 16       	cp	r12, r18
    16fe:	21 e0       	ldi	r18, 0x01	; 1
    1700:	d2 06       	cpc	r13, r18
    1702:	09 f4       	brne	.+2      	; 0x1706 <main+0x634>
    1704:	aa cf       	rjmp	.-172    	; 0x165a <main+0x588>
    1706:	fa cd       	rjmp	.-1036   	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1431
                        // old callback ( for compatibility with 1.4.2, not to be used in new designs )
                        if (notifyDccSigState)
                            notifyDccSigState (OutputAddress, TurnoutPairIndex, pDccMsg->Data[2]) ;
                    }

                    else if (pDccMsg->Size == 3) // Basic Accessory Decoder Packet Format
    1708:	83 30       	cpi	r24, 0x03	; 3
    170a:	79 f5       	brne	.+94     	; 0x176a <main+0x698>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1433
                    {
                        uint8_t direction   =  pDccMsg->Data[1] & 0b00000001;
    170c:	40 91 a8 38 	lds	r20, 0x38A8	; 0x8038a8 <dcc+0x3>
    1710:	74 2f       	mov	r23, r20
    1712:	71 70       	andi	r23, 0x01	; 1
    1714:	e7 2e       	mov	r14, r23
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1434
                        uint8_t outputPower = (pDccMsg->Data[1] & 0b00001000) >> 3;
    1716:	43 fb       	bst	r20, 3
    1718:	ff 24       	eor	r15, r15
    171a:	f0 f8       	bld	r15, 0
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1437

                        // old callback ( for compatibility with 1.4.2, not to be used in new designs )
                        if (notifyDccAccState)
    171c:	80 e0       	ldi	r24, 0x00	; 0
    171e:	90 e0       	ldi	r25, 0x00	; 0
    1720:	89 2b       	or	r24, r25
    1722:	39 f0       	breq	.+14     	; 0x1732 <main+0x660>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1438
                            notifyDccAccState (OutputAddress, BoardAddress, pDccMsg->Data[1] & 0b00000111, outputPower);
    1724:	47 70       	andi	r20, 0x07	; 7
    1726:	2f 2d       	mov	r18, r15
    1728:	6b 81       	ldd	r22, Y+3	; 0x03
    172a:	7c 81       	ldd	r23, Y+4	; 0x04
    172c:	c8 01       	movw	r24, r16
    172e:	0e 94 00 00 	call	0	; 0x0 <__vectors>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1440

                        if (DccProcState.Flags & FLAGS_OUTPUT_ADDRESS_MODE)
    1732:	80 91 ad 38 	lds	r24, 0x38AD	; 0x8038ad <DccProcState>
    1736:	86 ff       	sbrs	r24, 6
    1738:	0b c0       	rjmp	.+22     	; 0x1750 <main+0x67e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1443
                        {
                            DB_PRINT ("eDP: OAddr:%d  Turnout Dir:%d  Output Power:%d", OutputAddress, direction, outputPower);
                            if (notifyDccAccTurnoutOutput)
    173a:	a0 e0       	ldi	r26, 0x00	; 0
    173c:	b0 e0       	ldi	r27, 0x00	; 0
    173e:	ab 2b       	or	r26, r27
    1740:	09 f4       	brne	.+2      	; 0x1744 <main+0x672>
    1742:	dc cd       	rjmp	.-1096   	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1444
                                notifyDccAccTurnoutOutput (OutputAddress, direction, outputPower);
    1744:	4f 2d       	mov	r20, r15
    1746:	6e 2d       	mov	r22, r14
    1748:	c8 01       	movw	r24, r16
    174a:	0e 94 00 00 	call	0	; 0x0 <__vectors>
    174e:	d6 cd       	rjmp	.-1108   	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1449
                        }
                        else
                        {
                            DB_PRINT ("eDP: Turnout Pair Index:%d Dir:%d Output Power: ", TurnoutPairIndex, direction, outputPower);
                            if (notifyDccAccTurnoutBoard)
    1750:	e0 e0       	ldi	r30, 0x00	; 0
    1752:	f0 e0       	ldi	r31, 0x00	; 0
    1754:	ef 2b       	or	r30, r31
    1756:	09 f4       	brne	.+2      	; 0x175a <main+0x688>
    1758:	d1 cd       	rjmp	.-1118   	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1450
                                notifyDccAccTurnoutBoard (BoardAddress, TurnoutPairIndex, direction, outputPower);
    175a:	2f 2d       	mov	r18, r15
    175c:	4e 2d       	mov	r20, r14
    175e:	64 2d       	mov	r22, r4
    1760:	8b 81       	ldd	r24, Y+3	; 0x03
    1762:	9c 81       	ldd	r25, Y+4	; 0x04
    1764:	0e 94 00 00 	call	0	; 0x0 <__vectors>
    1768:	c9 cd       	rjmp	.-1134   	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1453
                        }
                    }
                    else if (pDccMsg->Size == 6) // Accessory Decoder OPS Mode Programming
    176a:	86 30       	cpi	r24, 0x06	; 6
    176c:	09 f0       	breq	.+2      	; 0x1770 <main+0x69e>
    176e:	c6 cd       	rjmp	.-1140   	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1457
                    {
                        DB_PRINT ("eDP: OPS Mode CV Programming Command");
                        // Check for unsupported OPS Mode Addressing mode
                        if ( ( (pDccMsg->Data[1] & 0b10001001) != 1) && ( (pDccMsg->Data[1] & 0b10001111) != 0x80))
    1770:	80 91 a8 38 	lds	r24, 0x38A8	; 0x8038a8 <dcc+0x3>
    1774:	98 2f       	mov	r25, r24
    1776:	99 78       	andi	r25, 0x89	; 137
    1778:	91 30       	cpi	r25, 0x01	; 1
    177a:	21 f0       	breq	.+8      	; 0x1784 <main+0x6b2>
    177c:	8f 78       	andi	r24, 0x8F	; 143
    177e:	80 38       	cpi	r24, 0x80	; 128
    1780:	09 f0       	breq	.+2      	; 0x1784 <main+0x6b2>
    1782:	bc cd       	rjmp	.-1160   	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1464
                            DB_PRINT ("eDP: Unsupported OPS Mode CV Addressing Mode");
                            return;
                        }

                        // Check if this command is for our address or the broadcast address
                        if (DccProcState.Flags & FLAGS_OUTPUT_ADDRESS_MODE)
    1784:	80 91 ad 38 	lds	r24, 0x38AD	; 0x8038ad <DccProcState>
    1788:	86 ff       	sbrs	r24, 6
    178a:	2c c0       	rjmp	.+88     	; 0x17e4 <main+0x712>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1467
                        {
                            DB_PRINT ("eDP: Check Output Address:%d", OutputAddress);
                            if ( (OutputAddress != getMyAddr()) && (OutputAddress < 2045))
    178c:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <getMyAddr()>
    1790:	80 17       	cp	r24, r16
    1792:	91 07       	cpc	r25, r17
    1794:	19 f5       	brne	.+70     	; 0x17dc <main+0x70a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1483
                                DB_PRINT ("eDP: Board Address Not Matched");
                                return;
                            }
                        }

                        uint16_t cvAddress = ( (pDccMsg->Data[2] & 0b00000011) << 8) + pDccMsg->Data[3] + 1;
    1796:	80 91 a9 38 	lds	r24, 0x38A9	; 0x8038a9 <dcc+0x4>
    179a:	90 e0       	ldi	r25, 0x00	; 0
    179c:	d8 2e       	mov	r13, r24
    179e:	cc 24       	eor	r12, r12
    17a0:	96 01       	movw	r18, r12
    17a2:	22 27       	eor	r18, r18
    17a4:	33 70       	andi	r19, 0x03	; 3
    17a6:	2b 83       	std	Y+3, r18	; 0x03
    17a8:	3c 83       	std	Y+4, r19	; 0x04
    17aa:	20 91 aa 38 	lds	r18, 0x38AA	; 0x8038aa <dcc+0x5>
    17ae:	4b 81       	ldd	r20, Y+3	; 0x03
    17b0:	5c 81       	ldd	r21, Y+4	; 0x04
    17b2:	42 0f       	add	r20, r18
    17b4:	51 1d       	adc	r21, r1
    17b6:	4f 5f       	subi	r20, 0xFF	; 255
    17b8:	5f 4f       	sbci	r21, 0xFF	; 255
    17ba:	4b 83       	std	Y+3, r20	; 0x03
    17bc:	5c 83       	std	Y+4, r21	; 0x04
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1484
                        uint8_t  cvValue   = pDccMsg->Data[4];
    17be:	10 91 ab 38 	lds	r17, 0x38AB	; 0x8038ab <dcc+0x6>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1486

                        OpsInstructionType insType = (OpsInstructionType) ( (pDccMsg->Data[2] & 0b00001100) >> 2) ;
    17c2:	95 95       	asr	r25
    17c4:	87 95       	ror	r24
    17c6:	95 95       	asr	r25
    17c8:	87 95       	ror	r24
    17ca:	83 70       	andi	r24, 0x03	; 3
    17cc:	99 27       	eor	r25, r25
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1489

                        DB_PRINT ("eDP: OPS Mode Instruction:%d", insType);
                        switch (insType)
    17ce:	82 30       	cpi	r24, 0x02	; 2
    17d0:	91 05       	cpc	r25, r1
    17d2:	a9 f0       	breq	.+42     	; 0x17fe <main+0x72c>
    17d4:	03 97       	sbiw	r24, 0x03	; 3
    17d6:	09 f4       	brne	.+2      	; 0x17da <main+0x708>
    17d8:	00 cf       	rjmp	.-512    	; 0x15da <main+0x508>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1467

                        // Check if this command is for our address or the broadcast address
                        if (DccProcState.Flags & FLAGS_OUTPUT_ADDRESS_MODE)
                        {
                            DB_PRINT ("eDP: Check Output Address:%d", OutputAddress);
                            if ( (OutputAddress != getMyAddr()) && (OutputAddress < 2045))
    17da:	90 cd       	rjmp	.-1248   	; 0x12fc <main+0x22a>
    17dc:	0d 3f       	cpi	r16, 0xFD	; 253
    17de:	17 40       	sbci	r17, 0x07	; 7
    17e0:	d4 f6       	brge	.-76     	; 0x1796 <main+0x6c4>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1476
                            }
                        }
                        else
                        {
                            DB_PRINT ("eDP: Check Board Address:%d", BoardAddress);
                            if ( (BoardAddress != getMyAddr()) && (BoardAddress < 511))
    17e2:	8c cd       	rjmp	.-1256   	; 0x12fc <main+0x22a>
    17e4:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <getMyAddr()>
    17e8:	cb 80       	ldd	r12, Y+3	; 0x03
    17ea:	dc 80       	ldd	r13, Y+4	; 0x04
    17ec:	8c 15       	cp	r24, r12
    17ee:	9d 05       	cpc	r25, r13
    17f0:	91 f2       	breq	.-92     	; 0x1796 <main+0x6c4>
    17f2:	2f ef       	ldi	r18, 0xFF	; 255
    17f4:	c2 16       	cp	r12, r18
    17f6:	21 e0       	ldi	r18, 0x01	; 1
    17f8:	d2 06       	cpc	r13, r18
    17fa:	69 f2       	breq	.-102    	; 0x1796 <main+0x6c4>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1510
                        // and C describes whether the operation is a verify bit or a write bit operation.
                        // C = "1" WRITE BIT
                        // C = "0" VERIFY BIT
                        case OPS_INS_BIT_MANIPULATION:
                            // Make sure its a Write Bit Manipulation
                            if ( (cvValue & 0b00010000) && validCV (cvAddress, 1))
    17fc:	7f cd       	rjmp	.-1282   	; 0x12fc <main+0x22a>
    17fe:	14 ff       	sbrs	r17, 4
    1800:	7d cd       	rjmp	.-1286   	; 0x12fc <main+0x22a>
    1802:	61 e0       	ldi	r22, 0x01	; 1
    1804:	8b 81       	ldd	r24, Y+3	; 0x03
    1806:	9c 81       	ldd	r25, Y+4	; 0x04
    1808:	eb d8       	rcall	.-3626   	; 0x9e0 <validCV(unsigned int, unsigned char)>
    180a:	88 23       	and	r24, r24
    180c:	09 f4       	brne	.+2      	; 0x1810 <main+0x73e>
    180e:	76 cd       	rjmp	.-1300   	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1512
                            {
                                uint8_t currentValue = readCV (cvAddress);
    1810:	8b 81       	ldd	r24, Y+3	; 0x03
    1812:	9c 81       	ldd	r25, Y+4	; 0x04
    1814:	0e 94 61 03 	call	0x6c2	; 0x6c2 <readCV(unsigned int)>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1513
                                uint8_t newValueMask = 1 << (cvValue & 0b00000111);
    1818:	91 2f       	mov	r25, r17
    181a:	97 70       	andi	r25, 0x07	; 7
    181c:	61 e0       	ldi	r22, 0x01	; 1
    181e:	70 e0       	ldi	r23, 0x00	; 0
    1820:	01 c0       	rjmp	.+2      	; 0x1824 <main+0x752>
    1822:	66 0f       	add	r22, r22
    1824:	9a 95       	dec	r25
    1826:	ea f7       	brpl	.-6      	; 0x1822 <main+0x750>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1514
                                if (cvValue & 0b00001000)
    1828:	13 ff       	sbrs	r17, 3
    182a:	02 c0       	rjmp	.+4      	; 0x1830 <main+0x75e>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1515
                                    writeCV (cvAddress, currentValue | newValueMask);
    182c:	68 2b       	or	r22, r24
    182e:	dd ce       	rjmp	.-582    	; 0x15ea <main+0x518>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1517
                                else
                                    writeCV (cvAddress, currentValue & ~newValueMask);
    1830:	60 95       	com	r22
    1832:	68 23       	and	r22, r24
    1834:	da ce       	rjmp	.-588    	; 0x15ea <main+0x518>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1527
                }
            }

            #ifdef NMRA_DCC_PROCESS_MULTIFUNCTION
            // Multi Function Decoders (14-bit address)
            else if (pDccMsg->Data[0] < 232)
    1836:	88 3e       	cpi	r24, 0xE8	; 232
    1838:	08 f0       	brcs	.+2      	; 0x183c <main+0x76a>
    183a:	60 cd       	rjmp	.-1344   	; 0x12fc <main+0x22a>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1530
            {
                uint16_t Address ;
                Address = ( (pDccMsg->Data[0] - 192) << 8) | pDccMsg->Data[1];
    183c:	80 5c       	subi	r24, 0xC0	; 192
    183e:	99 0b       	sbc	r25, r25
    1840:	30 91 a8 38 	lds	r19, 0x38A8	; 0x8038a8 <dcc+0x3>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/NmraDcc.cpp:1532
                //TODO should we convert Address to 1 .. 10239 ?
                processMultiFunctionMessage (Address, DCC_ADDR_LONG, pDccMsg->Data[2], pDccMsg->Data[3], pDccMsg->Data[4]) ;
    1844:	00 91 ab 38 	lds	r16, 0x38AB	; 0x8038ab <dcc+0x6>
    1848:	20 91 aa 38 	lds	r18, 0x38AA	; 0x8038aa <dcc+0x5>
    184c:	40 91 a9 38 	lds	r20, 0x38A9	; 0x8038a9 <dcc+0x4>
    1850:	61 e0       	ldi	r22, 0x01	; 1
    1852:	70 e0       	ldi	r23, 0x00	; 0
    1854:	a3 2f       	mov	r26, r19
    1856:	b8 2f       	mov	r27, r24
    1858:	cd 01       	movw	r24, r26
    185a:	7b ce       	rjmp	.-778    	; 0x1552 <main+0x480>
throttle():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:111

void throttle()
{
    static uint8 state = stationairy ;

    switch( state )
    185c:	83 30       	cpi	r24, 0x03	; 3
    185e:	09 f4       	brne	.+2      	; 0x1862 <main+0x790>
    1860:	70 c0       	rjmp	.+224    	; 0x1942 <main+0x870>
    1862:	84 30       	cpi	r24, 0x04	; 4
    1864:	09 f0       	breq	.+2      	; 0x1868 <main+0x796>
    1866:	f3 cc       	rjmp	.-1562   	; 0x124e <main+0x17c>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:143
        }
        END_REPEAT
        break ;

    case decelerating:
        REPEAT_MS( my.decelTime )
    1868:	0e 94 b2 02 	call	0x564	; 0x564 <millis>
    186c:	00 91 55 38 	lds	r16, 0x3855	; 0x803855 <throttle()::previousTime>
    1870:	10 91 56 38 	lds	r17, 0x3856	; 0x803856 <throttle()::previousTime+0x1>
    1874:	20 91 57 38 	lds	r18, 0x3857	; 0x803857 <throttle()::previousTime+0x2>
    1878:	30 91 58 38 	lds	r19, 0x3858	; 0x803858 <throttle()::previousTime+0x3>
    187c:	6b 01       	movw	r12, r22
    187e:	7c 01       	movw	r14, r24
    1880:	c0 1a       	sub	r12, r16
    1882:	d1 0a       	sbc	r13, r17
    1884:	e2 0a       	sbc	r14, r18
    1886:	f3 0a       	sbc	r15, r19
    1888:	97 01       	movw	r18, r14
    188a:	86 01       	movw	r16, r12
    188c:	40 91 96 38 	lds	r20, 0x3896	; 0x803896 <my+0x3>
    1890:	c4 2e       	mov	r12, r20
    1892:	d1 2c       	mov	r13, r1
    1894:	f1 2c       	mov	r15, r1
    1896:	e1 2c       	mov	r14, r1
    1898:	0c 15       	cp	r16, r12
    189a:	1d 05       	cpc	r17, r13
    189c:	2e 05       	cpc	r18, r14
    189e:	3f 05       	cpc	r19, r15
    18a0:	08 f4       	brcc	.+2      	; 0x18a4 <main+0x7d2>
    18a2:	d5 cc       	rjmp	.-1622   	; 0x124e <main+0x17c>
    18a4:	60 93 55 38 	sts	0x3855, r22	; 0x803855 <throttle()::previousTime>
    18a8:	70 93 56 38 	sts	0x3856, r23	; 0x803856 <throttle()::previousTime+0x1>
    18ac:	80 93 57 38 	sts	0x3857, r24	; 0x803857 <throttle()::previousTime+0x2>
    18b0:	90 93 58 38 	sts	0x3858, r25	; 0x803858 <throttle()::previousTime+0x3>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:145
        {
            followSpeed() ;
    18b4:	17 da       	rcall	.-3026   	; 0xce4 <followSpeed()>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:147

            if(      currentSpeed ==        0 ) state = stationairy ;
    18b6:	80 91 5d 38 	lds	r24, 0x385D	; 0x80385d <currentSpeed>
    18ba:	81 11       	cpse	r24, r1
    18bc:	71 c0       	rjmp	.+226    	; 0x19a0 <main+0x8ce>
    18be:	10 92 89 38 	sts	0x3889, r1	; 0x803889 <throttle()::state>
    18c2:	c5 cc       	rjmp	.-1654   	; 0x124e <main+0x17c>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:114
    static uint8 state = stationairy ;

    switch( state )
    {
    case stationairy:
        if( setPoint > 0 ) state = kickStart ;
    18c4:	80 91 88 38 	lds	r24, 0x3888	; 0x803888 <setPoint>
    18c8:	18 16       	cp	r1, r24
    18ca:	0c f0       	brlt	.+2      	; 0x18ce <main+0x7fc>
    18cc:	c0 cc       	rjmp	.-1664   	; 0x124e <main+0x17c>
    18ce:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:118
        break ;

    case kickStart:
        if( pwm.kickStart( my.kickStartTime ) ) state = accelerating ; // sets kick start, returns true when pulse has passed
    18d0:	80 93 89 38 	sts	0x3889, r24	; 0x803889 <throttle()::state>
    18d4:	bc cc       	rjmp	.-1672   	; 0x124e <main+0x17c>
kickStart():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:149

        *portx_p1 &= ~trackPin1 ; // ensure they are both OFF
        *portx_p2 &= ~trackPin2 ;

        if(dir) *portx_p1 |=  trackPin1 ; // set one high
        else    *portx_p2 |=  trackPin2 ;
    18d6:	e0 91 86 38 	lds	r30, 0x3886	; 0x803886 <pwm+0x24>
    18da:	f0 91 87 38 	lds	r31, 0x3887	; 0x803887 <pwm+0x25>
    18de:	80 81       	ld	r24, Z
    18e0:	90 91 6f 38 	lds	r25, 0x386F	; 0x80386f <pwm+0xd>
    18e4:	48 cd       	rjmp	.-1392   	; 0x1376 <main+0x2a4>
throttle():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:122
        break ;

    case cruising:
        REPEAT_MS( 50 )
    18e6:	0e 94 b2 02 	call	0x564	; 0x564 <millis>
    18ea:	00 91 5e 38 	lds	r16, 0x385E	; 0x80385e <throttle()::previousTime>
    18ee:	10 91 5f 38 	lds	r17, 0x385F	; 0x80385f <throttle()::previousTime+0x1>
    18f2:	20 91 60 38 	lds	r18, 0x3860	; 0x803860 <throttle()::previousTime+0x2>
    18f6:	30 91 61 38 	lds	r19, 0x3861	; 0x803861 <throttle()::previousTime+0x3>
    18fa:	6b 01       	movw	r12, r22
    18fc:	7c 01       	movw	r14, r24
    18fe:	c0 1a       	sub	r12, r16
    1900:	d1 0a       	sbc	r13, r17
    1902:	e2 0a       	sbc	r14, r18
    1904:	f3 0a       	sbc	r15, r19
    1906:	97 01       	movw	r18, r14
    1908:	86 01       	movw	r16, r12
    190a:	02 33       	cpi	r16, 0x32	; 50
    190c:	11 05       	cpc	r17, r1
    190e:	21 05       	cpc	r18, r1
    1910:	31 05       	cpc	r19, r1
    1912:	08 f4       	brcc	.+2      	; 0x1916 <main+0x844>
    1914:	9c cc       	rjmp	.-1736   	; 0x124e <main+0x17c>
    1916:	60 93 5e 38 	sts	0x385E, r22	; 0x80385e <throttle()::previousTime>
    191a:	70 93 5f 38 	sts	0x385F, r23	; 0x80385f <throttle()::previousTime+0x1>
    191e:	80 93 60 38 	sts	0x3860, r24	; 0x803860 <throttle()::previousTime+0x2>
    1922:	90 93 61 38 	sts	0x3861, r25	; 0x803861 <throttle()::previousTime+0x3>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:124
        {
            followSpeed() ;
    1926:	de d9       	rcall	.-3140   	; 0xce4 <followSpeed()>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:126

            if( setPoint > currentSpeed ) state = accelerating ;
    1928:	90 91 88 38 	lds	r25, 0x3888	; 0x803888 <setPoint>
    192c:	80 91 5d 38 	lds	r24, 0x385D	; 0x80385d <currentSpeed>
    1930:	89 17       	cp	r24, r25
    1932:	0c f4       	brge	.+2      	; 0x1936 <main+0x864>
    1934:	59 cd       	rjmp	.-1358   	; 0x13e8 <main+0x316>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:127
            if( setPoint < currentSpeed ) state = decelerating ;
    1936:	98 17       	cp	r25, r24
    1938:	0c f0       	brlt	.+2      	; 0x193c <main+0x86a>
    193a:	89 cc       	rjmp	.-1774   	; 0x124e <main+0x17c>
    193c:	50 92 89 38 	sts	0x3889, r5	; 0x803889 <throttle()::state>
    1940:	86 cc       	rjmp	.-1780   	; 0x124e <main+0x17c>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:133
        }
        END_REPEAT
        break ;

    case accelerating:
        REPEAT_MS( my.accelTime )
    1942:	0e 94 b2 02 	call	0x564	; 0x564 <millis>
    1946:	00 91 59 38 	lds	r16, 0x3859	; 0x803859 <throttle()::previousTime>
    194a:	10 91 5a 38 	lds	r17, 0x385A	; 0x80385a <throttle()::previousTime+0x1>
    194e:	20 91 5b 38 	lds	r18, 0x385B	; 0x80385b <throttle()::previousTime+0x2>
    1952:	30 91 5c 38 	lds	r19, 0x385C	; 0x80385c <throttle()::previousTime+0x3>
    1956:	6b 01       	movw	r12, r22
    1958:	7c 01       	movw	r14, r24
    195a:	c0 1a       	sub	r12, r16
    195c:	d1 0a       	sbc	r13, r17
    195e:	e2 0a       	sbc	r14, r18
    1960:	f3 0a       	sbc	r15, r19
    1962:	97 01       	movw	r18, r14
    1964:	86 01       	movw	r16, r12
    1966:	40 91 95 38 	lds	r20, 0x3895	; 0x803895 <my+0x2>
    196a:	c4 2e       	mov	r12, r20
    196c:	d1 2c       	mov	r13, r1
    196e:	f1 2c       	mov	r15, r1
    1970:	e1 2c       	mov	r14, r1
    1972:	0c 15       	cp	r16, r12
    1974:	1d 05       	cpc	r17, r13
    1976:	2e 05       	cpc	r18, r14
    1978:	3f 05       	cpc	r19, r15
    197a:	08 f4       	brcc	.+2      	; 0x197e <main+0x8ac>
    197c:	68 cc       	rjmp	.-1840   	; 0x124e <main+0x17c>
    197e:	60 93 59 38 	sts	0x3859, r22	; 0x803859 <throttle()::previousTime>
    1982:	70 93 5a 38 	sts	0x385A, r23	; 0x80385a <throttle()::previousTime+0x1>
    1986:	80 93 5b 38 	sts	0x385B, r24	; 0x80385b <throttle()::previousTime+0x2>
    198a:	90 93 5c 38 	sts	0x385C, r25	; 0x80385c <throttle()::previousTime+0x3>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:135
        {
            followSpeed() ;
    198e:	aa d9       	rcall	.-3244   	; 0xce4 <followSpeed()>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:137

            if( currentSpeed == setPoint ) state = cruising ;
    1990:	90 91 5d 38 	lds	r25, 0x385D	; 0x80385d <currentSpeed>
    1994:	80 91 88 38 	lds	r24, 0x3888	; 0x803888 <setPoint>
    1998:	98 13       	cpse	r25, r24
    199a:	59 cc       	rjmp	.-1870   	; 0x124e <main+0x17c>
    199c:	82 e0       	ldi	r24, 0x02	; 2
    199e:	98 cf       	rjmp	.-208    	; 0x18d0 <main+0x7fe>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:148
        REPEAT_MS( my.decelTime )
        {
            followSpeed() ;

            if(      currentSpeed ==        0 ) state = stationairy ;
            else if( currentSpeed == setPoint ) state = cruising ;
    19a0:	90 91 88 38 	lds	r25, 0x3888	; 0x803888 <setPoint>
    19a4:	89 13       	cpse	r24, r25
    19a6:	53 cc       	rjmp	.-1882   	; 0x124e <main+0x17c>
    19a8:	f9 cf       	rjmp	.-14     	; 0x199c <main+0x8ca>
updateFunc():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:164
    // AND dir depened is OFF OR direction is OK
    
    // fetch live from EEPROM?

    A.set = A.state 
    && ( !A.dir_dependend | (dir ^ A.inverted) ) ;
    19aa:	20 91 8f 38 	lds	r18, 0x388F	; 0x80388f <A>
    19ae:	27 ff       	sbrs	r18, 7
    19b0:	19 c0       	rjmp	.+50     	; 0x19e4 <main+0x912>
    19b2:	80 91 8e 38 	lds	r24, 0x388E	; 0x80388e <dir>
    19b6:	26 fb       	bst	r18, 6
    19b8:	dd 24       	eor	r13, r13
    19ba:	d0 f8       	bld	r13, 0
    19bc:	d9 82       	std	Y+1, r13	; 0x01
    19be:	1a 82       	std	Y+2, r1	; 0x02
    19c0:	e9 80       	ldd	r14, Y+1	; 0x01
    19c2:	fa 80       	ldd	r15, Y+2	; 0x02
    19c4:	e8 26       	eor	r14, r24
    19c6:	c7 01       	movw	r24, r14
    19c8:	22 95       	swap	r18
    19ca:	26 95       	lsr	r18
    19cc:	27 70       	andi	r18, 0x07	; 7
    19ce:	31 e0       	ldi	r19, 0x01	; 1
    19d0:	23 27       	eor	r18, r19
    19d2:	20 fb       	bst	r18, 0
    19d4:	aa 24       	eor	r10, r10
    19d6:	a0 f8       	bld	r10, 0
    19d8:	b1 2c       	mov	r11, r1
    19da:	8a 29       	or	r24, r10
    19dc:	9b 29       	or	r25, r11
    19de:	61 e0       	ldi	r22, 0x01	; 1
    19e0:	89 2b       	or	r24, r25
    19e2:	09 f4       	brne	.+2      	; 0x19e6 <main+0x914>
main():
    19e4:	60 e0       	ldi	r22, 0x00	; 0
updateFunc():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:163
    // State must be true
    // AND dir depened is OFF OR direction is OK
    
    // fetch live from EEPROM?

    A.set = A.state 
    19e6:	80 91 90 38 	lds	r24, 0x3890	; 0x803890 <A+0x1>
    19ea:	60 fb       	bst	r22, 0
    19ec:	80 f9       	bld	r24, 0
    19ee:	80 93 90 38 	sts	0x3890, r24	; 0x803890 <A+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:167
    && ( !A.dir_dependend | (dir ^ A.inverted) ) ;

    B.set = B.state 
    && ( !B.dir_dependend | (dir ^ B.inverted) ) ;
    19f2:	20 91 8a 38 	lds	r18, 0x388A	; 0x80388a <B>
    19f6:	27 ff       	sbrs	r18, 7
    19f8:	17 c0       	rjmp	.+46     	; 0x1a28 <main+0x956>
    19fa:	80 91 8e 38 	lds	r24, 0x388E	; 0x80388e <dir>
    19fe:	26 fb       	bst	r18, 6
    1a00:	88 24       	eor	r8, r8
    1a02:	80 f8       	bld	r8, 0
    1a04:	91 2c       	mov	r9, r1
    1a06:	a4 01       	movw	r20, r8
    1a08:	48 27       	eor	r20, r24
    1a0a:	ca 01       	movw	r24, r20
    1a0c:	22 95       	swap	r18
    1a0e:	26 95       	lsr	r18
    1a10:	27 70       	andi	r18, 0x07	; 7
    1a12:	31 e0       	ldi	r19, 0x01	; 1
    1a14:	23 27       	eor	r18, r19
    1a16:	20 fb       	bst	r18, 0
    1a18:	66 24       	eor	r6, r6
    1a1a:	60 f8       	bld	r6, 0
    1a1c:	71 2c       	mov	r7, r1
    1a1e:	86 29       	or	r24, r6
    1a20:	97 29       	or	r25, r7
    1a22:	21 e0       	ldi	r18, 0x01	; 1
    1a24:	89 2b       	or	r24, r25
    1a26:	09 f4       	brne	.+2      	; 0x1a2a <main+0x958>
main():
    1a28:	20 e0       	ldi	r18, 0x00	; 0
updateFunc():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:166
    // fetch live from EEPROM?

    A.set = A.state 
    && ( !A.dir_dependend | (dir ^ A.inverted) ) ;

    B.set = B.state 
    1a2a:	80 91 8b 38 	lds	r24, 0x388B	; 0x80388b <B+0x1>
    1a2e:	20 fb       	bst	r18, 0
    1a30:	80 f9       	bld	r24, 0
    1a32:	80 93 8b 38 	sts	0x388B, r24	; 0x80388b <B+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:170
    && ( !B.dir_dependend | (dir ^ B.inverted) ) ;


    if( A.pulseTime > 0 ) // if pulse time is enabled.
    1a36:	80 91 90 38 	lds	r24, 0x3890	; 0x803890 <A+0x1>
    1a3a:	28 2f       	mov	r18, r24
    1a3c:	26 95       	lsr	r18
    1a3e:	26 95       	lsr	r18
    1a40:	90 91 91 38 	lds	r25, 0x3891	; 0x803891 <A+0x2>
    1a44:	92 95       	swap	r25
    1a46:	99 0f       	add	r25, r25
    1a48:	99 0f       	add	r25, r25
    1a4a:	90 7c       	andi	r25, 0xC0	; 192
    1a4c:	92 2b       	or	r25, r18
    1a4e:	09 f4       	brne	.+2      	; 0x1a52 <main+0x980>
    1a50:	4e c0       	rjmp	.+156    	; 0x1aee <main+0xa1c>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:172
    {
        if( A.set == 0 ) A.trig = 1 ; // reset trigger when output is turned off
    1a52:	80 fd       	sbrc	r24, 0
    1a54:	03 c0       	rjmp	.+6      	; 0x1a5c <main+0x98a>
    1a56:	82 60       	ori	r24, 0x02	; 2
    1a58:	80 93 90 38 	sts	0x3890, r24	; 0x803890 <A+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:174

        if( A.trig == 1 )
    1a5c:	80 91 90 38 	lds	r24, 0x3890	; 0x803890 <A+0x1>
    1a60:	81 ff       	sbrs	r24, 1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:175
        {   A.trig  = 0 ;
    1a62:	1b c0       	rjmp	.+54     	; 0x1a9a <main+0x9c8>
    1a64:	8d 7f       	andi	r24, 0xFD	; 253
    1a66:	80 93 90 38 	sts	0x3890, r24	; 0x803890 <A+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:177

            A.prevTime = millis() ;
    1a6a:	0e 94 b2 02 	call	0x564	; 0x564 <millis>
    1a6e:	86 2f       	mov	r24, r22
    1a70:	88 0f       	add	r24, r24
    1a72:	88 0f       	add	r24, r24
    1a74:	90 91 91 38 	lds	r25, 0x3891	; 0x803891 <A+0x2>
    1a78:	93 70       	andi	r25, 0x03	; 3
    1a7a:	98 2b       	or	r25, r24
    1a7c:	90 93 91 38 	sts	0x3891, r25	; 0x803891 <A+0x2>
    1a80:	62 95       	swap	r22
    1a82:	66 95       	lsr	r22
    1a84:	66 95       	lsr	r22
    1a86:	63 70       	andi	r22, 0x03	; 3
    1a88:	80 91 92 38 	lds	r24, 0x3892	; 0x803892 <A+0x3>
    1a8c:	8c 7f       	andi	r24, 0xFC	; 252
    1a8e:	68 2b       	or	r22, r24
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:178
            digitalWrite( 2, HIGH ) ;
    1a90:	60 93 92 38 	sts	0x3892, r22	; 0x803892 <A+0x3>
    1a94:	61 e0       	ldi	r22, 0x01	; 1
    1a96:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:181
        }

        if( millis() - ((uint32)100*A.pulseTime) >= ((uint32)100*A.prevTime)) 
    1a98:	a4 d9       	rcall	.-3256   	; 0xde2 <digitalWrite>
    1a9a:	0e 94 b2 02 	call	0x564	; 0x564 <millis>
    1a9e:	7b 01       	movw	r14, r22
    1aa0:	8c 01       	movw	r16, r24
    1aa2:	20 91 90 38 	lds	r18, 0x3890	; 0x803890 <A+0x1>
    1aa6:	26 95       	lsr	r18
    1aa8:	26 95       	lsr	r18
    1aaa:	40 91 91 38 	lds	r20, 0x3891	; 0x803891 <A+0x2>
    1aae:	84 2f       	mov	r24, r20
    1ab0:	82 95       	swap	r24
    1ab2:	88 0f       	add	r24, r24
    1ab4:	88 0f       	add	r24, r24
    1ab6:	80 7c       	andi	r24, 0xC0	; 192
    1ab8:	28 2b       	or	r18, r24
    1aba:	30 e0       	ldi	r19, 0x00	; 0
    1abc:	a4 e6       	ldi	r26, 0x64	; 100
    1abe:	b0 e0       	ldi	r27, 0x00	; 0
    1ac0:	d7 d0       	rcall	.+430    	; 0x1c70 <__umulhisi3>
    1ac2:	e6 1a       	sub	r14, r22
    1ac4:	f7 0a       	sbc	r15, r23
    1ac6:	08 0b       	sbc	r16, r24
    1ac8:	19 0b       	sbc	r17, r25
    1aca:	46 95       	lsr	r20
    1acc:	46 95       	lsr	r20
    1ace:	20 91 92 38 	lds	r18, 0x3892	; 0x803892 <A+0x3>
    1ad2:	22 95       	swap	r18
    1ad4:	22 0f       	add	r18, r18
    1ad6:	22 0f       	add	r18, r18
    1ad8:	20 7c       	andi	r18, 0xC0	; 192
    1ada:	42 2b       	or	r20, r18
    1adc:	24 2f       	mov	r18, r20
    1ade:	30 e0       	ldi	r19, 0x00	; 0
    1ae0:	c7 d0       	rcall	.+398    	; 0x1c70 <__umulhisi3>
    1ae2:	e6 16       	cp	r14, r22
    1ae4:	f7 06       	cpc	r15, r23
    1ae6:	08 07       	cpc	r16, r24
    1ae8:	19 07       	cpc	r17, r25
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:183
        {
            digitalWrite( 2,  LOW ) ;
    1aea:	18 f0       	brcs	.+6      	; 0x1af2 <main+0xa20>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:188
        }
    }
    else
    {
        digitalWrite( 2, A.set ) ;
    1aec:	60 e0       	ldi	r22, 0x00	; 0
    1aee:	82 e0       	ldi	r24, 0x02	; 2
    1af0:	78 d9       	rcall	.-3344   	; 0xde2 <digitalWrite>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:191
    }

    if( B.pulseTime > 0 ) // if pulse time is enabled.
    1af2:	60 91 8b 38 	lds	r22, 0x388B	; 0x80388b <B+0x1>
    1af6:	96 2f       	mov	r25, r22
    1af8:	96 95       	lsr	r25
    1afa:	96 95       	lsr	r25
    1afc:	80 91 8c 38 	lds	r24, 0x388C	; 0x80388c <B+0x2>
    1b00:	82 95       	swap	r24
    1b02:	88 0f       	add	r24, r24
    1b04:	88 0f       	add	r24, r24
    1b06:	80 7c       	andi	r24, 0xC0	; 192
    1b08:	89 2b       	or	r24, r25
    1b0a:	09 f4       	brne	.+2      	; 0x1b0e <main+0xa3c>
    1b0c:	52 c0       	rjmp	.+164    	; 0x1bb2 <main+0xae0>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:193
    {
        if( B.set == 0 ) B.trig = 1 ; // reset trigger when output is turned off
    1b0e:	60 fd       	sbrc	r22, 0
    1b10:	03 c0       	rjmp	.+6      	; 0x1b18 <main+0xa46>
    1b12:	62 60       	ori	r22, 0x02	; 2
    1b14:	60 93 8b 38 	sts	0x388B, r22	; 0x80388b <B+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:195

        if( B.trig == 1 )
    1b18:	80 91 8b 38 	lds	r24, 0x388B	; 0x80388b <B+0x1>
    1b1c:	81 ff       	sbrs	r24, 1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:196
        {   B.trig  = 0 ;
    1b1e:	1b c0       	rjmp	.+54     	; 0x1b56 <main+0xa84>
    1b20:	8d 7f       	andi	r24, 0xFD	; 253
    1b22:	80 93 8b 38 	sts	0x388B, r24	; 0x80388b <B+0x1>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:198

            B.prevTime = millis() ;
    1b26:	0e 94 b2 02 	call	0x564	; 0x564 <millis>
    1b2a:	86 2f       	mov	r24, r22
    1b2c:	88 0f       	add	r24, r24
    1b2e:	88 0f       	add	r24, r24
    1b30:	90 91 8c 38 	lds	r25, 0x388C	; 0x80388c <B+0x2>
    1b34:	93 70       	andi	r25, 0x03	; 3
    1b36:	98 2b       	or	r25, r24
    1b38:	90 93 8c 38 	sts	0x388C, r25	; 0x80388c <B+0x2>
    1b3c:	62 95       	swap	r22
    1b3e:	66 95       	lsr	r22
    1b40:	66 95       	lsr	r22
    1b42:	63 70       	andi	r22, 0x03	; 3
    1b44:	80 91 8d 38 	lds	r24, 0x388D	; 0x80388d <B+0x3>
    1b48:	8c 7f       	andi	r24, 0xFC	; 252
    1b4a:	68 2b       	or	r22, r24
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:199
            digitalWrite( 2, HIGH ) ;
    1b4c:	60 93 8d 38 	sts	0x388D, r22	; 0x80388d <B+0x3>
    1b50:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:202
        }

        if( millis() - ((uint32)100*B.pulseTime) >= ((uint32)100*B.prevTime)) 
    1b52:	82 e0       	ldi	r24, 0x02	; 2
    1b54:	46 d9       	rcall	.-3444   	; 0xde2 <digitalWrite>
    1b56:	0e 94 b2 02 	call	0x564	; 0x564 <millis>
    1b5a:	7b 01       	movw	r14, r22
    1b5c:	8c 01       	movw	r16, r24
    1b5e:	20 91 8b 38 	lds	r18, 0x388B	; 0x80388b <B+0x1>
    1b62:	26 95       	lsr	r18
    1b64:	26 95       	lsr	r18
    1b66:	40 91 8c 38 	lds	r20, 0x388C	; 0x80388c <B+0x2>
    1b6a:	84 2f       	mov	r24, r20
    1b6c:	82 95       	swap	r24
    1b6e:	88 0f       	add	r24, r24
    1b70:	88 0f       	add	r24, r24
    1b72:	80 7c       	andi	r24, 0xC0	; 192
    1b74:	28 2b       	or	r18, r24
    1b76:	30 e0       	ldi	r19, 0x00	; 0
    1b78:	a4 e6       	ldi	r26, 0x64	; 100
    1b7a:	b0 e0       	ldi	r27, 0x00	; 0
    1b7c:	79 d0       	rcall	.+242    	; 0x1c70 <__umulhisi3>
    1b7e:	e6 1a       	sub	r14, r22
    1b80:	f7 0a       	sbc	r15, r23
    1b82:	08 0b       	sbc	r16, r24
    1b84:	19 0b       	sbc	r17, r25
    1b86:	46 95       	lsr	r20
    1b88:	46 95       	lsr	r20
    1b8a:	20 91 8d 38 	lds	r18, 0x388D	; 0x80388d <B+0x3>
    1b8e:	22 95       	swap	r18
    1b90:	22 0f       	add	r18, r18
    1b92:	22 0f       	add	r18, r18
    1b94:	20 7c       	andi	r18, 0xC0	; 192
    1b96:	42 2b       	or	r20, r18
    1b98:	24 2f       	mov	r18, r20
    1b9a:	30 e0       	ldi	r19, 0x00	; 0
    1b9c:	69 d0       	rcall	.+210    	; 0x1c70 <__umulhisi3>
    1b9e:	e6 16       	cp	r14, r22
    1ba0:	f7 06       	cpc	r15, r23
    1ba2:	08 07       	cpc	r16, r24
    1ba4:	19 07       	cpc	r17, r25
    1ba6:	08 f4       	brcc	.+2      	; 0x1baa <main+0xad8>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:204
        {
            digitalWrite( 2,  LOW ) ;
    1ba8:	52 cb       	rjmp	.-2396   	; 0x124e <main+0x17c>
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:209
        }
    }
    else
    {
        digitalWrite( 2, B.set ) ;
    1baa:	60 e0       	ldi	r22, 0x00	; 0
    1bac:	82 e0       	ldi	r24, 0x02	; 2
    1bae:	19 d9       	rcall	.-3534   	; 0xde2 <digitalWrite>
    1bb0:	4e cb       	rjmp	.-2404   	; 0x124e <main+0x17c>
    1bb2:	61 70       	andi	r22, 0x01	; 1
    1bb4:	fb cf       	rjmp	.-10     	; 0x1bac <main+0xada>
begin():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:35
    portx_p1      = portOutputRegister( port1 );

    if( trackPin2 != 255 )
    {
        uint8_t port2 = digitalPinToPort( trackPin2 );
        trackPin2     = digitalPinToBitMask( trackPin2 );
    1bb6:	8f ef       	ldi	r24, 0xFF	; 255
    1bb8:	80 93 6f 38 	sts	0x386F, r24	; 0x80386f <pwm+0xd>
main():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:36
        portx_p2      = portOutputRegister( port2 );
    1bbc:	90 e0       	ldi	r25, 0x00	; 0
    1bbe:	80 e0       	ldi	r24, 0x00	; 0
    1bc0:	37 cb       	rjmp	.-2450   	; 0x1230 <main+0x15e>

00001bc2 <_GLOBAL__sub_I_speed>:
_GLOBAL__sub_I_speed():
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:13
    Fmin = _Fmin ;
    Fmax = _Fmax ;
    sensePin = 255 ;
}

Weistra::Weistra(uint8_t _pin1, uint8_t _pin2, uint8_t _Fmin, uint8_t _Fmax ) 
    1bc2:	e2 e6       	ldi	r30, 0x62	; 98
    1bc4:	f8 e3       	ldi	r31, 0x38	; 56
    1bc6:	12 8a       	std	Z+18, r1	; 0x12
    1bc8:	84 e6       	ldi	r24, 0x64	; 100
    1bca:	83 8b       	std	Z+19, r24	; 0x13
    1bcc:	10 8e       	std	Z+24, r1	; 0x18
    1bce:	11 8e       	std	Z+25, r1	; 0x19
    1bd0:	14 8e       	std	Z+28, r1	; 0x1c
    1bd2:	15 8e       	std	Z+29, r1	; 0x1d
    1bd4:	16 8e       	std	Z+30, r1	; 0x1e
    1bd6:	17 8e       	std	Z+31, r1	; 0x1f
    1bd8:	2a e0       	ldi	r18, 0x0A	; 10
    1bda:	30 e0       	ldi	r19, 0x00	; 0
    1bdc:	20 a3       	std	Z+32, r18	; 0x20
    1bde:	31 a3       	std	Z+33, r19	; 0x21
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:15
{ // constructor
    trackPin1 = _pin1;
    1be0:	91 e0       	ldi	r25, 0x01	; 1
    1be2:	94 87       	std	Z+12, r25	; 0x0c
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:16
    trackPin2 = _pin2;
    1be4:	92 e0       	ldi	r25, 0x02	; 2
    1be6:	95 87       	std	Z+13, r25	; 0x0d
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:17
    Fmin = _Fmin ;
    1be8:	92 e3       	ldi	r25, 0x32	; 50
    1bea:	90 8b       	std	Z+16, r25	; 0x10
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:18
    Fmax = _Fmax ;
    1bec:	81 8b       	std	Z+17, r24	; 0x11
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS\src/weistra.cpp:19
    sensePin = 255 ;
    1bee:	8f ef       	ldi	r24, 0xFF	; 255
    1bf0:	87 8b       	std	Z+23, r24	; 0x17
C:\Users\sknippels\Dropbox\Train-Science-DIY\SOFTWARE\LoPiTS-XS/LoPiTS-XS.ino:339

void notifyCVResetFactoryDefault()
{
    dcc.setCV(511, 123 ) ; // ensure that new CV will be loaded
    loadCV() ;
    1bf2:	08 95       	ret

00001bf4 <__mulsi3>:
__mulsi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:648
    1bf4:	db 01       	movw	r26, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:649
    1bf6:	8f 93       	push	r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:650
    1bf8:	9f 93       	push	r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:651
    1bfa:	49 d0       	rcall	.+146    	; 0x1c8e <__muluhisi3>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:652
    1bfc:	bf 91       	pop	r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:653
    1bfe:	af 91       	pop	r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:655
    1c00:	a2 9f       	mul	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:656
    1c02:	80 0d       	add	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:657
    1c04:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:658
    1c06:	a3 9f       	mul	r26, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:659
    1c08:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:660
    1c0a:	b2 9f       	mul	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:661
    1c0c:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:662
    1c0e:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:663
    1c10:	08 95       	ret

00001c12 <__divmodhi4>:
__divmodhi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1440
    1c12:	97 fb       	bst	r25, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1441
    1c14:	07 2e       	mov	r0, r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1442
    1c16:	16 f4       	brtc	.+4      	; 0x1c1c <__divmodhi4+0xa>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1443
    1c18:	00 94       	com	r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1444
    1c1a:	06 d0       	rcall	.+12     	; 0x1c28 <__divmodhi4_neg1>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1446
    1c1c:	77 fd       	sbrc	r23, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1447
    1c1e:	08 d0       	rcall	.+16     	; 0x1c30 <__divmodhi4_neg2>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1448
    1c20:	46 d0       	rcall	.+140    	; 0x1cae <__udivmodhi4>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1449
    1c22:	07 fc       	sbrc	r0, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1450
    1c24:	05 d0       	rcall	.+10     	; 0x1c30 <__divmodhi4_neg2>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1451
    1c26:	3e f4       	brtc	.+14     	; 0x1c36 <__divmodhi4_exit>

00001c28 <__divmodhi4_neg1>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1454
    1c28:	90 95       	com	r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1455
    1c2a:	81 95       	neg	r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1456
    1c2c:	9f 4f       	sbci	r25, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1457
    1c2e:	08 95       	ret

00001c30 <__divmodhi4_neg2>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1460
    1c30:	70 95       	com	r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1461
    1c32:	61 95       	neg	r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1462
    1c34:	7f 4f       	sbci	r23, 0xFF	; 255

00001c36 <__divmodhi4_exit>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1464
    1c36:	08 95       	ret

00001c38 <__divmodsi4>:
__divmodsi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1686
    1c38:	05 2e       	mov	r0, r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1687
    1c3a:	97 fb       	bst	r25, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1688
    1c3c:	16 f4       	brtc	.+4      	; 0x1c42 <__divmodsi4+0xa>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1689
    1c3e:	00 94       	com	r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1690
    1c40:	0f d0       	rcall	.+30     	; 0x1c60 <__negsi2>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1692
    1c42:	57 fd       	sbrc	r21, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1694
    1c44:	05 d0       	rcall	.+10     	; 0x1c50 <__divmodsi4_neg2>
    1c46:	47 d0       	rcall	.+142    	; 0x1cd6 <__udivmodsi4>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1695
    1c48:	07 fc       	sbrc	r0, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1697
    1c4a:	02 d0       	rcall	.+4      	; 0x1c50 <__divmodsi4_neg2>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1698
    1c4c:	46 f4       	brtc	.+16     	; 0x1c5e <__divmodsi4_exit>
    1c4e:	08 c0       	rjmp	.+16     	; 0x1c60 <__negsi2>

00001c50 <__divmodsi4_neg2>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1701
    1c50:	50 95       	com	r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1702
    1c52:	40 95       	com	r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1703
    1c54:	30 95       	com	r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1704
    1c56:	21 95       	neg	r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1705
    1c58:	3f 4f       	sbci	r19, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1706
    1c5a:	4f 4f       	sbci	r20, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1707
    1c5c:	5f 4f       	sbci	r21, 0xFF	; 255

00001c5e <__divmodsi4_exit>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1709
    1c5e:	08 95       	ret

00001c60 <__negsi2>:
__negsi2():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1718
    1c60:	90 95       	com	r25
    1c62:	80 95       	com	r24
    1c64:	70 95       	com	r23
    1c66:	61 95       	neg	r22
    1c68:	7f 4f       	sbci	r23, 0xFF	; 255
    1c6a:	8f 4f       	sbci	r24, 0xFF	; 255
    1c6c:	9f 4f       	sbci	r25, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1719
    1c6e:	08 95       	ret

00001c70 <__umulhisi3>:
__umulhisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    1c70:	a2 9f       	mul	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    1c72:	b0 01       	movw	r22, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    1c74:	b3 9f       	mul	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    1c76:	c0 01       	movw	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    1c78:	a3 9f       	mul	r26, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    1c7a:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    1c7c:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    1c7e:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    1c80:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    1c82:	b2 9f       	mul	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    1c84:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    1c86:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    1c88:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    1c8a:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    1c8c:	08 95       	ret

00001c8e <__muluhisi3>:
__muluhisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    1c8e:	f0 df       	rcall	.-32     	; 0x1c70 <__umulhisi3>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    1c90:	a5 9f       	mul	r26, r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    1c92:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    1c94:	b4 9f       	mul	r27, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    1c96:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    1c98:	a4 9f       	mul	r26, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    1c9a:	80 0d       	add	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    1c9c:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    1c9e:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    1ca0:	08 95       	ret

00001ca2 <__mulshisi3>:
__mulshisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:603
    1ca2:	b7 ff       	sbrs	r27, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:605
    1ca4:	f4 cf       	rjmp	.-24     	; 0x1c8e <__muluhisi3>

00001ca6 <__mulohisi3>:
__mulohisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:613
    1ca6:	f3 df       	rcall	.-26     	; 0x1c8e <__muluhisi3>
    1ca8:	82 1b       	sub	r24, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:615
    1caa:	93 0b       	sbc	r25, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:616
    1cac:	08 95       	ret

00001cae <__udivmodhi4>:
__udivmodhi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:617
    1cae:	aa 1b       	sub	r26, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1409
    1cb0:	bb 1b       	sub	r27, r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1410
    1cb2:	51 e1       	ldi	r21, 0x11	; 17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1411
    1cb4:	07 c0       	rjmp	.+14     	; 0x1cc4 <__udivmodhi4_ep>

00001cb6 <__udivmodhi4_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1413
    1cb6:	aa 1f       	adc	r26, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1414
    1cb8:	bb 1f       	adc	r27, r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1415
    1cba:	a6 17       	cp	r26, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1416
    1cbc:	b7 07       	cpc	r27, r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1417
    1cbe:	10 f0       	brcs	.+4      	; 0x1cc4 <__udivmodhi4_ep>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1418
    1cc0:	a6 1b       	sub	r26, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1419
    1cc2:	b7 0b       	sbc	r27, r23

00001cc4 <__udivmodhi4_ep>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1421
    1cc4:	88 1f       	adc	r24, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1422
    1cc6:	99 1f       	adc	r25, r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1423
    1cc8:	5a 95       	dec	r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1424
    1cca:	a9 f7       	brne	.-22     	; 0x1cb6 <__udivmodhi4_loop>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1425
    1ccc:	80 95       	com	r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1426
    1cce:	90 95       	com	r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1428
    1cd0:	bc 01       	movw	r22, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1430
    1cd2:	cd 01       	movw	r24, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1432
    1cd4:	08 95       	ret

00001cd6 <__udivmodsi4>:
__udivmodsi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    1cd6:	a1 e2       	ldi	r26, 0x21	; 33
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    1cd8:	1a 2e       	mov	r1, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    1cda:	aa 1b       	sub	r26, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    1cdc:	bb 1b       	sub	r27, r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    1cde:	fd 01       	movw	r30, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    1ce0:	0d c0       	rjmp	.+26     	; 0x1cfc <__udivmodsi4_ep>

00001ce2 <__udivmodsi4_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    1ce2:	aa 1f       	adc	r26, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    1ce4:	bb 1f       	adc	r27, r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    1ce6:	ee 1f       	adc	r30, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    1ce8:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    1cea:	a2 17       	cp	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    1cec:	b3 07       	cpc	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    1cee:	e4 07       	cpc	r30, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    1cf0:	f5 07       	cpc	r31, r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    1cf2:	20 f0       	brcs	.+8      	; 0x1cfc <__udivmodsi4_ep>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    1cf4:	a2 1b       	sub	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    1cf6:	b3 0b       	sbc	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    1cf8:	e4 0b       	sbc	r30, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    1cfa:	f5 0b       	sbc	r31, r21

00001cfc <__udivmodsi4_ep>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    1cfc:	66 1f       	adc	r22, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    1cfe:	77 1f       	adc	r23, r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    1d00:	88 1f       	adc	r24, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    1d02:	99 1f       	adc	r25, r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    1d04:	1a 94       	dec	r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    1d06:	69 f7       	brne	.-38     	; 0x1ce2 <__udivmodsi4_loop>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    1d08:	60 95       	com	r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    1d0a:	70 95       	com	r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    1d0c:	80 95       	com	r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    1d0e:	90 95       	com	r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    1d10:	9b 01       	movw	r18, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    1d12:	ac 01       	movw	r20, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    1d14:	bd 01       	movw	r22, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    1d16:	cf 01       	movw	r24, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    1d18:	08 95       	ret

00001d1a <__tablejump2__>:
__tablejump2__():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    1d1a:	ee 0f       	add	r30, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    1d1c:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
    1d1e:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
    1d20:	f4 91       	lpm	r31, Z
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
    1d22:	e0 2d       	mov	r30, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
    1d24:	09 94       	ijmp

00001d26 <memcmp>:
memcmp():
    1d26:	fb 01       	movw	r30, r22
    1d28:	dc 01       	movw	r26, r24
    1d2a:	04 c0       	rjmp	.+8      	; 0x1d34 <memcmp+0xe>
    1d2c:	8d 91       	ld	r24, X+
    1d2e:	01 90       	ld	r0, Z+
    1d30:	80 19       	sub	r24, r0
    1d32:	21 f4       	brne	.+8      	; 0x1d3c <memcmp+0x16>
    1d34:	41 50       	subi	r20, 0x01	; 1
    1d36:	50 40       	sbci	r21, 0x00	; 0
    1d38:	c8 f7       	brcc	.-14     	; 0x1d2c <memcmp+0x6>
    1d3a:	88 1b       	sub	r24, r24
    1d3c:	99 0b       	sbc	r25, r25
    1d3e:	08 95       	ret

00001d40 <_exit>:
exit():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    1d40:	f8 94       	cli

00001d42 <__stop_program>:
__stop_program():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    1d42:	ff cf       	rjmp	.-2      	; 0x1d42 <__stop_program>
